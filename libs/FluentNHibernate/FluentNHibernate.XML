<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FluentNHibernate</name>
    </assembly>
    <members>
        <member name="T:FluentNHibernate.AutoMap.Alterations.AutoMappingOverrideAlteration">
            <summary>
            Built-in alteration for altering an AutoPersistenceModel with instance of IAutoMappingOverride&lt;T&gt;.
            </summary>
        </member>
        <member name="T:FluentNHibernate.AutoMap.Alterations.IAutoMappingAlteration">
            <summary>
            Provides a mechanism for altering an AutoPersistenceModel prior to
            the generation of mappings.
            </summary>
        </member>
        <member name="M:FluentNHibernate.AutoMap.Alterations.IAutoMappingAlteration.Alter(FluentNHibernate.AutoMap.AutoPersistenceModel)">
            <summary>
            Alter the model
            </summary>
            <param name="model">AutoPersistenceModel instance to alter</param>
        </member>
        <member name="M:FluentNHibernate.AutoMap.Alterations.AutoMappingOverrideAlteration.#ctor(System.Reflection.Assembly)">
            <summary>
            Constructor for AutoMappingOverrideAlteration.
            </summary>
            <param name="overrideAssembly">Assembly to load overrides from.</param>
        </member>
        <member name="M:FluentNHibernate.AutoMap.Alterations.AutoMappingOverrideAlteration.Alter(FluentNHibernate.AutoMap.AutoPersistenceModel)">
            <summary>
            Alter the model
            </summary>
            <remarks>
            Finds all types in the assembly (passed in the constructor) that implement IAutoMappingOverride&lt;T&gt;, then
            creates an AutoMap&lt;T&gt; and applies the override to it.
            </remarks>
            <param name="model">AutoPersistenceModel instance to alter</param>
        </member>
        <member name="T:FluentNHibernate.AutoMap.Alterations.IAutoMappingOverride`1">
            <summary>
            A mapping override for an auto mapped entity.
            </summary>
            <typeparam name="T">Entity who's auto-mapping you're overriding</typeparam>
        </member>
        <member name="M:FluentNHibernate.AutoMap.Alterations.IAutoMappingOverride`1.Override(FluentNHibernate.AutoMap.AutoMap{`0})">
            <summary>
            Alter the automapping for this type
            </summary>
            <param name="mapping">Automapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClasslike.Component``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Action{FluentNHibernate.Mapping.ComponentPart{``1}})">
            <summary>
            Maps a component
            </summary>
            <typeparam name="TEntity"></typeparam>
            <typeparam name="TComponent">Type of component</typeparam>
            <param name="expression">Component property</param>
            <param name="action">Component mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClasslike.HasMany``2(System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            CreateProperties a one-to-many relationship
            </summary>
            <typeparam name="TEntity"></typeparam>
            <typeparam name="TChild">Child object type</typeparam>
            <param name="expression">Expression to get property from</param>
            <returns>one-to-many part</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClasslike.HasMany``3(System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IDictionary{``1,``2}}})">
            <summary>
            CreateProperties a one-to-many relationship with a IDictionary
            </summary>
            <typeparam name="TEntity"></typeparam>
            <typeparam name="TKey">Dictionary key type</typeparam>
            <typeparam name="TChild">Child object type / Dictionary value type</typeparam>
            <param name="expression">Expression to get property from</param>
            <returns>one-to-many part</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClasslike.HasManyToMany``2(System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            CreateProperties a many-to-many relationship
            </summary>
            <typeparam name="TEntity"></typeparam>
            <typeparam name="TChild">Child object type</typeparam>
            <param name="expression">Expression to get property from</param>
            <returns>many-to-many part</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.Component``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Action{FluentNHibernate.Mapping.ComponentPart{``0}})">
            <summary>
            Maps a component
            </summary>
            <typeparam name="TComponent">Type of component</typeparam>
            <param name="expression">Component property</param>
            <param name="action">Component mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.Component``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{FluentNHibernate.Mapping.ComponentPart{``0}})">
            <summary>
            Maps a component
            </summary>
            <typeparam name="TComponent">Type of component</typeparam>
            <param name="expression">Component property</param>
            <param name="action">Component mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.MapHasMany``2(System.Linq.Expressions.Expression{System.Func{`0,``1}})">
            <summary>
            CreateProperties a one-to-many relationship
            </summary>
            <typeparam name="TChild">Child object type</typeparam>
            <typeparam name="TReturn">Property return type</typeparam>
            <param name="expression">Expression to get property from</param>
            <returns>one-to-many part</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
            <summary>
            CreateProperties a one-to-many relationship
            </summary>
            <typeparam name="TChild">Child object type</typeparam>
            <param name="expression">Expression to get property from</param>
            <returns>one-to-many part</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasMany``2(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IDictionary{``0,``1}}})">
            <summary>
            CreateProperties a one-to-many relationship with a IDictionary
            </summary>
            <typeparam name="TKey">Dictionary key type</typeparam>
            <typeparam name="TChild">Child object type / Dictionary value type</typeparam>
            <param name="expression">Expression to get property from</param>
            <returns>one-to-many part</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            CreateProperties a one-to-many relationship
            </summary>
            <typeparam name="TChild">Child object type</typeparam>
            <param name="expression">Expression to get property from</param>
            <returns>one-to-many part</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.MapHasManyToMany``2(System.Linq.Expressions.Expression{System.Func{`0,``1}})">
            <summary>
            CreateProperties a many-to-many relationship
            </summary>
            <typeparam name="TChild">Child object type</typeparam>
            <typeparam name="TReturn">Property return type</typeparam>
            <param name="expression">Expression to get property from</param>
            <returns>many-to-many part</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
            <summary>
            CreateProperties a many-to-many relationship
            </summary>
            <typeparam name="TChild">Child object type</typeparam>
            <param name="expression">Expression to get property from</param>
            <returns>many-to-many part</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            CreateProperties a many-to-many relationship
            </summary>
            <typeparam name="TChild">Child object type</typeparam>
            <param name="expression">Expression to get property from</param>
            <returns>many-to-many part</returns>
        </member>
        <member name="T:FluentNHibernate.Mapping.IHasAttributes">
            <summary>
            Dictates whether a element can have attributes set on it.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IHasAttributes.SetAttribute(System.String,System.String)">
            <summary>
            Set an attribute on the xml element produced by this mapping.
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">Attribute value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClassMap.WithTable(System.String)">
            <summary>
            Sets the table for the class.
            </summary>
            <param name="tableName">Table name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClassMap.SchemaIs(System.String)">
            <summary>
            Sets the hibernate-mapping schema for this class.
            </summary>
            <param name="schema">Schema name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClassMap.AutoImport">
            <summary>
            Sets the hibernate-mapping auto-import for this class.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClassMap.LazyLoad">
            <summary>
            Sets this entity to be lazy-loaded (overrides the default lazy load configuration).
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClassMap.ImportType``1">
            <summary>
            Imports an existing type for use in the mapping.
            </summary>
            <typeparam name="TImport">Type to import.</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClassMap.ReadOnly">
            <summary>
            Set the mutability of this class, sets the mutable attribute.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClassMap.DynamicUpdate">
            <summary>
            Sets this entity to be dynamic update
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IClassMap.DynamicInsert">
            <summary>
            Sets this entity to be dynamic insert
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.IClassMap.OptimisticLock">
            <summary>
            Sets the optimistic locking strategy
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.IClassMap.Not">
            <summary>
            Inverse next boolean
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.SetAttribute(System.String,System.String)">
            <summary>
            Set an attribute on the xml element produced by this class mapping.
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">Attribute value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.SchemaIs(System.String)">
            <summary>
            Sets the hibernate-mapping schema for this class.
            </summary>
            <param name="schema">Schema name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.AutoImport">
            <summary>
            Sets the hibernate-mapping auto-import for this class.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.WithTable(System.String)">
            <summary>
            Sets the table for the class.
            </summary>
            <param name="tableName">Table name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.LazyLoad">
            <summary>
            Sets this entity to be lazy-loaded (overrides the default lazy load configuration).
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.WithTable(System.String,System.Action{FluentNHibernate.Mapping.JoinPart{`0}})">
            <summary>
            Sets additional tables for the class via the NH 2.0 Join element.
            </summary>
            <param name="tableName">Joined table name</param>
            <param name="action">Joined table mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.ImportType``1">
            <summary>
            Imports an existing type for use in the mapping.
            </summary>
            <typeparam name="TImport">Type to import.</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.ReadOnly">
            <summary>
            Set the mutability of this class, sets the mutable attribute.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.DynamicUpdate">
            <summary>
            Sets this entity to be dynamic update
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.DynamicInsert">
            <summary>
            Sets this entity to be dynamic insert
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ClassMap`1.Cache">
            <summary>
            Specify caching for this entity.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ClassMap`1.DefaultAccess">
            <summary>
            Set the default access and naming strategies for this entire mapping.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ClassMap`1.Not">
            <summary>
            Inverse next boolean
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ClassMap`1.OptimisticLock">
            <summary>
            Sets the optimistic locking strategy
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.IMappingPart.PositionOnDocument">
            <summary>
            Indicates a constant, general position on the document the part should be written to
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.IMappingPart.LevelWithinPosition">
            <summary>
            Indicates a constant sub-position within a similar grouping of positions the element will be written in
            </summary>
        </member>
        <member name="M:FluentNHibernate.AutoMap.AutoMappingAlterationCollection.Add(System.Type)">
            <summary>
            Creates an instance of an IAutoMappingAlteration from a type instance, then adds it to the alterations collection.
            </summary>
            <param name="type">Type of an IAutoMappingAlteration</param>
        </member>
        <member name="M:FluentNHibernate.AutoMap.AutoMappingAlterationCollection.Add``1">
            <summary>
            Creates an instance of an IAutoMappingAlteration from a generic type parameter, then adds it to the alterations collection.
            </summary>
            <typeparam name="T">Type of an IAutoMappingAlteration</typeparam>
            <returns>Container</returns>
        </member>
        <member name="M:FluentNHibernate.AutoMap.AutoMappingAlterationCollection.Add(FluentNHibernate.AutoMap.Alterations.IAutoMappingAlteration)">
            <summary>
            Adds an alteration
            </summary>
            <param name="alteration">Alteration to add</param>
            <returns>Container</returns>
        </member>
        <member name="M:FluentNHibernate.AutoMap.AutoMappingAlterationCollection.AddFromAssembly(System.Reflection.Assembly)">
            <summary>
            Adds all alterations from an assembly
            </summary>
            <param name="assembly">Assembly to search</param>
            <returns>Container</returns>
        </member>
        <member name="M:FluentNHibernate.AutoMap.AutoMappingAlterationCollection.AddFromAssemblyOf``1">
            <summary>
            Adds all alterations from an assembly that contains T.
            </summary>
            <typeparam name="T">Type who's assembly to search</typeparam>
            <returns>Container</returns>
        </member>
        <member name="M:FluentNHibernate.AutoMap.AutoMappingAlterationCollection.Apply(FluentNHibernate.AutoMap.AutoPersistenceModel)">
            <summary>
            Apply alterations to an AutoPersisteceModel
            </summary>
            <param name="model">AutoPersistenceModel instance to apply alterations to</param>
        </member>
        <member name="M:FluentNHibernate.AutoMap.AutoPersistenceModel.WithAlterations(System.Action{FluentNHibernate.AutoMap.AutoMappingAlterationCollection})">
            <summary>
            Specify alterations to be used with this AutoPersisteceModel
            </summary>
            <param name="alterationDelegate">Lambda to declare alterations</param>
            <returns>AutoPersistenceModel</returns>
        </member>
        <member name="M:FluentNHibernate.AutoMap.AutoPersistenceModel.UseOverridesFromAssemblyOf``1">
            <summary>
            Use auto mapping overrides defined in the assembly of T.
            </summary>
            <typeparam name="T">Type to get assembly from</typeparam>
            <returns>AutoPersistenceModel</returns>
        </member>
        <member name="M:FluentNHibernate.AutoMap.AutoPersistenceModel.WithSetup(System.Action{FluentNHibernate.AutoMappingExpressions})">
            <summary>
            Setup the auto mapper
            </summary>
            <param name="expressionsAction"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.AutoMap.AutoPersistenceModel.#ctor(System.Reflection.Assembly)">
            <summary>
            
            </summary>
            <param name="mapAssembly">Assembly Containing Maps</param>
        </member>
        <member name="P:FluentNHibernate.AutoMap.AutoPersistenceModel.ConventionDiscovery">
            <summary>
            Alter convention discovery
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ISubclass.LazyLoad">
            <summary>
            Sets whether this subclass is lazy loaded
            </summary>
            <returns></returns>
        </member>
        <member name="P:FluentNHibernate.Mapping.ISubclass.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="T:FluentNHibernate.Cfg.AutoMappingsContainer">
            <summary>
            Container for automatic mappings
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.Add(System.Func{FluentNHibernate.AutoMap.AutoPersistenceModel})">
            <summary>
            Add automatic mappings
            </summary>
            <param name="model">Lambda returning an auto mapping setup</param>
            <returns>Auto mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.Add(FluentNHibernate.AutoMap.AutoPersistenceModel)">
            <summary>
            Add automatic mappings
            </summary>
            <param name="model">Auto mapping setup</param>
            <returns>Auto mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.ExportTo(System.String)">
            <summary>
            Sets the export location for generated mappings
            </summary>
            <param name="path">Path to folder for mappings</param>
            <returns>Auto mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.Apply(NHibernate.Cfg.Configuration)">
            <summary>
            Applies any added mappings to the NHibernate Configuration
            </summary>
            <param name="cfg">NHibernate Configuration instance</param>
        </member>
        <member name="P:FluentNHibernate.Cfg.AutoMappingsContainer.WasUsed">
            <summary>
            Gets whether any mappings were added
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.ProxyFactoryFactory(System.String)">
            <summary>
            Sets the proxyfactory.factory_class property.
            NOTE: NHibernate 2.1 only
            </summary>
            <param name="proxyFactoryFactoryClass">factory class</param>
            <returns>Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.AdoNetBatchSize(System.Int32)">
            <summary>
            Sets the adonet.batch_size property.
            </summary>
            <param name="size">Batch size</param>
            <returns>Configuration</returns>
        </member>
        <member name="P:FluentNHibernate.Cfg.Db.OracleClientConfiguration.Oracle9">
            <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleClientConfiguration"/> class using the
            MS Oracle Client (System.Data.OracleClient) library.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.Db.OracleConfiguration.Oracle9">
            <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleConfiguration"/> class using the
            Oracle Data Provider (Oracle.DataAccess) library.  The Oracle.DataAccess library must
            be available to the calling application/library.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Server(System.String)">
            <summary>
            Specifies the server to connect. This can be either the DNS name of the
            server or the IP (as a string).
            </summary>
            <param name="server">The server.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Instance(System.String)">
            <summary>
            Specifies the instance (database name) to use.  This can be the short name or the
            fully qualified name (Oracle service name).
            </summary>
            <param name="instance">The instance.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Username(System.String)">
            <summary>
            Specifies the name of the user account accessing the database.
            </summary>
            <param name="username">The username.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Password(System.String)">
            <summary>
            Specifies the password of the user account accessing the database.
            </summary>
            <param name="password">The password.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Port(System.Int32)">
            <summary>
            Optional. Ports the specified port the oracle database is running on.  This defaults to 1521.
            </summary>
            <param name="port">The port.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Pooling(System.Boolean)">
            <summary>
            Enable or disable pooling connections for this data configuration.
            </summary>
            <param name="pooling">if set to <c>true</c> enable pooling.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.StatementCacheSize(System.Int32)">
            <summary>
            Specifies the SQL statement cache size to use for this connection.
            </summary>
            <param name="cacheSize">Size of the cache.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.OtherOptions(System.String)">
            <summary>
            Specifies, as a string, other Oracle options to pass to the connection.
            </summary>
            <param name="otherOptions">The other options.</param>
            <returns></returns>
        </member>
        <member name="P:FluentNHibernate.Cfg.Db.OracleDataClientConfiguration.Oracle9">
            <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleDataClientConfiguration"/> class using the
            Oracle Data Provider (Oracle.DataAccess) library.  The Oracle.DataAccess library must
            be available to the calling application/library.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Cfg.FluentConfiguration">
            <summary>
            Fluent configuration API for NHibernate
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.Database(System.Func{FluentNHibernate.Cfg.Db.IPersistenceConfigurer})">
            <summary>
            Apply database settings
            </summary>
            <param name="config">Lambda returning database configuration</param>
            <returns>Fluent configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.Database(FluentNHibernate.Cfg.Db.IPersistenceConfigurer)">
            <summary>
            Apply database settings
            </summary>
            <param name="config">Database configuration instance</param>
            <returns>Fluent configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.Mappings(System.Action{FluentNHibernate.Cfg.MappingConfiguration})">
            <summary>
            Apply mappings to NHibernate
            </summary>
            <param name="mappings">Lambda used to apply mappings</param>
            <returns>Fluent configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.ExposeConfiguration(System.Action{NHibernate.Cfg.Configuration})">
            <summary>
            Allows altering of the raw NHibernate Configuration object before creation
            </summary>
            <param name="config">Lambda used to alter Configuration</param>
            <returns>Fluent configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.BuildSessionFactory">
            <summary>
            Verify's the configuration and instructs NHibernate to build a SessionFactory.
            </summary>
            <returns>ISessionFactory from supplied settings.</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.BuildConfiguration">
            <summary>
            Verifies the configuration and populates the NHibernate Configuration instance.
            </summary>
            <returns>NHibernate Configuration instance</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.CreateConfigurationException(System.Exception)">
            <summary>
            Creates an exception based on the current state of the configuration.
            </summary>
            <param name="innerException">Inner exception</param>
            <returns>FluentConfigurationException with state</returns>
        </member>
        <member name="T:FluentNHibernate.Cfg.Fluently">
            <summary>
            Fluently configure NHibernate
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.Fluently.Configure">
            <summary>
            Begin fluently configuring NHibernate
            </summary>
            <returns>Fluent Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Fluently.Configure(NHibernate.Cfg.Configuration)">
            <summary>
            Begin fluently configuring NHibernate
            </summary>
            <param name="cfg">Instance of an NHibernate Configuration</param>
            <returns>Fluent Configuration</returns>
        </member>
        <member name="T:FluentNHibernate.Cfg.FluentMappingsContainer">
            <summary>
            Container for fluent mappings
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.AddFromAssemblyOf``1">
            <summary>
            Add all fluent mappings in the assembly that contains T.
            </summary>
            <typeparam name="T">Type from the assembly</typeparam>
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.AddFromAssembly(System.Reflection.Assembly)">
            <summary>
            Add all fluent mappings in the assembly
            </summary>
            <param name="assembly">Assembly to add mappings from</param>
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.Add``1">
            <summary>
            Adds a single <see cref="T:FluentNHibernate.Mapping.IClassMap"/> represented by the specified type.
            </summary>
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.Add(System.Type)">
            <summary>
            Adds a single <see cref="T:FluentNHibernate.Mapping.IClassMap"/> represented by the specified type.
            </summary>
            <param name="type">The type.</param>
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.ExportTo(System.String)">
            <summary>
            Sets the export location for generated mappings
            </summary>
            <param name="path">Path to folder for mappings</param>
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.Apply(NHibernate.Cfg.Configuration)">
            <summary>
            Applies any added mappings to the NHibernate Configuration
            </summary>
            <param name="cfg">NHibernate Configuration instance</param>
        </member>
        <member name="P:FluentNHibernate.Cfg.FluentMappingsContainer.ConventionDiscovery">
            <summary>
            Alter convention discovery
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.FluentMappingsContainer.WasUsed">
            <summary>
            Gets whether any mappings were added
            </summary>
        </member>
        <member name="T:FluentNHibernate.Cfg.HbmMappingsContainer">
            <summary>
            Container for Hbm mappings
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.AddClasses(System.Type[])">
            <summary>
            Add explicit classes with Hbm mappings
            </summary>
            <param name="types">List of types to map</param>
            <returns>Hbm mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.AddFromAssemblyOf``1">
            <summary>
            Add all Hbm mappings in the assembly that contains T.
            </summary>
            <typeparam name="T">Type from the assembly</typeparam>
            <returns>Hbm mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.AddFromAssembly(System.Reflection.Assembly)">
            <summary>
            Add all Hbm mappings in the assembly
            </summary>
            <param name="assembly">Assembly to add mappings from</param>
            <returns>Hbm mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.Apply(NHibernate.Cfg.Configuration)">
            <summary>
            Applies any added mappings to the NHibernate Configuration
            </summary>
            <param name="cfg">NHibernate Configuration instance</param>
        </member>
        <member name="P:FluentNHibernate.Cfg.HbmMappingsContainer.WasUsed">
            <summary>
            Gets whether any mappings were added
            </summary>
        </member>
        <member name="T:FluentNHibernate.Cfg.MappingConfiguration">
            <summary>
            Fluent mapping configuration
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.MappingConfiguration.Apply(NHibernate.Cfg.Configuration)">
            <summary>
            Applies any mappings to the NHibernate Configuration
            </summary>
            <param name="cfg">NHibernate Configuration instance</param>
        </member>
        <member name="P:FluentNHibernate.Cfg.MappingConfiguration.FluentMappings">
            <summary>
            Fluent mappings
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.MappingConfiguration.AutoMappings">
            <summary>
            Automatic mapping configurations
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.MappingConfiguration.HbmMappings">
            <summary>
            Hbm mappings
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.MappingConfiguration.WasUsed">
            <summary>
            Get whether any mappings of any kind were added
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IConventionFinder">
            <summary>
            Convention finder - used to search through assemblies for types that implement a specific convention interface.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Add an assembly to be queried.
            </summary>
            <remarks>
            All convention types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder"/>.
            </remarks>
            <param name="assembly">Assembly instance to query</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.AddFromAssemblyOf``1">
            <summary>
            Adds all conventions found in the assembly that contains <typeparam name="T"/>.
            </summary>
            <remarks>
            All convention types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder"/>.
            </remarks>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.Add``1">
            <summary>
            Add a single convention by type.
            </summary>
            <remarks>
            Type must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder"/>.
            </remarks>
            <typeparam name="T">Convention type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.Add(System.Type)">
            <summary>
            Add a single convention by type.
            </summary>
            <remarks>
            Types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder"/>.
            </remarks>
            <param name="type">Type of convention</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.Add``1(``0)">
            <summary>
            Add an instance of a convention.
            </summary>
            <remarks>
            Useful for supplying conventions that require extra constructor parameters.
            </remarks>
            <typeparam name="T">Convention type</typeparam>
            <param name="instance">Instance of convention</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.Find``1">
            <summary>
            Find any conventions implementing T.
            </summary>
            <typeparam name="T">Convention interface type</typeparam>
            <returns>IEnumerable of T</returns>
        </member>
        <member name="T:FluentNHibernate.Conventions.IReferenceConvention">
            <summary>
            Reference convention, implement this interface to apply changes to Reference/many-to-one
            relationships.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IConvention`1">
            <summary>
            Basic convention interface. Don't use directly.
            </summary>
            <typeparam name="T">Mapping to apply conventions to</typeparam>
        </member>
        <member name="T:FluentNHibernate.Conventions.IConvention">
            <summary>
            Ignore - this is used for generic restrictions only
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConvention`1.Accept(`0)">
            <summary>
            Whether this convention will be applied to the target.
            </summary>
            <param name="target">Instace that could be supplied</param>
            <returns>Apply on this target?</returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConvention`1.Apply(`0)">
            <summary>
            Apply changes to the target
            </summary>
            <param name="target">Instance to apply changes to</param>
        </member>
        <member name="T:FluentNHibernate.Conventions.IHasManyConvention">
            <summary>
            HasMany convention, used for applying changes to one-to-many relationships.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IHasManyToManyConvention">
            <summary>
            HasManyToMany convention, used on many-to-many relationships.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.BaseMappingPartDiscoveryConvention`1">
            <summary>
            Base implementation for "classlike" mappings. Finds and applies any <see cref="T:FluentNHibernate.Conventions.IMappingPartConvention"/>
            implementations to all <see cref="T:FluentNHibernate.Mapping.IMappingPart"/>s in the classlike container.
            </summary>
            <remarks>
            Classlike mappings are ones that are like classes in their capabilities, components
            and join's are two examples.
            </remarks>
            <typeparam name="TPart">Classlike mapping</typeparam>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.ClassDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IClassConvention"/> implementations and applies them to all the
            <see cref="T:FluentNHibernate.Mapping.IClassMap"/>s in the domain.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IEntireMappingsConvention">
            <summary>
            Convention for all the class mappings in the assemblies Fluent NHibernate knows about.
            Implement this interface to alter collections of class mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.ClassMappingPartDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IMappingPartConvention"/> implementations and applies them to
            all <see cref="T:FluentNHibernate.Mapping.IMappingPart"/>s in an <see cref="T:FluentNHibernate.Mapping.IClassMap"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IClassConvention">
            <summary>
            Convention for a single class mapping. Implement this interface to apply
            changes to class mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.ComponentDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IComponentConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IComponent"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IMappingPartConvention">
            <summary>
            Mapping part convention, implement this interface to apply changes to
            all IMappingPart instances.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.ComponentMappingPartDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IMappingPartConvention"/> implementations and applies them to
            all <see cref="T:FluentNHibernate.Mapping.IMappingPart"/>s in an <see cref="T:FluentNHibernate.Mapping.IComponent"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IComponentConvention">
            <summary>
            Convention for a component mapping. Implement this interface to
            apply changes to components.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.DefaultConventionFinder">
            <summary>
            Default convention finder - doesn't do anything special.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Find``1">
            <summary>
            Find any conventions implementing T.
            </summary>
            <typeparam name="T">Convention interface type</typeparam>
            <returns>IEnumerable of T</returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Add an assembly to be queried.
            </summary>
            <remarks>
            All convention types must have a parameterless constructor, or a single parameter of IConventionFinder.
            </remarks>
            <param name="assembly">Assembly instance to query</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.AddFromAssemblyOf``1">
            <summary>
            Adds all conventions found in the assembly that contains T.
            </summary>
            <remarks>
            All convention types must have a parameterless constructor, or a single parameter of IConventionFinder.
            </remarks>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Add``1">
            <summary>
            Add a single convention by type.
            </summary>
            <remarks>
            Type must have a parameterless constructor, or a single parameter of IConventionFinder.
            </remarks>
            <typeparam name="T">Convention type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Add(System.Type)">
            <summary>
            Add a single convention by type.
            </summary>
            <remarks>
            Types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder"/>.
            </remarks>
            <param name="type">Type of convention</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Add``1(``0)">
            <summary>
            Add an instance of a convention.
            </summary>
            <remarks>
            Useful for supplying conventions that require extra constructor parameters.
            </remarks>
            <typeparam name="T">Convention type</typeparam>
            <param name="instance">Instance of convention</param>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.DynamicComponentDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IDynamicComponentConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IDynamicComponent"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.DynamicComponentMappingPartDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IMappingPartConvention"/> implementations and applies them to
            all <see cref="T:FluentNHibernate.Mapping.IMappingPart"/>s in an <see cref="T:FluentNHibernate.Mapping.IDynamicComponent"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IDynamicComponentConvention">
            <summary>
            Convention for dynamic components. Implement this member to apply changes
            to dynamic components.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.HasManyDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IHasManyConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IOneToManyPart"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IRelationshipConvention">
            <summary>
            Relationship convention, implement this interface to apply changes to
            all relationship mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.HasManyToManyDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IHasManyToManyConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IManyToManyPart"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.HasOneDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IHasOneConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IOneToOnePart"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.IdDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IIdConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IIdentityPart"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.JoinDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IJoinConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IJoin"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.JoinedSubclassDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IJoinedSubclassConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IJoinedSubclass"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.JoinedSubclassMappingPartDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IMappingPartConvention"/> implementations and applies them to
            all <see cref="T:FluentNHibernate.Mapping.IMappingPart"/>s in an <see cref="T:FluentNHibernate.Mapping.IJoinedSubclass"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IJoinedSubclassConvention">
            <summary>
            Joined subclass convention, implement this interface to alter joined-subclass mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.JoinMappingPartDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IMappingPartConvention"/> implementations and applies them to
            all <see cref="T:FluentNHibernate.Mapping.IMappingPart"/>s in an <see cref="T:FluentNHibernate.Mapping.IJoin"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IJoinConvention">
            <summary>
            Join convention, implement this interface to alter join mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.PropertyDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IPropertyConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IProperty"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.ReferenceDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IReferenceConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IManyToOnePart"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.RelationshipDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IRelationshipConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IRelationship"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.SubclassDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.ISubclassConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.ISubclass"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.SubclassMappingPartDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IMappingPartConvention"/> implementations and applies them to
            all <see cref="T:FluentNHibernate.Mapping.IMappingPart"/>s in an <see cref="T:FluentNHibernate.Mapping.ISubclass"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.ISubclassConvention">
            <summary>
            Subclass convention, implement this interface to alter subclass mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Discovery.VersionDiscoveryConvention">
            <summary>
            Discovers any <see cref="T:FluentNHibernate.Conventions.IVersionConvention"/> implementations and applies them to
            an <see cref="T:FluentNHibernate.Mapping.IVersion"/> instance.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IHasOneConvention">
            <summary>
            HasOne convention, used for applying changes to one-to-one relationships.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IIdConvention">
            <summary>
            Convention for identities, implement this interface to apply changes to
            identity mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IPropertyConvention">
            <summary>
            Property convention, implement this interface to apply changes to
            property mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IVersionConvention">
            <summary>
            Version convention, implement this interface to apply changes to vesion mappings.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Data.Entity.Equals(FluentNHibernate.Data.Entity)">
            <summary>
            Indicates whether the current <see cref="T:FluentNHibernate.Data.Entity" /> is equal to another <see cref="T:FluentNHibernate.Data.Entity" />.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
            <param name="obj">An Entity to compare with this object.</param>
        </member>
        <member name="M:FluentNHibernate.Data.Entity.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:FluentNHibernate.Data.Entity" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
            <returns>
            true if the specified <see cref="T:FluentNHibernate.Data.Entity" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. </param>
            <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:FluentNHibernate.Data.Entity.GetHashCode">
            <summary>
            Serves as a hash function for a Entity. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentNHibernate.Mapping.IAccessStrategy`1">
            <summary>
            Denotes that a mapping part has an access strategy.
            </summary>
            <typeparam name="T">Parent element, property, many-to-one etc...</typeparam>
        </member>
        <member name="P:FluentNHibernate.Mapping.IAccessStrategy`1.Access">
            <summary>
            Set the access and naming strategy for this element.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAnyPart`1.IdentityType(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            (REQUIRED) The identity type of the any mapping
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAnyPart`1.EntityTypeColumn(System.String)">
            <summary>
            (REQUIRED) Specifies the column name that will contain the type of the associated entity
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAnyPart`1.EntityIdentifierColumn(System.String)">
            <summary>
            (REQUIRED) Specifies the column name that will hold the identifier
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAnyPart`1.AddMetaValue``1(System.String)">
            <summary>
            This is used to map specific class types to value types stored in the EntityTypeColumn
            This method should only be called if the MetaType specified for this ANY mapping is a basic data type (such as string)
            </summary>
            <typeparam name="TModel">The class type to map</typeparam>
            <param name="valueMap">The string or character representing the value stored in the EntityTypeColumn in the table</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.IAnyPart`1.Cascade">
            <summary>
            Sets the cascade of this part. Valid options are "none", "all", and "save-update"
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.AnyPart`1">
            <summary>
            Represents the "Any" mapping in NHibernate. It is impossible to specify a foreign key constraint for this kind of association. For more information
            please reference chapter 5.2.4 in the NHibernate online documentation
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AnyPart`1.SetAttribute(System.String,System.String)">
            <summary>
            Used to specify attributes on the XML Element if the class does not contain the necessary Fluent mapping
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AnyPart`1.SetAttributes(FluentNHibernate.Mapping.Attributes)">
            <summary>
            Used to specify attributes on the XML Element if the class does not contain the necessary Fluent mapping
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AnyPart`1.Write(System.Xml.XmlElement,FluentNHibernate.IMappingVisitor)">
            <summary>
            Writes the Any element to the XmlElement. Typically called during a ClassMap write
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.AnyPart`1.AnyProperty">
            <summary>
            The property on your class that contains the mapped object
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.AnyPart`1.LevelWithinPosition">
            <summary>
            Indicates the level within the Position, that this Part should be written at. The Any part has no intrinsic level it's required to appear at.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.AnyPart`1.PositionOnDocument">
            <summary>
            The general ordering of which the Part should be written in the HBM mapping. The Any Part can be placed anywhere in a mapping file after the header components have been set.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.AnyPart`1.Access">
            <summary>
            Defines how NHibernate will access the object for persisting/hydrating (Defaults to Property)
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.AnyPart`1.Cascade">
            <summary>
            Cascade style (Defaults to none)
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ComponentPartBase`1.SetAttribute(System.String,System.String)">
            <summary>
            Set an attribute on the xml element produced by this component mapping.
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">Attribute value</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.ComponentPartBase`1.Access">
            <summary>
            Set the access and naming strategy for this component.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.AlwaysSelectWithValue">
            <summary>
            Force NHibernate to always select using the discriminator value, even when selecting all subclasses. This
            can be useful when your table contains more discriminator values than you have classes (legacy).
            </summary>
            <remarks>Sets the "force" attribute.</remarks>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.ReadOnly">
            <summary>
            Set this discriminator as read-only. Call this if your discriminator column is also part of a mapped composite identifier.
            </summary>
            <returns>Sets the "insert" attribute.</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.Formula(System.String)">
            <summary>
            An arbitrary SQL expression that is executed when a type has to be evaluated. Allows content-based discrimination.
            </summary>
            <param name="sql">SQL expression</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.SetAttribute(System.String,System.String)">
            <summary>
            Set an attribute on the xml element produced by this discriminator mapping.
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">Attribute value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsProperty">
            <summary>
            Sets the access-strategy to property.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsField">
            <summary>
            Sets the access-strategy to field.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsCamelCaseField">
            <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase (field.camelcase).
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsCamelCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsLowerCaseField">
            <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsLowerCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsPascalCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsReadOnlyPropertyThroughCamelCaseField">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsReadOnlyPropertyThroughCamelCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsReadOnlyPropertyThroughLowerCaseField">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsReadOnlyPropertyThroughLowerCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.AsReadOnlyPropertyThroughPascalCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.Using(System.String)">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <param name="propertyAccessorAssemblyQualifiedClassName">Assembly qualified name of the type to use as the access-strategy</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.Using(System.Type)">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <param name="propertyAccessorClassType">Type to use as the access-strategy</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IAccessStrategyBuilder.Using``1">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <typeparam name="TPropertyAccessorClass">Type to use as the access-strategy</typeparam>
        </member>
        <member name="T:FluentNHibernate.Conventions.UserTypeConvention`1">
            <summary>
            Base class for user type conventions. Create a subclass of this to automatically
            map all properties that the user type can be used against. Override Accept or
            Apply to alter the behavior.
            </summary>
            <typeparam name="TUserType">IUserType implementation</typeparam>
        </member>
        <member name="T:FluentNHibernate.Conventions.IUserTypeConvention">
            <summary>
            User type convention, implement this interface to apply changes to
            property's that use a IUserType. Subclassing <see cref="T:FluentNHibernate.Conventions.UserTypeConvention`1"/>
            is recommended instead of directly implementing this interface.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.IUserTypeConvention.Accept(System.Type)">
            <summary>
            Should apply changes to property's of this type?
            </summary>
            <param name="type">Property type</param>
            <returns>Accept or not</returns>
        </member>
        <member name="T:FluentNHibernate.Conventions.AttributePropertyConvention`1">
            <summary>
            Base class for attribute based conventions. Create a subclass of this to supply your own
            attribute based conventions.
            </summary>
            <typeparam name="T">Attribute identifier</typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.AttributePropertyConvention`1.Apply(`0,FluentNHibernate.Mapping.IProperty)">
            <summary>
            Apply changes to a property with an attribute matching T.
            </summary>
            <param name="attribute">Instance of attribute found on property.</param>
            <param name="target">Property with attribute</param>
        </member>
        <member name="T:FluentNHibernate.Conventions.Defaults.BaseMethodAccessorBackingFieldNamingConvention`1">
            <summary>
            Base convention for setting the backing field name of a property or method.
            </summary>
            <typeparam name="TPart">Collection relationship mapping</typeparam>
        </member>
        <member name="T:FluentNHibernate.Conventions.Defaults.HasManyMethodAccessorBackingFieldNamingConvention">
            <summary>
            Default HasMany backing field naming convention
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Defaults.HasManyToManyJoinTableNameConvention">
            <summary>
            Default HasManyToMany table name convention
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Defaults.HasManyToManyMethodAccessorBackingFieldNamingConvention">
            <summary>
            Default HasManyToMany backing field naming convention
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Defaults.PrimaryKeyConvention">
            <summary>
            Default primary key name convention.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Defaults.VersionColumnNameConvention">
            <summary>
            Version column naming convention
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.AccessStrategyBuilder`1">
            <summary>
            Access strategy mapping builder.
            </summary>
            <typeparam name="T">Mapping part to be applied to</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.#ctor(`0)">
            <summary>
            Access strategy mapping builder.
            </summary>
            <param name="parent">Instance of the parent mapping part.</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsProperty">
            <summary>
            Sets the access-strategy to property.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsField">
            <summary>
            Sets the access-strategy to field.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsCamelCaseField">
            <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase (field.camelcase).
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsCamelCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsLowerCaseField">
            <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsLowerCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsPascalCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsReadOnlyPropertyThroughCamelCaseField">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsReadOnlyPropertyThroughCamelCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsReadOnlyPropertyThroughLowerCaseField">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsReadOnlyPropertyThroughLowerCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.AsReadOnlyPropertyThroughPascalCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Using(System.String)">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <param name="propertyAccessorAssemblyQualifiedClassName">Assembly qualified name of the type to use as the access-strategy</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Using(System.Type)">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <param name="propertyAccessorClassType">Type to use as the access-strategy</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Using``1">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <typeparam name="TPropertyAccessorClass">Type to use as the access-strategy</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.SetAccessAttribute(System.String)">
            <summary>
            Sets the access attribute on the parent element.
            </summary>
            <param name="value">Value for the access attribute</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ICollectionRelationship.Component(System.Action{FluentNHibernate.Mapping.IClasslike})">
            <summary>
            Maps this collection as a collection of components.
            </summary>
            <param name="action">Component mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ICollectionRelationship.WithTableName(System.String)">
            <summary>
            Sets the table name for this one-to-many.
            </summary>
            <param name="name">Table name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ICollectionRelationship.Where(System.String)">
            <summary>
            Sets the where clause for this one-to-many relationship.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ICollectionRelationship.CollectionType``1">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ICollectionRelationship.CollectionType(System.Type)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ICollectionRelationship.CollectionType(System.String)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ICollectionRelationship.Cache">
            <summary>
            Specify caching for this entity.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ICollectionRelationship.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.INotFoundExpression.Ignore">
            <summary>
            Used to set the Not-Found attribute to ignore.  This tells NHibernate to 
            return a null object rather then throw an exception when the join fails
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.INotFoundExpression.Exception">
            <summary>
            Used to set the Not-Found attribute to exception (Nhibernate default).  This 
            tells NHibernate to throw an exception when the join fails
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.InvalidPrefixException">
            <summary>
            Thrown when a prefix is specified for an access-strategy that isn't supported.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.Prefix">
            <summary>
            Naming strategy prefix.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Defaults.TableNameConvention">
            <summary>
            Default entity table name convention
            </summary>
        </member>
        <member name="M:FluentNHibernate.Testing.PersistenceSpecification`1.CheckComponentList``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IList{``0})">
            <summary>
            Checks a list of components for validity.
            </summary>
            <typeparam name="TList">Type of list element</typeparam>
            <param name="expression">Property</param>
            <param name="propertyValue">Value to save</param>
        </member>
        <member name="T:FluentNHibernate.Utils.ExpressionToSql">
            <summary>
            Converts an expression to a best guess SQL string
            </summary>
        </member>
        <member name="M:FluentNHibernate.Utils.ExpressionToSql.Convert``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Converts a Func expression to a best guess SQL string
            </summary>
        </member>
        <member name="M:FluentNHibernate.Utils.ExpressionToSql.Convert``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Converts a boolean Func expression to a best guess SQL string
            </summary>
        </member>
        <member name="M:FluentNHibernate.Utils.ExpressionToSql.Convert(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Gets the value of a method call.
            </summary>
            <param name="body">Method call expression</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IIdentityPart.SetGeneratorClass(System.String)">
            <summary>
            Set the access and naming strategy for this identity.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IIdentityPart.WithUnsavedValue(System.Object)">
            <summary>
            Sets the unsaved-value of the identity.
            </summary>
            <param name="unsavedValue">Value that represents an unsaved value.</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IIdentityPart.ColumnName(System.String)">
            <summary>
            Sets the column name for the identity field.
            </summary>
            <param name="columnName">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IOneToManyPart.CollectionType``1">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IOneToManyPart.CollectionType(System.Type)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IOneToManyPart.CollectionType(System.String)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.IOneToManyPart.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.JoinPart`1">
            <summary>
            Maps to the Join element in NH 2.0
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.NotFoundExpression`1.Ignore">
            <summary>
            Used to set the Not-Found attribute to ignore.  This tells NHibernate to 
            return a null object rather then throw an exception when the join fails
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.NotFoundExpression`1.FluentNHibernate#Mapping#INotFoundExpression#Ignore">
            <summary>
            Used to set the Not-Found attribute to ignore.  This tells NHibernate to 
            return a null object rather then throw an exception when the join fails
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.NotFoundExpression`1.Exception">
            <summary>
            Used to set the Not-Found attribute to exception (Nhibernate default).  This 
            tells NHibernate to throw an exception when the join fails
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.NotFoundExpression`1.FluentNHibernate#Mapping#INotFoundExpression#Exception">
            <summary>
            Used to set the Not-Found attribute to exception (Nhibernate default).  This 
            tells NHibernate to throw an exception when the join fails
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder.None">
            <summary>
            Use no locking strategy
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder.Version">
            <summary>
            Use version locking
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder.Dirty">
            <summary>
            Use dirty locking
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder.All">
            <summary>
            Use all locking
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.PartPosition">
            <summary>
            Specifies the position within the parent that this element is output
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Component(System.Action{FluentNHibernate.Mapping.CompositeElementPart{`1}})">
            <summary>
            Maps this collection as a collection of components.
            </summary>
            <param name="action">Component mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.WithTableName(System.String)">
            <summary>
            Sets the table name for this one-to-many.
            </summary>
            <param name="name">Table name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Where(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Sets the where clause for this one-to-many relationship.
            Note: This only supports simple cases, use the string overload for more complex clauses.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Where(System.String)">
            <summary>
            Sets the where clause for this one-to-many relationship.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.CollectionType``1">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.CollectionType(System.Type)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.CollectionType(System.String)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.FluentNHibernate#Mapping#ICollectionRelationship#Component(System.Action{FluentNHibernate.Mapping.IClasslike})">
            <summary>
            Maps this collection as a collection of components.
            </summary>
            <param name="action">Component mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.FluentNHibernate#Mapping#ICollectionRelationship#WithTableName(System.String)">
            <summary>
            Sets the table name for this one-to-many.
            </summary>
            <param name="name">Table name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.FluentNHibernate#Mapping#ICollectionRelationship#Where(System.String)">
            <summary>
            Sets the where clause for this one-to-many relationship.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.FluentNHibernate#Mapping#ICollectionRelationship#CollectionType``1">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.FluentNHibernate#Mapping#ICollectionRelationship#CollectionType(System.Type)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.FluentNHibernate#Mapping#ICollectionRelationship#CollectionType(System.String)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ToManyBase`2.Cache">
            <summary>
            Specify caching for this entity.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ToManyBase`2.Access">
            <summary>
            Set the access and naming strategy for this one-to-many.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ToManyBase`2.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ToManyBase`2.FluentNHibernate#Mapping#ICollectionRelationship#Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Defaults.NullableEnumerationPropertyConvention">
            <summary>
            Nullable enum convention. Same behavior as <see cref="T:FluentNHibernate.Conventions.Defaults.EnumerationPropertyConvention"/> but sets the
            property to nullable aswell.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.CompositeElementPart`1">
            <summary>
            Component-element for component HasMany's.
            </summary>
            <typeparam name="T">Component type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeElementPart`1.WithParentReference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Maps a property of the component class as a reference back to the containing entity
            </summary>
            <param name="exp">Parent reference property</param>
            <returns>Component being mapped</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeElementPart`1.SetAttribute(System.String,System.String)">
            <summary>
            Set an attribute on the xml element produced by this component mapping.
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">Attribute value</param>
            <!-- Include tag is invalid --><include file="" path="[@name=&quot;&quot;]"/>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.WithKeyProperty(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Defines a property to be used as a key for this composite-id.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <returns>The composite identity part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.WithKeyProperty(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
            <summary>
            Defines a property to be used as a key for this composite-id with an explicit column name.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <param name="columnName">The column name in the database to use for this key, or null to use the property name</param>
            <returns>The composite identity part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.WithKeyReference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Defines a reference to be used as a many-to-one key for this composite-id with an explicit column name.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <returns>The composite identity part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.WithKeyReference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
            <summary>
            Defines a reference to be used as a many-to-one key for this composite-id with an explicit column name.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <param name="columnName">The column name in the database to use for this key, or null to use the property name</param>
            <returns>The composite identity part fluent interface</returns>
        </member>
        <member name="P:FluentNHibernate.Mapping.CompositeIdentityPart`1.Access">
            <summary>
            Set the access and naming strategy for this identity.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Defaults.PropertyTypeConvention">
            <summary>
            Sets the type attribute on property mappings
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.Defaults.EnumerationPropertyConvention">
            <summary>
            Specifies a custom type (of <see cref="T:FluentNHibernate.Mapping.GenericEnumMapper`1"/>) for any properties
            that are an enum.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.Increment">
            <summary>
            generates identifiers of any integral type that are unique only when no other 
            process is inserting data into the same table. Do not use in a cluster.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.Identity">
            <summary>
            supports identity columns in DB2, MySQL, MS SQL Server and Sybase.
            The identifier returned by the database is converted to the property type using 
            Convert.ChangeType. Any integral property type is thus supported.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.Sequence(System.String)">
            <summary>
            uses a sequence in DB2, PostgreSQL, Oracle or a generator in Firebird.
            The identifier returned by the database is converted to the property type 
            using Convert.ChangeType. Any integral property type is thus supported.
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.HiLo(System.String,System.String,System.String)">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="table"></param>
            <param name="column"></param>
            <param name="maxLo"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.HiLo(System.String)">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="maxLo"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.SeqHiLo(System.String,System.String)">
            <summary>
            uses an Oracle-style sequence (where supported)
            </summary>
            <param name="sequence"></param>
            <param name="maxLo"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.UuidHex(System.String)">
            <summary>
            uses System.Guid and its ToString(string format) method to generate identifiers
            of type string. The length of the string returned depends on the configured format. 
            </summary>
            <param name="format">http://msdn.microsoft.com/en-us/library/97af8hh4.aspx</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.UuidString">
            <summary>
            uses a new System.Guid to create a byte[] that is converted to a string.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.Guid">
            <summary>
            uses a new System.Guid as the identifier. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.GuidComb">
            <summary>
            Recommended for Guid identifiers!
            uses the algorithm to generate a new System.Guid described by Jimmy Nilsson 
            in the article http://www.informit.com/articles/article.asp?p=25862. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.Assigned">
            <summary>
            lets the application to assign an identifier to the object before Save() is called. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.Native">
            <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder.Foreign(System.String)">
            <summary>
            uses the identifier of another associated object. Usually used in conjunction with a one-to-one primary key association. 
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.SetAttribute(System.String,System.String)">
            <summary>
            Set an attribute on the xml element produced by this identity mapping.
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">Attribute value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.WithUnsavedValue(System.Object)">
            <summary>
            Sets the unsaved-value of the identity.
            </summary>
            <param name="unsavedValue">Value that represents an unsaved value.</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.ColumnName(System.String)">
            <summary>
            Sets the column name for the identity field.
            </summary>
            <param name="columnName">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.GetColumnName">
            <summary>
            Gets the column name
            </summary>
            <returns></returns>
        </member>
        <member name="P:FluentNHibernate.Mapping.IdentityPart.Access">
            <summary>
            Set the access and naming strategy for this identity.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IProperty.UniqueKey(System.String)">
            <summary>
            Specifies the name of a multi-column unique constraint.
            </summary>
            <param name="keyName">Name of constraint</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.IProperty.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.JoinedSubClassPart`1.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.SetAttribute(System.String,System.String)">
            <summary>
            Set an attribute on the xml element produced by this many-to-many mapping.
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">Attribute value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.UniqueKey(System.String)">
            <summary>
            Specifies the name of a multi-column unique constraint.
            </summary>
            <param name="keyName">Name of constraint</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.ManyToOnePart`1.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.SetAttribute(System.String,System.String)">
            <summary>
            Set an attribute on the xml element produced by this one-to-many mapping.
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">Attribute value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.FluentNHibernate#Mapping#IOneToManyPart#CollectionType``1">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.FluentNHibernate#Mapping#IOneToManyPart#CollectionType(System.Type)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.FluentNHibernate#Mapping#IOneToManyPart#CollectionType(System.String)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyMap.SetAttribute(System.String,System.String)">
            <summary>
            Set an attribute on the xml element produced by this property mapping.
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">Attribute value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyMap.CustomTypeIs``1">
            <summary>
            Specifies that a custom type (an implementation of <see cref="T:NHibernate.UserTypes.IUserType"/>) should be used for this property for mapping it to/from one or more database columns whose format or type doesn't match this .NET property.
            </summary>
            <typeparam name="TCustomtype">A type which implements <see cref="T:NHibernate.UserTypes.IUserType"/>.</typeparam>
            <returns>This property mapping to continue the method chain</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyMap.CustomTypeIs(System.Type)">
            <summary>
            Specifies that a custom type (an implementation of <see cref="T:NHibernate.UserTypes.IUserType"/>) should be used for this property for mapping it to/from one or more database columns whose format or type doesn't match this .NET property.
            </summary>
            <param name="type">A type which implements <see cref="T:NHibernate.UserTypes.IUserType"/>.</param>
            <returns>This property mapping to continue the method chain</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyMap.CustomTypeIs(System.String)">
            <summary>
            Specifies that a custom type (an implementation of <see cref="T:NHibernate.UserTypes.IUserType"/>) should be used for this property for mapping it to/from one or more database columns whose format or type doesn't match this .NET property.
            </summary>
            <param name="type">A type which implements <see cref="T:NHibernate.UserTypes.IUserType"/>.</param>
            <returns>This property mapping to continue the method chain</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyMap.UniqueKey(System.String)">
            <summary>
            Specifies the name of a multi-column unique constraint.
            </summary>
            <param name="keyName">Name of constraint</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.PropertyMap.Access">
            <summary>
            Set the access and naming strategy for this property.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.PropertyMap.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubClassPart`1.SetAttribute(System.String,System.String)">
            <summary>
            Set an attribute on the xml element produced by this sub-class mapping.
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">Attribute value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubClassPart`1.LazyLoad">
            <summary>
            Sets whether this subclass is lazy loaded
            </summary>
            <returns></returns>
        </member>
        <member name="P:FluentNHibernate.Mapping.SubClassPart`1.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.SubClassPart`1.FluentNHibernate#Mapping#IMappingPart#PositionOnDocument">
            <summary>
            Indicates a constant, general position on the document the part should be written to
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.SubClassPart`1.FluentNHibernate#Mapping#IMappingPart#LevelWithinPosition">
            <summary>
            Indicates a constant sub-position within a similar grouping of positions the element will be written in
            </summary>
        </member>
        <member name="M:FluentNHibernate.Reveal.Property``1(System.String)">
            <summary>
            Reveals a hidden property for use instead of expressions.
            </summary>
            <typeparam name="TEntity">Entity type</typeparam>
            <param name="propertyName">Name of property</param>
            <returns>Expression for the hidden property</returns>
        </member>
        <member name="M:FluentNHibernate.Reveal.Property``2(System.String)">
            <summary>
            Reveals a hidden property with a specific return type for use instead of expressions.
            </summary>
            <typeparam name="TEntity">Entity type</typeparam>
            <typeparam name="TReturn">Property return type</typeparam>
            <param name="propertyName">Name of property</param>
            <returns>Expression for the hidden property</returns>
        </member>
    </members>
</doc>
