# Job Consumers

In MassTransit, when a message is delivered from the broker to a consumer, it gets locked by the broker until the consumer completes processing. This lock
ensures that the message won’t be delivered to other consumers, even on different bus instances reading from the same queue (the competing consumer pattern).
Once the consumer completes, the message is acknowledged and removed from the queue. However, if the connection to the broker is lost, the message may be
unlocked and redelivered to another consumer. This works well for most cases where the processing time is short.

But what happens when you need to process a message that takes a long time? In scenarios where a task might take several minutes, hours, or even longer, a
standard consumer may not be the best fit. This is where Job Consumers come in.

## What are Job Consumers?

A Job Consumer in MassTransit is a specialized type of consumer designed to handle long-running tasks, often referred to as jobs. Unlike traditional consumers
that lock and process messages quickly, job consumers are built to execute tasks that may take an extended time to complete. They provide additional
functionality to manage long-running tasks, including handling retries, concurrency, and ensuring job completion even in the face of system interruptions.

Job consumers are implemented using the `IJobConsumer<TJob>` interface, where `TJob` represents the message type that defines the job. This makes them ideal for
scenarios where jobs could take minutes or even hours, such as video processing, large data transformations, or background tasks that don’t fit within the
typical message lock period provided by brokers like RabbitMQ, Azure Service Bus, or Amazon SQS.

One critical difference is that job consumers require a saga repository to store and manage the job state. They decouple the task of consuming the message from
the message broker, allowing more flexibility for handling tasks asynchronously and managing retries without relying solely on broker mechanisms.

#### Why Should You Use a Job Consumer?

The key question to ask is: How long does the task take to complete?

- If your task takes less than 5 minutes, a standard consumer is usually sufficient. Brokers like RabbitMQ, Azure, or SQS can hold a message lock for around 5
  minutes, which is often long enough for most tasks.
- If your task exceeds 5 minutes, that’s when you should consider using a job consumer. When tasks exceed the broker’s lock time, you risk message reprocessing
  or failures due to lock timeouts. Job consumers are specifically designed to handle these scenarios without worrying about broker timeouts.

That said, it’s important to recognize that job consumers introduce some computational overhead due to the additional bookkeeping required to manage job state,
retries, and concurrency. Make sure the benefits outweigh the extra complexity before adopting job consumers for your long-running tasks.

:sample{sample="job-consumer"}

A video covering job consumers and the same is available on YouTube:

::div
:video-player{src="https://www.youtube.com/watch?v=nHrbw5cfNVo"}
::

## Implementation

To use job consumers, you'll need to create a consumer that implements the `IJobConsumer<TJob>` interface.

```csharp
public interface IJobConsumer<in TJob> :
    IConsumer
    where TJob : class
{
    Task Run(JobContext<TJob> context);
}
```

```csharp
public class ConvertVideoJobConsumer : 
    IJobConsumer<ConvertVideo>
{
    public async Task Run(JobContext<ConvertVideo> context)
    {
        await Task.Delay(30000, context.CancellationToken);        
    }
}
```

### Job Cancellation

When a job is canceled, the `CancellationToken` on `JobContext` is canceled. Job consumers should check for cancellation using
_IsCancellationRequested_ and when it is safe to cancel call:

`context.CancellationToken.ThrowIfCancellationRequested()`

This ensured the job is properly reported as canceled to the job saga state machines.

::alert{type="info"}
When the bus is stopped and there are job consumers configured on the bus, any running jobs are canceled. Canceled jobs will be restarted by the next available
job consumer instance (added in MassTransit v8.3.0).
::

### Job Progress

> New in MassTransit v8.3.0

Job consumers can track progress and that progress is saved by the job saga. If a job is canceled or faults, the most recently saved progress is included
in the `JobContext` passed to the job consumer if the job is retried.

To save progress, call `SetJobProgress` as shown below.

```csharp
public class ConvertVideoJobConsumer : 
    IJobConsumer<ConvertVideo>
{
    public async Task Run(JobContext<ConvertVideo> context)
    {
        // some aspects of the content being process
        long length = File.Length;
        
        await context.SetJobProgress(0, length);
        
        for (int index = 1; index <= length; index++)
        {
            // do something
        
            context.SetJobProgress(index, length);
        }
    }
}
```

### Job State

> New in MassTransit v8.3.0

Job consumers can save state in the job saga. In the event that a job is canceled or faults, when the job is retried the previously saved state will be
included in the `JobContext` passed to the job consumer.

To save the job state when a job is canceled:

```csharp
public class ConvertVideoJobConsumer : 
    IJobConsumer<ConvertVideo>
{
    public async Task Run(JobContext<ConvertVideo> context)
    {
        // some aspects of the content being process
        long length = File.Length;
        
        int index = 1;
        try
        {
            await context.SetJobProgress(0, length);
            
            for (; index <= length; index++)
            {
                context.CancellationToken.ThrowIfCancellationRequested();
                
                // do something
            
                context.SetJobProgress(index, length);
            }
        }
        catch (OperationCanceledException) when (context.CancellationToken.IsCancellationRequested)
        {
            await context.SaveJobState(new ConsumerState { LastIndex = index });
            throw;            
        }
    }
    
    class ConsumerState
    {
        public long LastIndex { get; set; }
    }
}
```

When the job is started, the consumer can check if a previously saved job state exists, and use it to continue where processing left off.

```csharp
public class ConvertVideoJobConsumer : 
    IJobConsumer<ConvertVideo>
{
    public async Task Run(JobContext<ConvertVideo> context)
    {
        // some aspects of the content being process
        long length = File.Length;
        
        int index = context.TryGetJobState(out ConsumerState? state)
            ? state.LastIndex + 1
            : 1;

        // elided, see above
    }
}
```

The job state type (in this case, `ConsumerState`) is only relevant to the job consumer and is stored as a serialized dictionary in the job saga.

## Configuration

The example below configures a job consumer that is automatically configured by `ConfigureEndpoints`.

```csharp
services.AddMassTransit(x =>
{
    x.AddConsumer<ConvertVideoJobConsumer>(cfg =>
    {
        cfg.Options<JobOptions<ConvertVideo>>(options => options
            .SetJobTimeout(TimeSpan.FromMinutes(15))
            .SetConcurrentJobLimit(10));
    });

    x.AddDelayedMessageScheduler();
    
    x.SetKebabCaseEndpointNameFormatter();

    // in this case, just use the in-memory saga repository, 
    // but an actual database should be used
    x.SetInMemorySagaRepositoryProvider();
    
    x.AddJobSagaStateMachines();

    x.UsingRabbitMq((context, cfg) =>
    {
        cfg.UseDelayedMessageScheduler();
        
        cfg.ConfigureEndpoints(context);
    });
});
```

::alert{type="info"}
The old syntax of creating a service instance and manually configuring job consumers is completely deprecated and will no longer be supported.
::

In this example, the job timeout as well as the number of concurrent jobs allowed is configured via `JobOptions<T>` when configuring the consumer. The job
options can also be specified using a consumer definition in the same way.

### Job Options

There are several job options that can be configured, including:

| Option                       | Type           | Description                                                                                                                  |
|------------------------------|:---------------|------------------------------------------------------------------------------------------------------------------------------|
| `ConcurrentJobLimit`         | `int`          | The number of concurrent jobs allowed to run on a given instance                                                             |
| `JobTimeout`                 | `TimeSpan`     | How long a job consumer is allowed to run before the job is canceled (via the CancellationToken)                             |
| `JobCancellationTimeout`     | `TimeSpan`     | How long after a job consumer is canceled to wait before considering the job canceled regardless of whether it has completed |
| `JobTypeName`                | `string`       | Override the default job type name (optional, not really recommended)                                                        |
| `RetryPolicy`                | `IRetryPolicy` | The retry policy applied when a job faults                                                                                   |
| `ProgressBuffer.TimeLimit`   | `TimeSpan`     | How often any progress updates should be reported to the job saga                                                            |
| `ProgressBuffer.UpdateLimit` | `TimeSpan`     | How many progress updates should be reported before updating the job saga                                                    |

### Job Saga Options

When adding the job saga state machines, the `JobSagaOptions` can also be configured.

```csharp
x.AddJobSagaStateMachines(options =>
{
    options.FinalizeCompleted = true;
    options.ConcurrentMessageLimit = 32;
    options.HeartbeatTimeout = TimeSpan.FromMinutes(5);
    options.SlotWaitTime = TimeSpan.FromSeconds(30);
    options.SuspectJobRetryCount = 2;
    options.SuspectJobRetryDelay = TimeSpan.FromMinutes(1);
});
```

| Option                   | Type       | Description                                                                                                          |
|--------------------------|:-----------|----------------------------------------------------------------------------------------------------------------------|
| `FinalizeCompleted`      | `bool`     | Automatically remove completed job sagas                                                                             |
| `ConcurrentMessageLimit` | `int`      | Specifies the concurrency of the job service sagas (not the actual jobs)                                             |
| `HeartbeatInterval`      | `TimeSpan` | Period of time after which a job consumer instance is removed from the active list if no heartbeat has been received |
| `SlotWaitTime`           | `TimeSpan` | How long a job waits for an available job slot between attempts                                                      |
| `SuspectJobRetryCount`   | `int`      | How many times to retry a job that becomes suspect (not faulted, but the job consumer instance stops responding)     |
| `SuspectJobRetryDelay`   | `TimeSpan` | How long a job should wait retrying when the job became suspect and `SuspectJobRetryCount` is > 0                    |

## Submitting a job

To submit a job, call the `SubmitJob` extension method on an `IPublishEndpoint` as shown below. This is a fire-and-forget method, no response is sent.

```csharp
[HttpPut("{path}")]
public async Task<IActionResult> FireAndForgetSubmitJob(string path, [FromServices] IPublishEndpoint publishEndpoint)
{
    var jobId = await publishEndpoint.SubmitJob<ConvertVideo>(new ConvertVideo
    {
        Path = path
    });

    return Ok(new
    {
        jobId,
        path
    });
}
```

To wait for a response indicating the job submission was successful (not really necessary, but commonly used), use the request client, `IRequestClient<T>`,
submit a job using the `SubmitJob` extension method as shown below. The _RequestId_ generated by the request client will be used as the _JobId_.

```csharp
[HttpPost("{path}")]
public async Task<IActionResult> SubmitJob(string path, [FromServices] IRequestClient<ConvertVideo> client)
{    
    var jobId = await client.SubmitJob(new ConvertVideo
    {
        Path = path
    });

    return Ok(new
    {
        jobId,
        path
    });
}
```

Additionally, a `jobId` can be specified if the `IRequestClient<SubmitJob<TJob>>` interface is used instead.

```csharp
[HttpPost("{path}")]
public async Task<IActionResult> SubmitJob(string path, [FromServices] IRequestClient<SubmitJob<ConvertVideo>> client)
{
    var jobId = NewId.NextGuid();
        
    await client.SubmitJob(jobId, new ConvertVideo
    {
        Path = path
    });

    return Ok(new
    {
        jobId,
        path
    });
}
```

## Job Saga Endpoints

The job saga state machines are configured on their own endpoints, using the configured endpoint name formatter. These endpoints are required on _at
least one_ bus instance. Additionally, it is not necessary to configure them on _every_ bus instance. In the example above, the job saga state machines
endpoints
are configured. A standard __ConfigureEndpoints__ call will suffice to host the job consumers without the job saga state machines.

### Job Saga Repository

A persistent saga repository should be used with job consumers, and should be configured when adding the job saga state machines. In the example below,
Entity Framework Core is configured, along with the Postgres lock statement provider (required when using PostgreSQL).

```csharp
x.AddJobSagaStateMachines()
    .EntityFrameworkRepository(r =>
    {
        r.ExistingDbContext<JobServiceSagaDbContext>();
        r.UsePostgres();
    });
```

For a more detailed example of configuring the job saga state machine endpoints, including persistent storage, see the sample mentioned in the box above.

## Job Saga State Machines

Job consumers use three saga state machines to orchestrate jobs and keep track of available job consumer instances.

| Variable       | Description                                                                           |
|----------------|---------------------------------------------------------------------------------------|
| JobSaga        | Orchestrates each job, including scheduling, retry, and failure handling              |
| JobAttemptSaga | Orchestrates each job attempt, communicating directly with the job consumer instances |
| JobTypeSaga    | Keep track of available job instances and allocates job slots to waiting jobs         |

### Job Saga States

A job can be in one of the following states:

1. Initial
2. Final
3. Submitted
4. Waiting to Start
5. Waiting for Slot
6. Started
7. Completed
8. Faulted
9. Canceled
10. Starting Job Attempt
11. Allocating Job Slot
12. Waiting to Retry

### Job Attempt Saga States

A job attempt can be in one of the following states:

1. Initial
2. Final
3. Starting
4. Running
5. Faulted
6. Checking Status
7. Suspect

### Job Type Saga States

A job type has only two valid states

1. Initial
2. Final
3. Active
4. Idle

