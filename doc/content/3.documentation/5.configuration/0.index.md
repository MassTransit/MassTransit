---
navigation.title: Overview
---

# Configuration

MassTransit is usable in most .NET application types. MassTransit is easily configured in ASP.NET Core or .NET Generic Host applications (using .NET 6 or later).

To use MassTransit, add the _MassTransit_ package (from NuGet) and start with the _AddMassTransit_ method shown below.

```csharp
using MassTransit;

services.AddMassTransit(x =>
{
    x.UsingRabbitMq((context, cfg) =>
    {
    });
});
```

In this configuration, the following variables are used:

| Variable  | Type                              | Description                                                                               |
|-----------|:----------------------------------|-------------------------------------------------------------------------------------------|
| `x`       | `IBusRegistrationConfigurator`    | Configure the bus instance (not transport specific) and the underlying service collection |
| `context` | `IBusRegistrationContext`         | The configured bus context, also implements `IServiceProvider`                            |
| `cfg`     | `IRabbitMqBusFactoryConfigurator` | Configure the bus specific to the transport (each transport has its own interface type    |

:::alert{type="info"}
The callback passed to the _UsingRabbitMq_ method is invoked after the service collection has been built. Any methods to configure the bus instance (using `x`) should be called outside of this callback.
:::

Adding MassTransit, as shown above, will configure the service collection with required components, including:

 * Several interfaces (and their implementations, appropriate for the transport specified)
   * `IBus` (singleton)
   * `IBusControl` (singleton)
   * `IReceiveEndpointConnector` (singleton)
   * `ISendEndpointProvider` (scoped)
   * `IPublishEndpoint` (scoped)
   * `IRequestClient<T>` (scoped)
 * The bus endpoint with the default settings (not started by default)
 * The _MassTransitHostedService_
 *  Health checks for the bus (or buses) and receive endpoints
 * Using `ILoggerFactory` for log output

> To configure multiple bus instances in the same service collection, refer to the [MultiBus](/documentation/configuration/multibus) section.

## Host Options

MassTransit adds a hosted service so that the generic host can start and stop the bus (or buses, if multiple bus instances are configured). The host options can be configured via _MassTransitHostOptions_ using the _Options_ pattern as shown below.

```csharp
services.AddOptions<MassTransitHostOptions>()
    .Configure(options =>
    {
    });
```

| Option              | Description                                                                                                                                                                                                                                          |
|---------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| WaitUntilStarted    | By default, MassTransit connects to the broker asynchronously. When set to _true_, the MassTransit Hosted Service will block startup until the broker connection has been established.                                                               |
| StartTimeout        | By default, MassTransit waits infinitely until the broker connection is established. If specified, MassTransit will give up after the timeout has expired.                                                                                           | 
| StopTimeout         | MassTransit waits infinitely for the bus to stop, including any active message consumers. If specified, MassTransit will force the bus to stop after the timeout has expired.                                                                        | 
| ConsumerStopTimeout | If specified, the `ConsumeContext.CancellationToken` will be canceled after the specified timeout when the bus is stopping. This allows long-running consumers to observe the cancellation token and react accordingly. Must be <= the `StopTimeout` | 

::callout{type="info"}
#summary
The .NET Generic Host has its own internal shutdown timeout.
#content
To configure the Generic Host options so that the bus has sufficient time to stop, configure the host options as shown.
```csharp
services.Configure<HostOptions>(
    options => options.ShutdownTimeout = TimeSpan.FromMinutes(1));
```
::

## Transport Options

Each supported transport has configurable options that can be configured using .NET _options_. In the RabbitMQ example above, the [RabbitMqTransportOptions](/documentation/configuration/transports/rabbitmq#transport-options) should be used to configure the transport.

The transport can also be configured using the `.Host()` method. 


## Consumers

In the configuration shown above, the bus is only configured to publish messages, send messages, and send requests/receive responses. To consume messages, one or more consumers should be added and receive endpoints configured for the added consumers. MassTransit connects each receive endpoint to a queue on the message broker.

To add a consumer and automatically configure a receive endpoint for the consumer, call one of the [_AddConsumer_](/documentation/configuration/bus/consumers) methods and call _ConfigureEndpoints_ as shown below.

```csharp
services.AddMassTransit(x =>
{
    x.AddConsumer<SubmitOrderConsumer>();
    
    x.UsingRabbitMq((context, cfg) =>
    {
        cfg.ConfigureEndpoints(context);
    });
});
```

:::alert{type="info"}
**_ConfigureEndpoints_** should be the last method called after all settings and middleware components have been configured.
:::

MassTransit will automatically configure a receive endpoint for the _SubmitOrderConsumer_ using the name returned by the configured endpoint name formatter. When the bus is started, the receive endpoint will be started and messages will be delivered from the queue by the transport to an instance of the consumer.

> All consumer types can be added, including consumers, sagas, saga state machines, and routing slip activities. If a job consumer is added, [additional configuration](/documentation/patterns/job-consumers) is required.

::callout{type="info"}
#summary
Learn about the default conventions as well as how to tailor the naming style to meet your requirements in this short video:
#content
::div
  :video-player{src="https://www.youtube.com/watch?v=bsUlQ93j2MY"}
::
::

To exclude a consumer, saga, or routing slip activity from automatic configuration, use the _ExcludeFromConfigureEndpoints_ extension method when adding the consumer:

```csharp
x.AddConsumer<SubmitOrderConsumer>()
    .ExcludeFromConfigureEndpoints()
```

Alternatively, the _ExcludeFromConfigureEndpoints_ attribute may be specified on the consumer.

```csharp
[ExcludeFromConfigureEndpoints]
public class SubmitOrderConsumer :
    IConsumer<SubmitOrder>
{
}
```

## Endpoint Name Formatters

_ConfigureEndpoints_ uses an `IEndpointNameFormatter` to format the queue names for all supported consumer types. The default endpoint name formatter returns _PascalCase_ class names without the namespace. There are several built-in endpoint name formatters included. For the _SubmitOrderConsumer_, the receive endpoint names would be formatted as shown below. Note that class suffixes such as _Consumer_, _Saga_, and _Activity_ are trimmed from the endpoint name by default.

| Format     | Configuration                       | Name           |
|:-----------|:------------------------------------|:---------------|
| Default    | `SetDefaultEndpointNameFormatter`   | `SubmitOrder`  |
| Snake Case | `SetSnakeCaseEndpointNameFormatter` | `submit_order` |
| Kebab Case | `SetKebabCaseEndpointNameFormatter` | `submit-order` |

The endpoint name formatters can also be customized by constructing a new instance and configuring MassTransit to use it.

```csharp
x.SetEndpointNameFormatter(new KebabCaseEndpointNameFormatter(prefix: "Dev"));
```

By specifying a prefix, the endpoint name would be `dev-submit-order`. This is useful when sharing a single broker with multiple developers (Amazon SQS is account-wide, for instance).

::callout{type="info"}
#summary
When using MultiBus with different endpoint name formatters for each bus... 
#content
Specify the endpoint name formatter when calling `ConfigureEndpoints` as shown. 
```csharp
cfg.ConfigureEndpoints(context, new KebabCaseEndpointNameFormatter(prefix: "Mobile"));
```
::

## Receive Endpoints

The previous examples use conventions to configure receive endpoints. Alternatively, receive endpoints can be explicitly configured. 

> When configuring endpoints manually, _ConfigureEndpoints_ should be excluded or be called **after** any explicitly configured receive endpoints.

To explicitly configure endpoints, use the _ConfigureConsumer_ or _ConfigureConsumers_ method.

```csharp
services.AddMassTransit(x =>
{
    x.AddConsumer<SubmitOrderConsumer>();
    
    x.UsingRabbitMq((context, cfg) =>
    {
        cfg.ReceiveEndpoint("order-service", e =>
        {
            e.ConfigureConsumer<SubmitOrderConsumer>(context);
        });
    });
});
```

Receive endpoints have transport-independent settings that can be configured.

| Name                     | Description                                                                 | Default                                                                   |
|:-------------------------|:----------------------------------------------------------------------------|:--------------------------------------------------------------------------|
| PrefetchCount            | Number of unacknowledged messages delivered by the broker                   | max(CPU Count x 2,16)                                                     |
| ConcurrentMessageLimit   | Number of concurrent messages delivered to consumers                        | (none, uses PrefetchCount)                                                |
| ConfigureConsumeTopology | Create exchanges/topics on the broker and bind them to the receive endpoint | true                                                                      |
| PublishFaults            | Publish `Fault<T>` events when consumers fault                              | true                                                                      |
| DefaultContentType       | The default content type for received messages                              | See [serialization](configuration/integrations/serialization#serializers) |
| SerializerContentType    | The default content type for sending/publishing messages                    | See [serialization](configuration/integrations/serialization#serializers) |

> The _PrefetchCount_, _ConcurrentMessageLimit_, and serialization settings can be specified at the bus level and will be applied to all receive endpoints.

In the following example, the _PrefetchCount_ is set to 32 and the _ConcurrentMessageLimit_ is set to 28.

```csharp
services.AddMassTransit(x =>
{
    x.AddConsumer<SubmitOrderConsumer>();
    
    x.UsingRabbitMq((context, cfg) =>
    {
        cfg.PrefetchCount = 32; // applies to all receive endpoints
        
        cfg.ReceiveEndpoint("order-service", e =>
        {
            e.ConcurrentMessageLimit = 28; // only applies to this endpoint
            e.ConfigureConsumer<SubmitOrderConsumer>(context);
        });
    });
});
```

> When using _ConfigureConsumer_ with a consumer that has a definition, the _EndpointName_, _PrefetchCount_, and _Temporary_ properties of the consumer definition are not used.

### Temporary Endpoints

Some consumers only need to receive messages while connected, and any messages published while disconnected should be discarded. This can be achieved by using a TemporaryEndpointDefinition to configure the receive endpoint.

```csharp
services.AddMassTransit(x =>
{
    x.AddConsumer<SubmitOrderConsumer>();

    x.UsingInMemory((context, cfg) =>
    {
        cfg.ReceiveEndpoint(new TemporaryEndpointDefinition(), e =>
        {
            e.ConfigureConsumer<SubmitOrderConsumer>(context);
        });

        cfg.ConfigureEndpoints(context);
    });
});
```

### Consumer Definition

A consumer definition is used to configure the receive endpoint and pipeline behavior for the consumer. When scanning assemblies or namespaces for consumers, consumer definitions are also found and added to the container. The _SubmitOrderConsumer_ and matching definition are shown below.

```csharp
class SubmitOrderConsumer :
    IConsumer<SubmitOrder>
{
    readonly ILogger<SubmitOrderConsumer> _logger;

    public SubmitOrderConsumer(ILogger<SubmitOrderConsumer> logger)
    {
        _logger = logger;
    }

    public async Task Consume(ConsumeContext<SubmitOrder> context)
    {
        _logger.LogInformation("Order Submitted: {OrderId}", context.Message.OrderId);

        await context.Publish<OrderSubmitted>(new
        {
            context.Message.OrderId
        });
    }
}

class SubmitOrderConsumerDefinition :
    ConsumerDefinition<SubmitOrderConsumer>
{
    public SubmitOrderConsumerDefinition()
    {
        // override the default endpoint name
        EndpointName = "order-service";

        // limit the number of messages consumed concurrently
        // this applies to the consumer only, not the endpoint
        ConcurrentMessageLimit = 8;
    }

    protected override void ConfigureConsumer(IReceiveEndpointConfigurator endpointConfigurator,
        IConsumerConfigurator<SubmitOrderConsumer> consumerConfigurator)
    {
        // configure message retry with millisecond intervals
        endpointConfigurator.UseMessageRetry(r => r.Intervals(100,200,500,800,1000));

        // use the outbox to prevent duplicate events from being published
        endpointConfigurator.UseInMemoryOutbox();
    }
}
```

### Endpoint Definition

To configure the endpoint for a consumer registration, or override the endpoint configuration in the definition, the `Endpoint` method can be added to the consumer registration. This will create an endpoint definition for the consumer, and register it in the container. This method is available on consumer and saga registrations, with separate execute and compensate endpoint methods for activities.

```csharp
services.AddMassTransit(x =>
{
    x.AddConsumer<SubmitOrderConsumer>(typeof(SubmitOrderConsumerDefinition))
        .Endpoint(e =>
        {
            // override the default endpoint name
            e.Name = "order-service-extreme";

            // specify the endpoint as temporary (may be non-durable, auto-delete, etc.)
            e.Temporary = false;

            // specify an optional concurrent message limit for the consumer
            e.ConcurrentMessageLimit = 8;

            // only use if needed, a sensible default is provided, and a reasonable
            // value is automatically calculated based upon ConcurrentMessageLimit if
            // the transport supports it.
            e.PrefetchCount = 16;

            // set if each service instance should have its own endpoint for the consumer
            // so that messages fan out to each instance.
            e.InstanceId = "something-unique";
        });

    x.UsingRabbitMq((context, cfg) => cfg.ConfigureEndpoints(context));
});
```

When the endpoint is configured after the _AddConsumer_ method, the configuration then overrides the endpoint configuration in the consumer definition. However, it cannot override the `EndpointName` if it is specified in the constructor. The order of precedence for endpoint naming is explained below.

1. Specifying `EndpointName = "submit-order-extreme"` in the constructor which cannot be overridden

    ```csharp
    x.AddConsumer<SubmitOrderConsumer, SubmitOrderConsumerDefinition>()

    public SubmitOrderConsumerDefinition()
    {
        EndpointName = "submit-order-extreme";
    }
    ```

2. Specifying `.Endpoint(x => x.Name = "submit-order-extreme")` in the consumer registration, chained to `AddConsumer`

    ```csharp
    x.AddConsumer<SubmitOrderConsumer, SubmitOrderConsumerDefinition>()
        .Endpoint(x => x.Name = "submit-order-extreme");

    public SubmitOrderConsumerDefinition()
    {
        Endpoint(x => x.Name = "not used");
    }
    ```

3. Specifying `Endpoint(x => x.Name = "submit-order-extreme")` in the constructor, which creates an endpoint definition

    ```csharp
    x.AddConsumer<SubmitOrderConsumer, SubmitOrderConsumerDefinition>()

    public SubmitOrderConsumerDefinition()
    {
        Endpoint(x => x.Name = "submit-order-extreme");
    }
    ```

4. Unspecified, the endpoint name formatter is used (in this case, the endpoint name is `SubmitOrder` using the default formatter)

    ```csharp
    x.AddConsumer<SubmitOrderConsumer, SubmitOrderConsumerDefinition>()

    public SubmitOrderConsumerDefinition()
    {
    }
    ```

### Saga Registration

To add a state machine saga, use the _AddSagaStateMachine_ methods. For a consumer saga, use the _AddSaga_ methods.

::alert{type="success"}
State machine sagas should be added before class-based sagas, and the class-based saga methods should not be used to add state machine sagas. This may be simplified in the future, but for now, be aware of this registration requirement.
::

```csharp
services.AddMassTransit(r =>
{
    // add a state machine saga, with the in-memory repository
    r.AddSagaStateMachine<OrderStateMachine, OrderState>()
        .InMemoryRepository();

    // add a consumer saga with the in-memory repository
    r.AddSaga<OrderSaga>()
        .InMemoryRepository();

    // add a saga by type, without a repository. The repository should be registered
    // in the container elsewhere
    r.AddSaga(typeof(OrderSaga));

    // add a state machine saga by type, including a saga definition for that saga
    r.AddSagaStateMachine(typeof(OrderState), typeof(OrderStateDefinition))

    // add all saga state machines by type
    r.AddSagaStateMachines(Assembly.GetExecutingAssembly());

    // add all sagas in the specified assembly
    r.AddSagas(Assembly.GetExecutingAssembly());

    // add sagas from the namespace containing the type
    r.AddSagasFromNamespaceContaining<OrderSaga>();
    r.AddSagasFromNamespaceContaining(typeof(OrderSaga));
});
```

To add a saga registration and configure the consumer endpoint in the same expression, a definition can automatically be created.

```csharp
services.AddMassTransit(r =>
{
    r.AddSagaStateMachine<OrderStateMachine, OrderState>()
        .NHibernateRepository()
        .Endpoint(e =>
        {
            e.Name = "order-state";
            e.ConcurrentMessageLimit = 8;
        });
});
```

Supported saga persistence storage engines are documented in the [saga documentation](/documentation/patterns/saga/) section.


```csharp
services.AddMassTransit(x =>
{
    x.AddConsumer<ValueEnteredEventConsumer>();

    x.SetKebabCaseEndpointNameFormatter();

    x.UsingRabbitMq((context, cfg) =>
    {
        cfg.ConfigureEndpoints(context);
    });
});
```

And the consumer: 

```csharp
class ValueEnteredEventConsumer :
    IConsumer<ValueEntered>
{
    ILogger<ValueEnteredEventConsumer> _logger;

    public ValueEnteredEventConsumer(ILogger<ValueEnteredEventConsumer> logger)
    {
        _logger = logger;
    }

    public async Task Consume(ConsumeContext<ValueEntered> context)
    {
        _logger.LogInformation("Value: {Value}", context.Message.Value);
    }
}
```

An ASP.NET Core application can also configure receive endpoints. The consumer, along with the receive endpoint, is configured within the _AddMassTransit_ configuration. Separate registration of the consumer is not required (and discouraged), however, any consumer dependencies should be added to the container separately. Consumers are registered as scoped, and dependencies should be registered as scoped when possible, unless they are singletons.

```csharp
services.AddMassTransit(x =>
{
    x.AddConsumer<EventConsumer>();

    x.UsingRabbitMq((context, cfg) =>
    {
        cfg.ReceiveEndpoint("event-listener", e =>
        {
            e.ConfigureConsumer<EventConsumer>(context);
        });
    });
});
```

```csharp
class EventConsumer :
    IConsumer<ValueEntered>
{
    ILogger<EventConsumer> _logger;

    public EventConsumer(ILogger<EventConsumer> logger)
    {
        _logger = logger;
    }

    public async Task Consume(ConsumeContext<ValueEntered> context)
    {
        _logger.LogInformation("Value: {Value}", context.Message.Value);
    }
}
```

## Health Checks

The _AddMassTransit_ method adds bus health checks to the service collection. To configure health checks, map the ready and live endpoints in your ASP.NET application.

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health/ready", new HealthCheckOptions()
    {
        Predicate = (check) => check.Tags.Contains("ready"),
    });

    endpoints.MapHealthChecks("/health/live", new HealthCheckOptions());
});
```

## Transports

:FolderNavigation{path='documentation/configuration/transports'}

## Persistence

:FolderNavigation{path='documentation/configuration/persistence'}

## Middleware

:FolderNavigation{path='documentation/configuration/middleware'}

## Scheduling

:FolderNavigation{path='documentation/configuration/scheduling'}

## Integrations

:FolderNavigation{path='documentation/configuration/integration'}
