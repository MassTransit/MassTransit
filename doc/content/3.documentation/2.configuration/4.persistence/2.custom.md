# Custom Persistence

[NUGET BADGE HERE]

## Overview

Custom Persistence provides a lightweight persistence layer for MassTransit sagas and MessageData when teams cannot use ORMs like Entity Framework or other supported persistence providers. This solution requires only database-specific drivers and gives developers precise control over persistence workflows.

## When to Use

- You need fine-grained control over database interactions
- You want to integrate with existing data access patterns
- You're building proof-of-concept applications and want to understand MassTransit's persistence internals
- Your team has restrictions preventing ORM usage (but still allows MassTransit for some reason)
- You require custom MessageData storage with specific cleanup policies

## Migrating from MassTransit.DapperIntegration

Converting from MassTransit.DapperIntegration is straightforward.  The original integration only supported Sql Server, so migration is generally as simple as adding the `MassTransit.Persistence.SqlServer` NuGet package, and changing your saga registrations as shown below:

```csharp
services.AddMassTransit(bus =>
{
    // old:
    bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
        .DapperRepository("my connection string");

    // new:
    bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
        .CustomRepository(conf => conf.UseSqlServer("my connection string"));
});
```

The `Dapper.Contrib` attributes for `[Table("orders")]`, `[Key]` and `[ExplicitKey]` behave as before.  If your original DapperIntegration repository used more advanced features from Dapper, such as custom TypeMappers, then you will need to create a custom `DatabaseContext<TSaga>` implementation.

## Quick Start

Install the appropriate NuGet package for your database:

```bash
Install-Package MassTransit.Persistence.SqlServer
Install-Package MassTransit.Persistence.Postgres
Install-Package MassTransit.Persistence.MySql
```

## Basic Configuration

```csharp
services.AddMassTransit(bus =>
{
    bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
        .CustomRepository(conf => 
            conf.UsingSqlServer(opt => opt.SetConnectionString("my connection string"))
        );
});
```
This creates a repository for the `OrderSaga` model with the following behaviors as default:

- **Concurrency**: Pessimistic
- **Isolation**: Repeatable Read transaction isolation
- **Table naming**: `OrderSagas`
- **Primary key**: `CorrelationId`

Each of these properties can be changed at startup via configuration methods:
```csharp
bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
    .CustomRepository(conf => conf.UsingSqlServer(opt => opt
        .SetConnectionString("my connection string")
        .SetTableName("Orders")
        .SetIdentityColumnName("OrderId")
        .SetOptimisticConcurrency(m => m.RowVersion)
    ));
```

Database-specific setup instructions and SQL scripts are available in separate documents.

- [Using SQL Server](2.database-specific/2.custom.sqlserver.md)
- [Using PostgreSQL](2.database-specific/3.custom.postgres.md)
- [Using MySQL](2.database-specific/4.custom.mysql.md)


## Customization

### Custom Context Factory

Register your repository in DI and specify it as a context factory:

```csharp
services.AddScoped<DatabaseContext<OrderSaga>, OrderSagaRepository>();

bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
    .CustomRepository(conf => conf.SetContextFactory(
        async ctx => ctx.GetRequiredService<DatabaseContext<OrderSaga>>()
    ));
```

### Base Class Implementation

Each database provider includes optimistic and pessimistic base classes:

```csharp
public class OrderSagaRepository : OptimisticSqlServerDatabaseContext<OrderSaga>
{
    const string MyTableName = "Orders";
    const string MyIdColumnName = "OrderId";
    const string MyVersionColumnName = "RowVersion";
    const string MyVersionPropertyName = nameof(OrderSaga.RowVersion);

    public OrderSagaRepository(string connectionString)
        : base(connectionString, MyTableName, MyIdColumnName, MyVersionColumnName, MyVersionPropertyName)
    {
    }
}
```


Override query methods to use stored procedures or custom SQL:

```csharp
protected override string BuildInsertSql() => "usp_AddOrder";
protected override string BuildUpdateSql() => "usp_UpdateOrder";
protected override string BuildDeleteSql() => "usp_DeleteOrder";
protected override string BuildLoadSql() => "usp_GetOrder";

// Or custom SQL with additional logic
protected override string BuildInsertSql() => 
    "INSERT INTO Orders VALUES (@correlationid, @rowversion, GETUTCDATE(), dbo.ufn_GetTenantId());";
```

Custom Object Mapping

#### Reader Adapter (Database &rarr; Saga)

```csharp
protected override Func<IDataReader, OrderSaga> CreateReaderAdapter() => MapFrom;

static OrderSaga MapFrom(IDataReader reader)
{
    if (reader is not SqlDataReader r)
        throw new InvalidOperationException("Only SqlDataReader is supported in this custom adapter");

    return new OrderSaga
    {
        CorrelationId = r.GetFieldValue<Guid>("OrderId"),
        RowVersion = r.GetFieldValue<byte[]>("RowVersion"),
        CreatedOn = r.GetFieldValue<DateTime>("CreatedOn"),
        Items = r.FromJson<List<OrderItem>>("ItemsJson")
    };
}
```

> **Note**: The `IDataReader` is the raw database provider instance. You must handle `DBNull` values properly. Extension methods like `GetInt32OrNull("columnName")` are available, as well as `.ToJson()` and `.FromJson<T>()`.

#### Writer Adapter (Saga &rarr; Database)

```csharp
protected override Action<object?, SqlParameterCollection> CreateWriterAdapter() => MapTo;

static void MapTo(object? input, SqlParameterCollection parameters)
{
    if (input is OrderSaga saga)
    {
        parameters.Add("@correlationid", SqlDbType.UniqueIdentifier).Value = saga.CorrelationId;
        parameters.Add("@rowversion", SqlDbType.Timestamp).Value = saga.RowVersion;
        parameters.Add("@createdon", SqlDbType.DateTime2).Value = saga.CreatedOn;
        parameters.Add("@itemsjson", SqlDbType.NVarChar).Value = saga.Items.ToJson().OrDbNull();
        return;
    }

    AssignParameters(input, parameters);
}
```

> **Note**: Use `OrDbNull()` extension method to handle null values properly.


#### Connection and Command Customization

```csharp
// Called immediately after connection opens
protected override ValueTask OnConnectionOpened(SqlConnection connection, CancellationToken cancellationToken)
{
    // The Pessimistic implementations use this hook to start the transaction.
    connection.StatisticsEnabled = true;
    return base.OnConnectionOpened(connection, cancellationToken);
}

// Called immediately before command execution
protected override ValueTask OnParametersWritten(SqlCommand command, CancellationToken cancellationToken)
{
    command.Parameters.Add("@tenantid", SqlDbType.Int).Value = _tenantId;

    return base.OnParametersWritten(command, cancellationToken);
}
```

### Facade Pattern Implementation

Integrate with existing service layers:

```csharp
public class OrderSagaRepository : DatabaseContext<OrderSaga>
{
    readonly IOrderService _service;

    public OrderSagaRepository(IOrderService service)
        => _service = service;

    public ValueTask DisposeAsync() 
        => _service.DisposeAsync();

    public void Dispose() 
        => _service.Dispose();

    public Task DeleteAsync(OrderSaga instance, CancellationToken cancellationToken = default)
        => _service.RemoveOrder(instance.CorrelationId, cancellationToken);

    public Task<OrderSaga?> LoadAsync(Guid correlationId, CancellationToken cancellationToken = default)
        => _service.GetOrderById(correlationId, cancellationToken);

    public Task InsertAsync(OrderSaga instance, CancellationToken cancellationToken = default)
        => _service.CreateOrder(instance, cancellationToken);

    public Task UpdateAsync(OrderSaga instance, CancellationToken cancellationToken = default)
        => _service.UpdateOrder(instance, cancellationToken);

    public IAsyncEnumerable<OrderSaga> QueryAsync(Expression<Func<OrderSaga, bool>> filterExpression, CancellationToken cancellationToken = default)
        => throw new NotSupportedException("Orders do not need searches right now");

    public Task CommitAsync(CancellationToken cancellationToken = default)
        => _service.SaveChangesAsync(cancellationToken);
}
```


## Limitations and Tradeoffs

The following limitations apply to the included implementations.  Overriding various functions can be used to work around any one of these limitations.

**Parameter Mapping**

- Parameters map 1:1 to columns with case-insensitive names
- Only primary key and concurrency token columns can be renamed
- No automatic data type conversion

**Correlation Expressions**

- Limited query grammar support compared to full ORMs:

```csharp
// Supported expressions
x => x.CorrelationId == id;
x => x.IsDone;
x => !x.IsRunning;
x => x.Threshold < minimum;  // supports <, <=, ==, !=, >=, >
x => x.IsDone && !x.IsRunning && x.Threshold < minimum;

// Complex joins, subqueries, and advanced SQL features require custom implementation
```