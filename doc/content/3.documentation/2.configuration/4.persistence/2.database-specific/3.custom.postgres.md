# PostgreSql Setup Guide

## Saga Table Creation

### Basic Sagas

::callout{type="info"}
#summary
Using Optimistic Concurrency

#content
::div
Include a `uint` property on the model.  The default name is `XMin`, but the property can be specified in the configuration. Saga model:
```csharp
public class OrderSaga : SagaStateMachineInstance
{
    public Guid CorrelationId { get; set; }
    public uint XMin { get; set; }
    public int CurrentState { get; set; }
    public DateTime CreatedOn { get; set; }
    public DateTime UpdatedOn { get; set; }
}
```

Registration:
```csharp
services.AddMassTransit(bus => 
{
    bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
        .CustomRepository(conf => 
            conf.UsingPostgres(opt => 
            {
                opt.SetConnectionString("my connection string");
                opt.SetOptimisticConcurrency();
                opt.SetTableName("order_sagas");
            }
        ));
});
```

Create table script:
```sql
CREATE TABLE order_sagas (
    correlation_id UUID PRIMARY KEY,
    current_state INT NOT NULL,
    created_on TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_on TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```
::
::

::callout{type="info"}
#summary
Using Pessimistic Concurrency

#content
::div
Saga model:
```csharp
public class OrderSaga : SagaStateMachineInstance
{
    public Guid CorrelationId { get; set; }
    public int CurrentState { get; set; }
    public DateTime CreatedOn { get; set; }
    public DateTime UpdatedOn { get; set; }
}
```

Registration:
```csharp
services.AddMassTransit(bus => 
{
    bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
        .CustomRepository(conf => 
            conf.UsingPostgres(opt => 
            {
                opt.SetConnectionString("my connection string");
                opt.SetPessimisticConcurrency();
                opt.SetTableName("order_sagas");
            }
        ));
});
```

Create table script:
```sql
CREATE TABLE order_sagas (
    correlation_id UUID PRIMARY KEY,
    current_state INT NOT NULL,
    created_on TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_on TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```
::
::

### Customized Repository Example

#### Saga model:

Most sagas are more complex than 2 primitive properties and a timestamp.  Consider a more representative example below:
```csharp
public class OrderSaga : SagaStateMachineInstance
{
    public Guid CorrelationId { get; set; }
    public uint Version { get; set; }
    public int CurrentState { get; set; }
    public string OrderNumber { get; set; }
    public Guid? CustomerId { get; set; }
    public decimal TotalAmount { get; set; }    
    public DateTime CreatedOn { get; set; }
    public DateTime UpdatedOn { get; set; }

    public ICollection<OrderItem> Items { get; set; } = [];
}

public record OrderItem(Guid ItemId, int Quantity, decimal ItemPrice);
```

#### Registration
Registration is different from before, because the provider doesn't know how to inject a completely custom service.  In this case, you must specify a factory.  The `serviceProvider` parameter is the DI container everything was registered against.  This example shows pulling the connection string from application options.
```csharp
bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
    .CustomRepository(conf => conf.SetContextFactory(
        async serviceProvider => 
        {
            var options = serviceProvider.GetRequiredService<IOptions<ApplicationOptions>>().Value;
            return new PostgresOrderSagaRepository(options.ConnectionString);
        }
    ));
```

#### Repository

The repository shows a more advanced usage of supported features.  The collection of `Items` is serialized to/from JSON, but because the table structure is different from the saga, the property must be renamed via `MapProperty`.  Pay close attention to the relationship of the model property "Items", as that controls the name of the parameter "@items".  The MapProperty method is used to rename the generated column name.  Without this mapping, the column name is assumed to be just `[Items]`, which means other expectations relying on that will fail.

```csharp
public class PostgresOrderSagaRepository : OptimisticPostgresDatabaseContext<OrderSaga>
{
    public PostgresOrderSagaRepository(string connectionString)
        // base constructor shows setting the table, id, and version names
        : base(connectionString, "order_sagas", "correlationid", "Version")
    {
        MapProperty(saga => saga.Items, "ItemsJson");
    }

    protected override Func<IDataReader, OrderSaga> CreateReaderAdapter() => MapFromReader;
    static OrderSaga MapFromReader(IDataReader reader)
    {
        var r = (NpgsqlDataReader)reader;
        return new OrderSaga
        {
            CorrelationId = r.GetGuid("correlationid"),
            CurrentState = r.GetInt32("current_state"),
            OrderNumber = r.GetString("order_number"),
            CustomerId = r.GetGuidOrNull("customer_id"),
            TotalAmount = r.GetDecimal("total_amount"),
            Items = r.FromJson<List<OrderItem>>("items_json") ?? [],
            CreatedOn = r.GetDateTime("created_on"),
            UpdatedOn = r.GetDateTime("updated_on"),
            RowVersion = r.GetFieldValue<byte[]>("RowVersion")
        };
    }

    protected override Action<object?, NpgsqlParameterCollection> CreateWriterAdapter() => MapToParameters;
    static void MapToParameters(object? input, NpgsqlParameterCollection parameters)
    {
        if (input is OrderSaga saga)
        {
            parameters.Add("@correlationid", NpgsqlDbType.UniqueIdentifier).Value = saga.CorrelationId;
            parameters.Add("@currentstate", NpgsqlDbType.Int).Value = saga.CurrentState;
            parameters.Add("@ordernumber", NpgsqlDbType.NVarChar, 50).Value = saga.OrderNumber;
            parameters.Add("@customerid", NpgsqlDbType.UniqueIdentifier).Value = saga.CustomerId.OrDbNull();
            parameters.Add("@totalamount", NpgsqlDbType.Decimal).Value = saga.TotalAmount;
            parameters.Add("@items", NpgsqlDbType.NVarChar).Value = saga.Items.ToJson().OrDbNull();
            parameters.Add("@xmin", NpgsqlDbType.Timestamp).Value = saga.RowVersion;
            return;
        }

        // Fallback for query parameters
        AssignParameters(input, parameters);
    }
}
```

#### Create table script:
```sql
CREATE TABLE order_sagas (
    correlationid UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,
    current_state INT NOT NULL,
    order_number NVARCHAR(50) NOT NULL,
    customer_id UNIQUEIDENTIFIER NULL,
    total_amount DECIMAL(18,2) NOT NULL,    
    created_on DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    updated_on DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    items_json NVARCHAR(MAX) NULL
);
```


## Feature Implementations

### Job Consumers

JobConsumers in MassTransit are implemented via sagas, and the `MassTransit.Persistence.Postgres` package provides a repository for them.  To use the included sagas, the following tables must be created exactly as shown -- at least, as far as names and datatypes are concerned.  Feel free to add additional indexes if needed.

#### Registration:
```csharp
services.AddMassTransit(bus => {
    bus.AddJobSagaStateMachines()
        .CustomRepository(conf => conf.UsingPostgres(
            opt => opt.SetConnectionString("my connection string")
        ));
});
```

#### Create table scripts:
```sql
CREATE TABLE IF NOT EXISTS JobAttempts (
    CorrelationId UUID NOT NULL,
    CurrentState INTEGER NOT NULL,
    JobId UUID NOT NULL,    
    Started TIMESTAMP NULL,
    Faulted TIMESTAMP NULL,
    StatusCheckTokenId UUID NULL,    
    RetryAttempt INTEGER NOT NULL,
    ServiceAddress VARCHAR(1000) NULL,
    InstanceAddress VARCHAR(1000) NULL,
    PRIMARY KEY (CorrelationId)
);

CREATE TABLE IF NOT EXISTS JobTypes (
    CorrelationId UUID NOT NULL,
    Name VARCHAR(255) NOT NULL,
    CurrentState INTEGER NOT NULL,
    ActiveJobCount INTEGER NOT NULL,
    ConcurrentJobLimit INTEGER NOT NULL,
    OverrideJobLimit INTEGER NULL,
    OverrideLimitExpiration TIMESTAMP NULL,
    GlobalConcurrentJobLimit INTEGER NULL,
    ActiveJobs JSONB NULL,
    Instances JSONB NULL,
    Properties JSONB NULL,      
    PRIMARY KEY (CorrelationId)
);

CREATE TABLE IF NOT EXISTS Jobs (
    CorrelationId UUID NOT NULL,
    CurrentState INTEGER NOT NULL,    
    Completed TIMESTAMP NULL,
    Faulted TIMESTAMP NULL,
    Started TIMESTAMP NULL,
    Submitted TIMESTAMP NULL,    
    EndDate TIMESTAMPTZ NULL,
    NextStartDate TIMESTAMPTZ NULL,
    StartDate TIMESTAMPTZ NULL,    
    AttemptId UUID NOT NULL,
    JobTypeId UUID NOT NULL,
    JobRetryDelayToken UUID NULL,
    JobSlotWaitToken UUID NULL,    
    RetryAttempt INTEGER NOT NULL,
    LastProgressLimit BIGINT NULL,
    LastProgressSequenceNumber BIGINT NULL,
    LastProgressValue BIGINT NULL,
    CronExpression VARCHAR(255) NULL,
    Reason TEXT NULL,
    TimeZoneId VARCHAR(100) NULL,    
    Duration INTERVAL NULL,
    JobTimeout INTERVAL NULL,
    ServiceAddress VARCHAR(1000) NULL,    
    IncompleteAttempts JSONB NULL,    
    Job JSONB NULL,
    JobProperties JSONB NULL,
    JobState JSONB NULL,    
    PRIMARY KEY (CorrelationId)
);
```


### MessageData

MessageData is the MassTransit implementation of [Claim Checks](../../../3.patterns/8.claim-check.md), and relies on a temporary storage location to pass data without putting it on the bus.  While not ideal, special types of tables can be used to perform this task, and an implementation is included.

#### Registration

MessageData is part of the transport pipe, and can only be configured inside the transport configuration.  Replace `UsingInMemory` with your transport.  The included implementation expects this table structure, but allows specifying a different table (or schema.table).

```csharp
bus.UsingInMemory((ctx, cfg) =>
{
    cfg.UseMessageData(conf => conf.UsingPostgres(opt => opt
        .SetConnectionString("my connection string")
    ));

    cfg.ConfigureEndpoints(ctx);
});
```

#### Create table script
```sql
CREATE TABLE MessageData (
    Id UUID NOT NULL PRIMARY KEY,
    Created TIMESTAMP NOT NULL,
    Expires TIMESTAMP NOT NULL,
    Data BYTEA NOT NULL
);

CREATE INDEX IX_MessageData_Expires ON MessageData (Expires);
```

#### Cleaning Expired Entries

There is no default mechanism to remove expired entries, and this requires an additional step after deployment.  The Postgres MessageData repository implementation includes a method to call to clean up old entries, with the decision of when and how to call it left up to the end user.
```csharp
var repository = new PostgresMessageDataRepository(
    connectionString: "my connection string",
    tableName: "MessageData",
    isolationLevel: IsolationLevel.ReadCommitted,
    timeProvider: TimeProvider.System
);

services.AddMassTransit(bus =>
{
    bus.UsingInMemory((ctx, cfg) =>
    {        
        cfg.UseMessageData(repository);
        cfg.ConfigureEndpoints(ctx);
    });
});

// CleanupAsync is the method exposed to remove stale entries.
await repository.CleanupAsync(cancellationToken);
```