# MySql Setup Guide

## Saga Table Creation

### Basic Sagas

::callout{type="info"}
#summary
Using Optimistic Concurrency

#content
::div
Include a `byte[]` property on the model.  The default name is `RowVersion`, but the property can be specified in the configuration. Saga model:
```csharp
public class OrderSaga : SagaStateMachineInstance
{
    public Guid CorrelationId { get; set; }
    public byte[] RowVersion { get; set; }
    public int CurrentState { get; set; }
    public DateTime CreatedOn { get; set; }
    public DateTime UpdatedOn { get; set; }
}
```

Registration:
```csharp
services.AddMassTransit(bus => 
{
    bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
        .CustomRepository(conf => 
            conf.UsingMySql(opt => 
            {
                opt.SetConnectionString("my connection string");
                opt.SetOptimisticConcurrency();
                opt.SetTableName("Orders");
            }
        ));
});
```

Create table script:
```sql
CREATE TABLE Orders (
    CorrelationId BINARY(16) PRIMARY KEY,
    RowVersion TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),
    CurrentState INT NOT NULL,
    CreatedOn TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UpdatedOn TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB;
```
::
::

::callout{type="info"}
#summary
Using Pessimistic Concurrency

#content
::div
Saga model:
```csharp
public class OrderSaga : SagaStateMachineInstance
{
    public Guid CorrelationId { get; set; }
    public int CurrentState { get; set; }
    public DateTime CreatedOn { get; set; }
    public DateTime UpdatedOn { get; set; }
}
```

Registration:
```csharp
services.AddMassTransit(bus => 
{
    bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
        .CustomRepository(conf => 
            conf.UsingMySql(opt => 
            {
                opt.SetConnectionString("my connection string");
                opt.SetPessimisticConcurrency();
                opt.SetTableName("Orders");
            }
        ));
});
```

Create table script:
```sql
CREATE TABLE Orders (
    CorrelationId BINARY(16) PRIMARY KEY,
    CurrentState INT NOT NULL,
    CreatedOn TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UpdatedOn TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB;
```
::
::

### Customized Repository Example

#### Saga model:

Most sagas are more complex than 2 primitive properties and a timestamp.  Consider a more representative example below:
```csharp
public class OrderSaga : SagaStateMachineInstance
{
    public Guid CorrelationId { get; set; }
    public byte[] RowVersion { get; set; }
    public int CurrentState { get; set; }
    public string OrderNumber { get; set; }
    public Guid? CustomerId { get; set; }
    public decimal TotalAmount { get; set; }    
    public DateTime CreatedOn { get; set; }
    public DateTime UpdatedOn { get; set; }

    public ICollection<OrderItem> Items { get; set; } = [];
}

public record OrderItem(Guid ItemId, int Quantity, decimal ItemPrice);
```

#### Registration
Registration is different from before, because the provider doesn't know how to inject a completely custom service.  In this case, you must specify a factory.  The `serviceProvider` parameter is the DI container everything was registered against.  This example shows pulling the connection string from application options.
```csharp
bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
    .CustomRepository(conf => conf.SetContextFactory(
        async serviceProvider => 
        {
            var options = serviceProvider.GetRequiredService<IOptions<ApplicationOptions>>().Value;
            return new MySqlOrderSagaRepository(options.ConnectionString);
        }
    ));
```

#### Repository

The repository shows a more advanced usage of supported features.  The collection of `Items` is serialized to/from JSON, but because the table structure is different from the saga, the property must be renamed via `MapProperty`.  Pay close attention to the relationship of the model property "Items", as that controls the name of the parameter "@items".  The MapProperty method is used to rename the generated column name.  Without this mapping, the column name is assumed to be just `[Items]`, which means other expectations relying on that will fail.

```csharp
public class MySqlOrderSagaRepository : OptimisticMySqlDatabaseContext<OrderSaga>
{
    public MySqlOrderSagaRepository(string connectionString)
        // base constructor shows setting the table, id, and version column/property names
        : base(connectionString, "OrderSagas", "CorrelationId", "RowVersion", "RowVersion")
    {
        MapProperty(saga => saga.Items, "ItemsJson");
    }

    protected override Func<IDataReader, OrderSaga> CreateReaderAdapter() => MapFromReader;
    static OrderSaga MapFromReader(IDataReader reader)
    {
        var r = (MySqlDataReader)reader;
        return new OrderSaga
        {
            CorrelationId = r.GetGuid("CorrelationId"),
            CurrentState = r.GetInt32("CurrentState"),
            OrderNumber = r.GetString("OrderNumber"),
            CustomerId = r.GetGuidOrNull("CustomerId"),
            TotalAmount = r.GetDecimal("TotalAmount"),
            Items = r.FromJson<List<OrderItem>>("ItemsJson") ?? [],
            CreatedOn = r.GetDateTime("CreatedOn"),
            UpdatedOn = r.GetDateTime("UpdatedOn"),
            RowVersion = r.GetFieldValue<byte[]>("RowVersion")
        };
    }

    protected override Action<object?, MySqlParameterCollection> CreateWriterAdapter() => MapToParameters;
    static void MapToParameters(object? input, MySqlParameterCollection parameters)
    {
        if (input is OrderSaga saga)
        {
            parameters.Add("@correlationid", MySqlDbType.Guid).Value = saga.CorrelationId;
            parameters.Add("@currentstate", MySqlDbType.Int32).Value = saga.CurrentState;
            parameters.Add("@ordernumber", MySqlDbType.VarChar, 50).Value = saga.OrderNumber;
            parameters.Add("@customerid", MySqlDbType.Guid).Value = saga.CustomerId.OrDbNull();
            parameters.Add("@totalamount", MySqlDbType.Decimal).Value = saga.TotalAmount;
            parameters.Add("@items", MySqlDbType.Text).Value = saga.Items.ToJson().OrDbNull();
            parameters.Add("@rowversion", MySqlDbType.Timestamp).Value = saga.RowVersion;
            return;
        }

        // Fallback for query parameters
        AssignParameters(input, parameters);
    }
}
```

#### Create table script:
```sql
CREATE TABLE OrderSagas (
    CorrelationId BINARY(16) PRIMARY KEY,
    RowVersion TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),
    CurrentState INT NOT NULL,
    OrderNumber VARCHAR(50) NOT NULL,
    CustomerId BINARY(16) NOT NULL,
    TotalAmount DECIMAL(18,2) NOT NULL,
    ItemsJson TEXT,
    CreatedOn TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UpdatedOn TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB;
```


## Feature Implementations

### Job Consumers

JobConsumers in MassTransit are implemented via sagas, and the `MassTransit.Persistence.MySql` package provides a repository for them.  To use the included sagas, the following tables must be created exactly as shown -- at least, as far as names and datatypes are concerned.  Feel free to add additional indexes if needed.

#### Registration:
```csharp
services.AddMassTransit(bus => {
    bus.AddJobSagaStateMachines()
        .CustomRepository(conf => conf.UsingMySql(
            opt => opt.SetConnectionString("my connection string")
        ));
});
```

#### Create table scripts:
```sql
CREATE TABLE `JobAttempts` (
    `CorrelationId` BINARY(16) NOT NULL,
    `CurrentState` INT NOT NULL,
    `JobId` CHAR(36) NOT NULL,    
    `Started` DATETIME NULL,
    `Faulted` DATETIME NULL,
    `StatusCheckTokenId` CHAR(36) NULL,    
    `RetryAttempt` INT NOT NULL,
    `ServiceAddress` VARCHAR(1000) NULL,
    `InstanceAddress` VARCHAR(1000) NULL,
    PRIMARY KEY (`CorrelationId`)
) ENGINE=InnoDB;

CREATE TABLE `JobTypes` (
    `CorrelationId` BINARY(16) NOT NULL,
    `Name` VARCHAR(255) NOT NULL,
    `CurrentState` INT NOT NULL,
    `ActiveJobCount` INT NOT NULL,
    `ConcurrentJobLimit` INT NOT NULL,
    `OverrideJobLimit` INT NULL,
    `OverrideLimitExpiration` DATETIME NULL,
    `GlobalConcurrentJobLimit` INT NULL,
    `ActiveJobs` TEXT NULL,
    `Instances` TEXT NULL,
    `Properties` TEXT NULL,      
    PRIMARY KEY (`CorrelationId`)
) ENGINE=InnoDB;

CREATE TABLE `Jobs` (
    `CorrelationId` BINARY(16) NOT NULL,
    `CurrentState` INT NOT NULL,    
    `Completed` DATETIME NULL,
    `Faulted` DATETIME NULL,
    `Started` DATETIME NULL,
    `Submitted` DATETIME NULL,    
    `EndDate` DATETIME NULL,
    `NextStartDate` DATETIME NULL,
    `StartDate` DATETIME NULL,    
    `AttemptId` CHAR(36) NOT NULL,
    `JobTypeId` CHAR(36) NOT NULL,
    `JobRetryDelayToken` CHAR(36) NULL,
    `JobSlotWaitToken` CHAR(36) NULL,    
    `RetryAttempt` INT NOT NULL,
    `LastProgressLimit` BIGINT NULL,
    `LastProgressSequenceNumber` BIGINT NULL,
    `LastProgressValue` BIGINT NULL,
    `CronExpression` VARCHAR(255) NULL,
    `Reason` TEXT NULL,
    `TimeZoneId` VARCHAR(100) NULL,    
    `Duration` TIME NULL,
    `JobTimeout` TIME NULL,
    `ServiceAddress` VARCHAR(1000) NULL,    
    `IncompleteAttempts` TEXT NULL,    
    `Job` TEXT NULL,
    `JobProperties` TEXT NULL,
    `JobState` TEXT NULL,    
    PRIMARY KEY (`CorrelationId`)
) ENGINE=InnoDB;
```


### MessageData

MessageData is the MassTransit implementation of [Claim Checks](../../../3.patterns/8.claim-check.md), and relies on a temporary storage location to pass data without putting it on the bus.  While not ideal, special types of tables can be used to perform this task, and an implementation is included.

#### Registration

MessageData is part of the transport pipe, and can only be configured inside the transport configuration.  Replace `UsingInMemory` with your transport.  The included implementation expects this table structure, but allows specifying a different table (or schema.table).

```csharp
bus.UsingInMemory((ctx, cfg) =>
{
    cfg.UseMessageData(conf => conf.UsingMySql(opt => opt
        .SetConnectionString("my connection string")
    ));

    cfg.ConfigureEndpoints(ctx);
});
```

#### Create table script
```sql
CREATE TABLE `MessageData` (
    `Id` BINARY(16) NOT NULL PRIMARY KEY,
    `Created` DATETIME NOT NULL,
    `Expires` DATETIME NOT NULL,
    `Data` LONGBLOB NOT NULL
);

CREATE INDEX IX_MessageData_Expires ON MessageData (Expires);
```

#### Cleaning Expired Entries

There is no default mechanism to remove expired entries, and this requires an additional step after deployment.  The SqlServer MessageData repository implementation includes a method to call to clean up old entries, with the decision of when and how to call it left up to the end user.
```csharp
var repository = new MySqlMessageDataRepository(
    connectionString: "my connection string",
    tableName: "MessageData",
    isolationLevel: IsolationLevel.ReadCommitted,
    timeProvider: TimeProvider.System
);

services.AddMassTransit(bus =>
{
    bus.UsingInMemory((ctx, cfg) =>
    {        
        cfg.UseMessageData(repository);
        cfg.ConfigureEndpoints(ctx);
    });
});

// CleanupAsync is the method exposed to remove stale entries.
await repository.CleanupAsync(cancellationToken);
```