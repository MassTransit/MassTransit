# SQL Server Setup Guide

## Saga Table Creation

### Basic Sagas

::callout{type="info"}
#summary
Using Optimistic Concurrency

#content
::div
Include a `byte[]` property on the model.  The default name is `RowVersion`, but the property can be specified in the configuration. Saga model:
```csharp
public class OrderSaga : SagaStateMachineInstance
{
    public Guid CorrelationId { get; set; }
    public byte[] RowVersion { get; set; }
    public int CurrentState { get; set; }
    public DateTime CreatedOn { get; set; }
    public DateTime UpdatedOn { get; set; }
}
```

Registration:
```csharp
services.AddMassTransit(bus => 
{
    bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
        .CustomRepository(conf => 
            conf.UsingSqlServer(opt => 
            {
                opt.SetConnectionString("my connection string");
                opt.SetOptimisticConcurrency();
                opt.SetTableName("Orders");
            }
        ));
});
```

Create table script:
```sql
CREATE TABLE [dbo].[Orders] (
    [CorrelationId] UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,
    [RowVersion] ROWVERSION NOT NULL,
    [CurrentState] INT NOT NULL,
    [CreatedOn] DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    [UpdatedOn] DATETIME2 NOT NULL DEFAULT GETUTCDATE()    
);
```
::
::

::callout{type="info"}
#summary
Using Pessimistic Concurrency

#content
::div
Saga model:
```csharp
public class OrderSaga : SagaStateMachineInstance
{
    public Guid CorrelationId { get; set; }
    public int CurrentState { get; set; }
    public DateTime CreatedOn { get; set; }
    public DateTime UpdatedOn { get; set; }
}
```

Registration:
```csharp
services.AddMassTransit(bus => 
{
    bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
        .CustomRepository(conf => 
            conf.UsingSqlServer(opt => 
            {
                opt.SetConnectionString("my connection string");
                opt.SetPessimisticConcurrency();
                opt.SetTableName("Orders");
            }
        ));
});
```

Create table script:
```sql
CREATE TABLE [dbo].[Orders] (
    [CorrelationId] UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,
    [CurrentState] INT NOT NULL,
    [CreatedOn] DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    [UpdatedOn] DATETIME2 NOT NULL DEFAULT GETUTCDATE()
);
```
::
::

### Customized Repository Example

#### Saga model:

Most sagas are more complex than 2 primitive properties and a timestamp.  Consider a more representative example below:
```csharp
public class OrderSaga : SagaStateMachineInstance
{
    public Guid CorrelationId { get; set; }
    public byte[] RowVersion { get; set; }
    public int CurrentState { get; set; }
    public string OrderNumber { get; set; }
    public Guid? CustomerId { get; set; }
    public decimal TotalAmount { get; set; }    
    public DateTime CreatedOn { get; set; }
    public DateTime UpdatedOn { get; set; }

    public ICollection<OrderItem> Items { get; set; } = [];
}

public record OrderItem(Guid ItemId, int Quantity, decimal ItemPrice);
```

#### Registration
Registration is different from before, because the provider doesn't know how to inject a completely custom service.  In this case, you must specify a factory.  The `serviceProvider` parameter is the DI container everything was registered against.  This example shows pulling the connection string from application options.
```csharp
bus.AddSagaStateMachine<OrderStateMachine, OrderSaga>()
    .CustomRepository(conf => conf.SetContextFactory(
        async serviceProvider => 
        {
            var options = serviceProvider.GetRequiredService<IOptions<ApplicationOptions>>().Value;
            return new SqlServerOrderSagaRepository(options.ConnectionString);
        }
    ));
```

#### Repository

The repository shows a more advanced usage of supported features.  The collection of `Items` is serialized to/from JSON, but because the table structure is different from the saga, the property must be renamed via `MapProperty`.  Pay close attention to the relationship of the model property "Items", as that controls the name of the parameter "@items".  The MapProperty method is used to rename the generated column name.  Without this mapping, the column name is assumed to be just `[Items]`, which means other expectations relying on that will fail.

```csharp
public class SqlServerOrderSagaRepository : OptimisticSqlServerDatabaseContext<OrderSaga>
{
    public SqlServerOrderSagaRepository(string connectionString)
        // base constructor shows setting the table, id, and version column/property names
        : base(connectionString, "OrderSagas", "CorrelationId", "RowVersion", "RowVersion")
    {
        MapProperty(saga => saga.Items, "ItemsJson");
    }

    protected override Func<IDataReader, OrderSaga> CreateReaderAdapter() => MapFromReader;
    static OrderSaga MapFromReader(IDataReader reader)
    {
        var r = (SqlDataReader)reader;
        return new OrderSaga
        {
            CorrelationId = r.GetGuid("CorrelationId"),
            CurrentState = r.GetInt32("CurrentState"),
            OrderNumber = r.GetString("OrderNumber"),
            CustomerId = r.GetGuidOrNull("CustomerId"),
            TotalAmount = r.GetDecimal("TotalAmount"),
            Items = r.FromJson<List<OrderItem>>("ItemsJson") ?? [],
            CreatedOn = r.GetDateTime("CreatedOn"),
            UpdatedOn = r.GetDateTime("UpdatedOn"),
            RowVersion = r.GetFieldValue<byte[]>("RowVersion")
        };
    }

    protected override Action<object?, SqlParameterCollection> CreateWriterAdapter() => MapToParameters;
    static void MapToParameters(object? input, SqlParameterCollection parameters)
    {
        if (input is OrderSaga saga)
        {
            parameters.Add("@correlationid", SqlDbType.UniqueIdentifier).Value = saga.CorrelationId;
            parameters.Add("@currentstate", SqlDbType.Int).Value = saga.CurrentState;
            parameters.Add("@ordernumber", SqlDbType.NVarChar, 50).Value = saga.OrderNumber;
            parameters.Add("@customerid", SqlDbType.UniqueIdentifier).Value = saga.CustomerId.OrDbNull();
            parameters.Add("@totalamount", SqlDbType.Decimal).Value = saga.TotalAmount;
            parameters.Add("@items", SqlDbType.NVarChar).Value = saga.Items.ToJson().OrDbNull();
            parameters.Add("@rowversion", SqlDbType.Timestamp).Value = saga.RowVersion;
            return;
        }

        // Fallback for query parameters
        AssignParameters(input, parameters);
    }
}
```

#### Create table script:
```sql
CREATE TABLE [dbo].[OrderSagas] (
    [CorrelationId] UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,
    [RowVersion] ROWVERSION NOT NULL,
    [CurrentState] INT NOT NULL,
    [OrderNumber] NVARCHAR(50) NOT NULL,
    [CustomerId] UNIQUEIDENTIFIER NULL,
    [TotalAmount] DECIMAL(18,2) NOT NULL,    
    [CreatedOn] DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    [UpdatedOn] DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    [ItemsJson] NVARCHAR(MAX) NULL
);
```


## Feature Implementations

### Job Consumers

JobConsumers in MassTransit are implemented via sagas, and the `MassTransit.Persistence.SqlServer` package provides a repository for them.  To use the included sagas, the following tables must be created exactly as shown -- at least, as far as names and datatypes are concerned.  Feel free to add additional indexes if needed.

#### Registration:
```csharp
services.AddMassTransit(bus => {
    bus.AddJobSagaStateMachines()
        .CustomRepository(conf => conf.UsingSqlServer(
            opt => opt.SetConnectionString("my connection string")
        ));
});
```

#### Create table scripts:
```sql
CREATE TABLE [dbo].[Jobs] (
    [CorrelationId] UNIQUEIDENTIFIER NOT NULL,
    [CurrentState] INT NOT NULL,    
    [Completed] DATETIME NULL,
    [Faulted] DATETIME NULL,
    [Started] DATETIME NULL,
    [Submitted] DATETIME NULL,    
    [EndDate] DATETIMEOFFSET NULL,
    [NextStartDate] DATETIMEOFFSET NULL,
    [StartDate] DATETIMEOFFSET NULL,    
    [AttemptId] UNIQUEIDENTIFIER NOT NULL,
    [JobTypeId] UNIQUEIDENTIFIER NOT NULL,
    [JobRetryDelayToken] UNIQUEIDENTIFIER NULL,
    [JobSlotWaitToken] UNIQUEIDENTIFIER NULL,    
    [RetryAttempt] INT NOT NULL,
    [LastProgressLimit] BIGINT NULL,
    [LastProgressSequenceNumber] BIGINT NULL,
    [LastProgressValue] BIGINT NULL,
    [CronExpression] NVARCHAR(255) NULL,
    [Reason] NVARCHAR(MAX) NULL,
    [TimeZoneId] NVARCHAR(100) NULL,    
    [Duration] TIME NULL,
    [JobTimeout] TIME NULL,
    [ServiceAddress] NVARCHAR(1000) NULL,    
    [IncompleteAttempts] VARCHAR(MAX) NULL,    
    [Job] VARCHAR(MAX) NULL,
    [JobProperties] VARCHAR(MAX) NULL,
    [JobState] VARCHAR(MAX) NULL,    
    PRIMARY KEY CLUSTERED ([CorrelationId] ASC)
);

CREATE TABLE [dbo].[JobAttempts] (
    [CorrelationId] UNIQUEIDENTIFIER NOT NULL,
    [CurrentState] INT NOT NULL,
    [JobId] UNIQUEIDENTIFIER NOT NULL,    
    [Started] DATETIME NULL,
    [Faulted] DATETIME NULL,
    [StatusCheckTokenId] UNIQUEIDENTIFIER NULL,    
    [RetryAttempt] INT NOT NULL,
    [ServiceAddress] NVARCHAR(1000) NULL,
    [InstanceAddress] NVARCHAR(1000) NULL,                
    PRIMARY KEY CLUSTERED ([CorrelationId] ASC)
);

CREATE TABLE [dbo].[JobTypes] (
    [CorrelationId] UNIQUEIDENTIFIER NOT NULL,
    [Name] NVARCHAR(255) NOT NULL,
    [CurrentState] INT NOT NULL,
    [ActiveJobCount] INT NOT NULL,
    [ConcurrentJobLimit] INT NOT NULL,
    [OverrideJobLimit] INT NULL,
    [OverrideLimitExpiration] DATETIME NULL,
    [GlobalConcurrentJobLimit] INT NULL,
    [ActiveJobs] VARCHAR(MAX) NULL,
    [Instances] VARCHAR(MAX) NULL,
    [Properties] VARCHAR(MAX) NULL,      
    PRIMARY KEY CLUSTERED ([CorrelationId] ASC)
);
```


### MessageData

MessageData is the MassTransit implementation of [Claim Checks](../../../3.patterns/8.claim-check.md), and relies on a temporary storage location to pass data without putting it on the bus.  While not ideal, special types of tables can be used to perform this task, and an implementation is included.

#### Registration

MessageData is part of the transport pipe, and can only be configured inside the transport configuration.  Replace `UsingInMemory` with your transport.  The included implementation expects this table structure, but allows specifying a different table (or schema.table).

```csharp
bus.UsingInMemory((ctx, cfg) =>
{
    cfg.UseMessageData(conf => conf.UsingSqlServer(opt => opt
        .SetConnectionString("my connection string")
        // .SetTableName("bulk.MessageData")
    ));

    cfg.ConfigureEndpoints(ctx);
});
```

#### Create table script
```sql
CREATE TABLE [MessageData] (
    [Id] UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,
    [Created] DATETIMEOFFSET NOT NULL,
    [Expires] DATETIMEOFFSET NOT NULL,
    [Data] VARBINARY(MAX) NOT NULL
);

CREATE INDEX IX_MessageData_Expires ON [dbo].[MessageData] ([Expires]);
```

#### Cleaning Expired Entries

::callout{type="info"}
#summary
Cleanup via SqlServerMessageDataRepository.

#content
::div

There is no default mechanism to remove expired entries, and this requires an additional step after deployment.  The SqlServer MessageData repository implementation includes a method to call to clean up old entries, with the decision of when and how to call it left up to the end user.
```csharp
var repository = new SqlServerMessageDataRepository(
    connectionString: "my connection string",
    tableName: "dbo.MessageData",
    isolationLevel: IsolationLevel.ReadCommitted,
    timeProvider: TimeProvider.System
);

services.AddMassTransit(bus =>
{
    bus.UsingInMemory((ctx, cfg) =>
    {        
        cfg.UseMessageData(repository);
        cfg.ConfigureEndpoints(ctx);
    });
});

// CleanupAsync is the method exposed to remove stale entries.
await repository.CleanupAsync(cancellationToken);
```
::
::

::callout{type="info"}
#summary
Cleanup via SQL Agent job.

#content
::div
```sql
-- Cleanup expired message data
CREATE PROCEDURE [dbo].[CleanupMessageData]
    @BatchSize INT = 1000
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @DeletedCount INT = 0;
    DECLARE @TotalDeleted INT = 0;
    
    WHILE 1 = 1
    BEGIN
        DELETE TOP (@BatchSize) FROM [dbo].[MessageData]
        WHERE ExpiresAt IS NOT NULL 
        AND ExpiresAt < GETUTCDATE();
        
        SET @DeletedCount = @@ROWCOUNT;
        SET @TotalDeleted = @TotalDeleted + @DeletedCount;
        
        IF @DeletedCount < @BatchSize
            BREAK;
            
        WAITFOR DELAY '00:00:01';
    END
    
    SELECT @TotalDeleted as DeletedRecords;
END
GO

-- Create SQL Server Agent job for automated cleanup
USE [msdb]
GO

EXEC dbo.sp_add_job
    @job_name = N'MassTransit MessageData Cleanup',
    @enabled = 1,
    @description = N'Cleanup expired MessageData records';

EXEC dbo.sp_add_jobstep
    @job_name = N'MassTransit MessageData Cleanup',
    @step_name = N'Cleanup Expired Records',
    @command = N'EXEC [dbo].[CleanupMessageData] @BatchSize = 5000',
    @database_name = N'YourDatabase';

EXEC dbo.sp_add_schedule
    @schedule_name = N'Hourly Cleanup',
    @freq_type = 4,
    @freq_interval = 1,
    @freq_subday_type = 8,
    @freq_subday_interval = 1;

EXEC dbo.sp_attach_schedule
    @job_name = N'MassTransit MessageData Cleanup',
    @schedule_name = N'Hourly Cleanup';

EXEC dbo.sp_add_jobserver
    @job_name = N'MassTransit MessageData Cleanup';
```
::
::
