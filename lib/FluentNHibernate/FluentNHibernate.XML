<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FluentNHibernate</name>
    </assembly>
    <members>
        <member name="T:FluentNHibernate.Automapping.Alterations.AutoMappingOverrideAlteration">
            <summary>
            Built-in alteration for altering an AutoPersistenceModel with instance of IAutoMappingOverride&lt;T&gt;.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Automapping.Alterations.IAutoMappingAlteration">
            <summary>
            Provides a mechanism for altering an AutoPersistenceModel prior to
            the generation of mappings.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Automapping.Alterations.IAutoMappingAlteration.Alter(FluentNHibernate.Automapping.AutoPersistenceModel)">
            <summary>
            Alter the model
            </summary>
            <param name="model">AutoPersistenceModel instance to alter</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.Alterations.AutoMappingOverrideAlteration.#ctor(System.Reflection.Assembly)">
            <summary>
            Constructor for AutoMappingOverrideAlteration.
            </summary>
            <param name="overrideAssembly">Assembly to load overrides from.</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.Alterations.AutoMappingOverrideAlteration.Alter(FluentNHibernate.Automapping.AutoPersistenceModel)">
            <summary>
            Alter the model
            </summary>
            <remarks>
            Finds all types in the assembly (passed in the constructor) that implement IAutoMappingOverride&lt;T&gt;, then
            creates an AutoMapping&lt;T&gt; and applies the override to it.
            </remarks>
            <param name="model">AutoPersistenceModel instance to alter</param>
        </member>
        <member name="T:FluentNHibernate.Automapping.Alterations.IAutoMappingOverride`1">
            <summary>
            A mapping override for an auto mapped entity.
            </summary>
            <typeparam name="T">Entity who's auto-mapping you're overriding</typeparam>
        </member>
        <member name="M:FluentNHibernate.Automapping.Alterations.IAutoMappingOverride`1.Override(FluentNHibernate.Automapping.AutoMapping{`0})">
            <summary>
            Alter the automapping for this type
            </summary>
            <param name="mapping">Automapping</param>
        </member>
        <member name="T:FluentNHibernate.AssemblyTypeSource">
            <summary>
            Facade over an assembly for retrieving type instances.
            </summary>
        </member>
        <member name="T:FluentNHibernate.ITypeSource">
            <summary>
            A source for Type instances, acts as a facade for an Assembly or as an alternative Type provider.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.OnMemberMapped(FluentNHibernate.Member)">
            <summary>
            Called when a member is mapped by a builder method.
            </summary>
            <param name="member">Member being mapped.</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.Map(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Create a property mapping.
            </summary>
            <param name="memberExpression">Property to map</param>
            <example>
            Map(x => x.Name);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.Map(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
            <summary>
            Create a property mapping.
            </summary>
            <param name="memberExpression">Property to map</param>
            <param name="columnName">Property column name</param>
            <example>
            Map(x => x.Name, "person_name");
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.References``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Create a reference to another entity. In database terms, this is a many-to-one
            relationship.
            </summary>
            <typeparam name="TOther">Other entity</typeparam>
            <param name="memberExpression">Property on the current entity</param>
            <example>
            References(x => x.Company);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.References``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String)">
            <summary>
            Create a reference to another entity. In database terms, this is a many-to-one
            relationship.
            </summary>
            <typeparam name="TOther">Other entity</typeparam>
            <param name="memberExpression">Property on the current entity</param>
            <param name="columnName">Column name</param>
            <example>
            References(x => x.Company, "company_id");
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.References``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Create a reference to another entity. In database terms, this is a many-to-one
            relationship.
            </summary>
            <typeparam name="TOther">Other entity</typeparam>
            <param name="memberExpression">Property on the current entity</param>
            <example>
            References(x => x.Company, "company_id");
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.References``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
            <summary>
            Create a reference to another entity. In database terms, this is a many-to-one
            relationship.
            </summary>
            <typeparam name="TOther">Other entity</typeparam>
            <param name="memberExpression">Property on the current entity</param>
            <param name="columnName">Column name</param>
            <example>
            References(x => x.Company, "company_id");
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.ReferencesAny``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Create a reference to any other entity. This is an "any" polymorphic relationship.
            </summary>
            <typeparam name="TOther">Other entity to reference</typeparam>
            <param name="memberExpression">Property</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasOne``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Create a reference to another entity based exclusively on the primary-key values.
            This is sometimes called a one-to-one relationship, in database terms. Generally
            you should use <see cref="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.References``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})"/>
            whenever possible.
            </summary>
            <typeparam name="TOther">Other entity</typeparam>
            <param name="memberExpression">Property</param>
            <example>
            HasOne(x =&gt; x.ExtendedInfo);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasOne``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Create a reference to another entity based exclusively on the primary-key values.
            This is sometimes called a one-to-one relationship, in database terms. Generally
            you should use <see cref="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.References``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})"/>
            whenever possible.
            </summary>
            <typeparam name="TOther">Other entity</typeparam>
            <param name="memberExpression">Property</param>
            <example>
            HasOne(x =&gt; x.ExtendedInfo);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.DynamicComponent(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.IDictionary}},System.Action{FluentNHibernate.Mapping.DynamicComponentPart{System.Collections.IDictionary}})">
            <summary>
            Create a dynamic component mapping. This is a dictionary that represents
            a limited number of columns in the database.
            </summary>
            <param name="memberExpression">Property containing component</param>
            <param name="dynamicComponentAction">Component setup action</param>
            <example>
            DynamicComponent(x => x.Data, comp =>
            {
              comp.Map(x => (int)x["age"]);
            });
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.Component``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Creates a component reference. This is a place-holder for a component that is defined externally with a
            <see cref="T:FluentNHibernate.Mapping.ComponentMap`1"/>; the mapping defined in said <see cref="T:FluentNHibernate.Mapping.ComponentMap`1"/> will be merged
            with any options you specify from this call.
            </summary>
            <typeparam name="TComponent">Component type</typeparam>
            <param name="member">Property exposing the component</param>
            <returns>Component reference builder</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.Component``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Action{FluentNHibernate.Mapping.ComponentPart{``0}})">
            <summary>
            Maps a component
            </summary>
            <typeparam name="TComponent">Type of component</typeparam>
            <param name="expression">Component property</param>
            <param name="action">Component mapping</param>
            <example>
            Component(x => x.Address, comp =>
            {
              comp.Map(x => x.Street);
              comp.Map(x => x.City);
            });
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.Component``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{FluentNHibernate.Mapping.ComponentPart{``0}})">
            <summary>
            Maps a component
            </summary>
            <typeparam name="TComponent">Type of component</typeparam>
            <param name="expression">Component property</param>
            <param name="action">Component mapping</param>
            <example>
            Component(x => x.Address, comp =>
            {
              comp.Map(x => x.Street);
              comp.Map(x => x.City);
            });
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.Component(FluentNHibernate.Mapping.Providers.IComponentMappingProvider)">
            <summary>
            Allows the user to add a custom component mapping to the class mapping.        
            Note: not a fluent method.
            </summary>
            <remarks>
            In some cases, our users need a way to add an instance of their own implementation of IComponentMappingProvider.
            For an example of where this might be necessary, see: http://codebetter.com/blogs/jeremy.miller/archive/2010/02/16/our-extension-properties-story.aspx
            </remarks>        
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
            <summary>
            Maps a collection of entities as a one-to-many
            </summary>
            <typeparam name="TChild">Child entity type</typeparam>
            <param name="memberExpression">Collection property</param>
            <example>
            HasMany(x => x.Locations);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Maps a collection of entities as a one-to-many
            </summary>
            <typeparam name="TChild">Child entity type</typeparam>
            <param name="memberExpression">Collection property</param>
            <example>
            HasMany(x => x.Locations);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
            <summary>
            Maps a collection of entities as a many-to-many
            </summary>
            <typeparam name="TChild">Child entity type</typeparam>
            <param name="memberExpression">Collection property</param>
            <example>
            HasManyToMany(x => x.Locations);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Maps a collection of entities as a many-to-many
            </summary>
            <typeparam name="TChild">Child entity type</typeparam>
            <param name="memberExpression">Collection property</param>
            <example>
            HasManyToMany(x => x.Locations);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.SqlInsert(System.String)">
            <summary>
            Specify an insert stored procedure
            </summary>
            <param name="innerText">Stored procedure call</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.SqlUpdate(System.String)">
            <summary>
            Specify an update stored procedure
            </summary>
            <param name="innerText">Stored procedure call</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.SqlDelete(System.String)">
            <summary>
            Specify an delete stored procedure
            </summary>
            <param name="innerText">Stored procedure call</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.SqlDeleteAll(System.String)">
            <summary>
            Specify an delete all stored procedure
            </summary>
            <param name="innerText">Stored procedure call</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.JoinedSubClassPart`1.EntityName(System.String)">
            <summary>
            Specifies an entity-name.
            </summary>
            <remarks>See http://nhforge.org/blogs/nhibernate/archive/2008/10/21/entity-name-in-action-a-strongly-typed-entity.aspx</remarks>
        </member>
        <member name="P:FluentNHibernate.Mapping.JoinedSubClassPart`1.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.JoinPart`1">
            <summary>
            Maps to the Join element in NH 2.0
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.JoinPart`1.KeyColumn(System.String)">
            <summary>
            Specify the key column name
            </summary>
            <param name="column">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.JoinPart`1.KeyColumn(System.String[])">
            <summary>
            Specify the key column name
            </summary>
            <param name="columnNames">Column names</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.JoinPart`1.Schema(System.String)">
            <summary>
            Specify the schema
            </summary>
            <param name="schema">Schema name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.JoinPart`1.Inverse">
            <summary>
            Inverse the ownership of this relationship
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.JoinPart`1.Optional">
            <summary>
            Specify this relationship as optional
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.JoinPart`1.Catalog(System.String)">
            <summary>
            Specify the catalog
            </summary>
            <param name="catalog">Catalog</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.JoinPart`1.Subselect(System.String)">
            <summary>
            Specify a subselect for fetching this join
            </summary>
            <param name="subselect">Query</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.JoinPart`1.Table(System.String)">
            <summary>
            Specify the table name
            </summary>
            <param name="tableName">Table name</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.JoinPart`1.Fetch">
            <summary>
            Specify the fetching strategy
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.JoinPart`1.Not">
            <summary>
            Invert the next boolean operation
            </summary>
        </member>
        <member name="T:FluentNHibernate.Automapping.AutoMap">
            <summary>
            Starting point for automapping your entities.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.AssemblyOf``1">
            <summary>
            Automatically map classes in the assembly that contains <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Class in the assembly you want to map</typeparam>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.AssemblyOf``1(FluentNHibernate.Automapping.IAutomappingConfiguration)">
            <summary>
            Automatically map classes in the assembly that contains <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Class in the assembly you want to map</typeparam>
            <param name="cfg">Automapping configuration</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.Assembly(System.Reflection.Assembly)">
            <summary>
            Automatically map the classes in <paramref name="assembly"/>.
            </summary>
            <param name="assembly">Assembly containing the classes to map</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.Assembly(System.Reflection.Assembly,FluentNHibernate.Automapping.IAutomappingConfiguration)">
            <summary>
            Automatically map the classes in <paramref name="assembly"/>.
            </summary>
            <param name="assembly">Assembly containing the classes to map</param>
            <param name="cfg">Automapping configuration</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.Assemblies(System.Reflection.Assembly[])">
            <summary>
            Automatically map the classes in each assembly supplied.
            </summary>
            <param name="assemblies">Assemblies containing classes to map</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.Assemblies(FluentNHibernate.Automapping.IAutomappingConfiguration,System.Reflection.Assembly[])">
            <summary>
            Automatically map the classes in each assembly supplied.
            </summary>
            <param name="cfg">Automapping configuration</param>
            <param name="assemblies">Assemblies containing classes to map</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.Assemblies(FluentNHibernate.Automapping.IAutomappingConfiguration,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Automatically map the classes in each assembly supplied.
            </summary>
            <param name="cfg">Automapping configuration</param>
            <param name="assemblies">Assemblies containing classes to map</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.Source(FluentNHibernate.ITypeSource)">
            <summary>
            Automatically map the classes exposed through the supplied <see cref="T:FluentNHibernate.ITypeSource"/>.
            </summary>
            <param name="source"><see cref="T:FluentNHibernate.ITypeSource"/> containing classes to map</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.Source(FluentNHibernate.ITypeSource,FluentNHibernate.Automapping.IAutomappingConfiguration)">
            <summary>
            Automatically map the classes exposed through the supplied <see cref="T:FluentNHibernate.ITypeSource"/>.
            </summary>
            <param name="source"><see cref="T:FluentNHibernate.ITypeSource"/> containing classes to map</param>
            <param name="cfg">Automapping configuration</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.Source(FluentNHibernate.ITypeSource,System.Func{System.Type,System.Boolean})">
            <summary>
            Automatically map the classes exposed through the supplied <see cref="T:FluentNHibernate.ITypeSource"/>.
            </summary>
            <param name="source"><see cref="T:FluentNHibernate.ITypeSource"/> containing classes to map</param>
            <param name="where">Criteria for selecting a subset of the types in the assembly for mapping</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.Assembly(System.Reflection.Assembly,System.Func{System.Type,System.Boolean})">
            <summary>
            Automatically map the classes in <paramref name="assembly"/>.
            </summary>
            <param name="assembly">Assembly containing the classes to map</param>
            <param name="where">Criteria for selecting a subset of the types in the assembly for mapping</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMap.AssemblyOf``1(System.Func{System.Type,System.Boolean})">
            <summary>
            Automatically map classes in the assembly that contains <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Class in the assembly you want to map</typeparam>
            <param name="where">Criteria for selecting a subset of the types in the assembly for mapping</param>
        </member>
        <member name="T:FluentNHibernate.Mapping.ClassMap`1">
            <summary>
            Defines a mapping for an entity. Derive from this class to create a mapping,
            and use the constructor to control how your entity is persisted.
            </summary>
            <example>
            public class PersonMap : ClassMap&lt;Person&gt;
            {
              public PersonMap()
              {
                Id(x => x.PersonId);
                Map(x => x.Name);
                Map(x => x.Age);
              }
            }
            </example>
            <typeparam name="T">Entity type to map</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Id(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Specify the identifier for this entity.
            </summary>
            <param name="memberExpression">Identity property</param>
            <example>
            Id(x => x.PersonId);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Id(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
            <summary>
            Specify the identifier for this entity.
            </summary>
            <param name="memberExpression">Identity property</param>
            <param name="column">Column name</param>
            <example>
            Id(x => x.PersonId, "id");
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Id">
            <summary>
            Create an Id that doesn't have a corresponding property in
            the domain object, or a column in the database. This is mainly
            for use with read-only access and/or views. Defaults to an int
            identity with an "increment" generator.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Id``1">
            <summary>
            Create an Id that doesn't have a corresponding property in
            the domain object, or a column in the database. This is mainly
            for use with read-only access and/or views.
            </summary>
            <typeparam name="TId">Type of the id</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Id``1(System.String)">
            <summary>
            Create an Id that doesn't have a corresponding property in
            the domain object.
            </summary>
            <typeparam name="TId">Type of the id</typeparam>
            <param name="column">Name and column name of the id</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.NaturalId">
            <summary>
            Create a natural identity. This is a secondary identifier
            that has "business meaning" moreso than the primary key.
            </summary>
            <example>
            NaturalId()
              .Property(x => x.Name);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.CompositeId">
            <summary>
            Create a composite identity. This is an identity composed of multiple
            columns.
            Note: Prefer using a surrogate key over a composite key whenever possible.
            </summary>
            <example>
            CompositeId()
              .KeyProperty(x => x.FirstName)
              .KeyProperty(x => x.LastName);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.CompositeId``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Create a composite identity represented by an identity class. This is an
            identity composed of multiple columns.
            Note: Prefer using a surrogate key over a composite key whenever possible.
            </summary>
            <param name="memberExpression">Composite id property</param>
            <example>
            CompositeId(x => x.Id)
              .KeyProperty(x => x.FirstName)
              .KeyProperty(x => x.LastName);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Version(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Specifies that this class should be versioned/timestamped using the
            given property.
            </summary>
            <param name="memberExpression">Version/timestamp property</param>
            <example>
            Version(x => x.Timestamp);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.DiscriminateSubClassesOnColumn``1(System.String,``0)">
            <summary>
            Specify that this entity should use a discriminator with it's subclasses.
            This is a mapping strategy called table-per-inheritance-hierarchy; where all
            subclasses are stored in the same table, differenciated by a discriminator
            column value.
            </summary>
            <typeparam name="TDiscriminator">Type of the discriminator column</typeparam>
            <param name="columnName">Discriminator column name</param>
            <param name="baseClassDiscriminator">Default discriminator value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.DiscriminateSubClassesOnColumn``1(System.String)">
            <summary>
            Specify that this entity should use a discriminator with it's subclasses.
            This is a mapping strategy called table-per-inheritance-hierarchy; where all
            subclasses are stored in the same table, differenciated by a discriminator
            column value.
            </summary>
            <typeparam name="TDiscriminator">Type of the discriminator column</typeparam>
            <param name="columnName">Discriminator column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.DiscriminateSubClassesOnColumn(System.String)">
            <summary>
            Specify that this entity should use a discriminator with it's subclasses.
            This is a mapping strategy called table-per-inheritance-hierarchy; where all
            subclasses are stored in the same table, differenciated by a discriminator
            column value.
            </summary>
            <param name="columnName">Discriminator column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.UseUnionSubclassForInheritanceMapping">
            <summary>
            Specifies that any subclasses of this entity should be treated as union-subclass
            mappings. Don't use this in combination with a discriminator, as they are mutually
            exclusive.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Schema(System.String)">
            <summary>
            Sets the schema for this class.
            </summary>
            <param name="schema">Schema name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Table(System.String)">
            <summary>
            Sets the table for the class.
            </summary>
            <param name="tableName">Table name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.LazyLoad">
            <summary>
            Sets this entity to be lazy-loaded (overrides the default lazy load configuration).
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Join(System.String,System.Action{FluentNHibernate.Mapping.JoinPart{`0}})">
            <summary>
            Links this entity to another table, to create a composite entity from two or
            more tables.
            </summary>
            <param name="tableName">Joined table name</param>
            <param name="action">Joined table mapping</param>
            <example>
            Join("another_table", join =>
            {
              join.Map(x => x.Name);
              join.Map(x => x.Age);
            });
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.ImportType``1">
            <summary>
            Imports an existing type for use in the mapping.
            </summary>
            <typeparam name="TImport">Type to import.</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.ReadOnly">
            <summary>
            Set the mutability of this class, sets the mutable attribute.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.DynamicUpdate">
            <summary>
            Sets this entity to be dynamic update
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.DynamicInsert">
            <summary>
            Sets this entity to be dynamic insert
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.BatchSize(System.Int32)">
            <summary>
            Sets the query batch size for this entity.
            </summary>
            <param name="size">Batch size</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.CheckConstraint(System.String)">
            <summary>
            Specifies a check constraint
            </summary>
            <param name="constraint">Constraint name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Persister``1">
            <summary>
            Specifies a persister to be used with this entity
            </summary>
            <typeparam name="TPersister">Persister type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Persister(System.Type)">
            <summary>
            Specifies a persister to be used with this entity
            </summary>
            <param name="type">Persister type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Persister(System.String)">
            <summary>
            Specifies a persister to be used with this entity
            </summary>
            <param name="type">Persister type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Proxy``1">
            <summary>
            Specifies a proxy class for this entity.
            </summary>
            <typeparam name="TProxy">Proxy type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Proxy(System.Type)">
            <summary>
            Specifies a proxy class for this entity.
            </summary>
            <param name="type">Proxy type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Proxy(System.String)">
            <summary>
            Specifies a proxy class for this entity.
            </summary>
            <param name="type">Proxy type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.SelectBeforeUpdate">
            <summary>
            Specifies that a select should be performed before updating
            this entity
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Where(System.String)">
            <summary>
            Defines a SQL 'where' clause used when retrieving objects of this type.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Subselect(System.String)">
            <summary>
            Sets the SQL statement used in subselect fetching.
            </summary>
            <param name="subselectSql">Subselect SQL Query</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.EntityName(System.String)">
            <summary>
            Specifies an entity-name.
            </summary>
            <remarks>See http://nhforge.org/blogs/nhibernate/archive/2008/10/21/entity-name-in-action-a-strongly-typed-entity.aspx</remarks>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.ApplyFilter(System.String,System.String)">
            <summary>
            Applies a filter to this entity given its name.
            </summary>
            <param name="name">The filter's name</param>
            <param name="condition">The condition to apply</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.ApplyFilter(System.String)">
            <summary>
            Applies a filter to this entity given its name.
            </summary>
            <param name="name">The filter's name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.ApplyFilter``1(System.String)">
            <summary>
            Applies a named filter to this entity.
            </summary>
            <param name="condition">The condition to apply</param>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.ApplyFilter``1">
            <summary>
            Applies a named filter to this entity.
            </summary>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ClassMap`1.Tuplizer(FluentNHibernate.MappingModel.TuplizerMode,System.Type)">
            <summary>
            Configures the tuplizer for this entity. The tuplizer defines how to transform
            a Property-Value to its persistent representation, and viceversa a Column-Value
            to its in-memory representation, and the EntityMode defines which tuplizer is in use.
            </summary>
            <param name="mode">Tuplizer entity-mode</param>
            <param name="tuplizerType">Tuplizer type</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.ClassMap`1.Cache">
            <summary>
            Specify the caching for this entity.
            </summary>
            <example>
            Cache.ReadWrite();
            </example>
        </member>
        <member name="P:FluentNHibernate.Mapping.ClassMap`1.HibernateMapping">
            <summary>
            Specify settings for the container/hibernate-mapping for this class.
            Note: Avoid using this, if possible prefer using conventions.
            </summary>
            <example>
            HibernateMapping.Schema("dto");
            </example>
        </member>
        <member name="P:FluentNHibernate.Mapping.ClassMap`1.Not">
            <summary>
            Inverts the next boolean option
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ClassMap`1.OptimisticLock">
            <summary>
            Sets the optimistic locking strategy
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ClassMap`1.Polymorphism">
            <summary>
            Sets the polymorphism behaviour
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ClassMap`1.SchemaAction">
            <summary>
            Sets the schema action behaviour
            </summary>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMapper.FlagAsMapped(System.Type)">
            <summary>
            Flags a type as already mapped, stop it from being auto-mapped.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.Add(System.Type)">
            <summary>
            Creates an instance of an IAutoMappingAlteration from a type instance, then adds it to the alterations collection.
            </summary>
            <param name="type">Type of an IAutoMappingAlteration</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.Add``1">
            <summary>
            Creates an instance of an IAutoMappingAlteration from a generic type parameter, then adds it to the alterations collection.
            </summary>
            <typeparam name="T">Type of an IAutoMappingAlteration</typeparam>
            <returns>Container</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.Add(FluentNHibernate.Automapping.Alterations.IAutoMappingAlteration)">
            <summary>
            Adds an alteration
            </summary>
            <param name="alteration">Alteration to add</param>
            <returns>Container</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.AddFromAssembly(System.Reflection.Assembly)">
            <summary>
            Adds all alterations from an assembly
            </summary>
            <param name="assembly">Assembly to search</param>
            <returns>Container</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.AddFromAssemblyOf``1">
            <summary>
            Adds all alterations from an assembly that contains T.
            </summary>
            <typeparam name="T">Type who's assembly to search</typeparam>
            <returns>Container</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.Apply(FluentNHibernate.Automapping.AutoPersistenceModel)">
            <summary>
            Apply alterations to an AutoPersisteceModel
            </summary>
            <param name="model">AutoPersistenceModel instance to apply alterations to</param>
        </member>
        <member name="F:FluentNHibernate.Automapping.AutoMappingExpressions.FindMembers">
            <summary>
            Determines whether a member is to be automapped. 
            </summary>
        </member>
        <member name="F:FluentNHibernate.Automapping.AutoMappingExpressions.FindIdentity">
            <summary>
            Determines whether a member is the identity of an entity.
            </summary>
        </member>
        <member name="F:FluentNHibernate.Automapping.AutoMappingExpressions.AbstractClassIsLayerSupertype">
            <summary>
            Determines whether an abstract class is a layer supertype or part of a mapped inheritance hierarchy.
            </summary>
        </member>
        <member name="F:FluentNHibernate.Automapping.AutoMappingExpressions.SimpleTypeCollectionValueColumn">
            <summary>
            Specifies the value column used in a table of simple types. 
            </summary>
        </member>
        <member name="T:FluentNHibernate.Automapping.IAutomappingConfiguration">
            <summary>
            Implement this interface to control how the automapper behaves.
            Typically you're better off deriving from the <see cref="T:FluentNHibernate.Automapping.DefaultAutomappingConfiguration"/>
            class, which is pre-configured with the default settings; you can then
            just override specific methods that you'd like to alter.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.ShouldMap(System.Type)">
            <summary>
            Determines whether a type should be auto-mapped.
            Override to restrict which types are mapped in your domain.
            </summary>
            <remarks>
            You normally want to override this method and restrict via something known, like
            Namespace.
            </remarks>
            <example>
            return type.Namespace.EndsWith("Domain");
            </example>
            <param name="type">Type to map</param>
            <returns>Should map type</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.ShouldMap(FluentNHibernate.Member)">
            <summary>
            Determines whether a member of a type should be auto-mapped.
            Override to restrict which members are considered in automapping.
            </summary>
            <remarks>
            You normally want to override this method to restrict which members will be
            used for mapping. This method will be called for every property, field, and method
            on your types.
            </remarks>
            <example>
            // all writable public properties:
            return member.IsProperty &amp;&amp; member.IsPublic &amp;&amp; member.CanWrite;
            </example>
            <param name="member">Member to map</param>
            <returns>Should map member</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.IsId(FluentNHibernate.Member)">
            <summary>
            Determines whether a member is the id of an entity.
            </summary>
            <remarks>
            This method is called for each member that ShouldMap(Type) returns true for.
            </remarks>
            <param name="member">Member</param>
            <returns>Member is id</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.GetAccessStrategyForReadOnlyProperty(FluentNHibernate.Member)">
            <summary>
            Gets the access strategy to be used for a read-only property. This method is
            called for every setterless property and private-setter autoproperty in your
            domain that has been accepted through <see cref="M:FluentNHibernate.Automapping.IAutomappingConfiguration.ShouldMap(FluentNHibernate.Member)"/>.
            </summary>
            <param name="member">Member to get access strategy for</param>
            <returns>Access strategy</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.GetParentSideForManyToMany(System.Type,System.Type)">
            <summary>
            Controls which side of a many-to-many relationship is considered the "parent".
            </summary>
            <param name="left">Left side of the relationship</param>
            <param name="right">Right side of the relationship</param>
            <returns>left or right</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.IsConcreteBaseType(System.Type)">
            <summary>
            Determines whether a type is a concrete, or instantiatable, base class. This
            affects how the inheritance mappings are built, specifically that any types
            this method returns true for will not be mapped as a subclass.
            </summary>
            <param name="type">Type</param>
            <returns>Base type is concrete?</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.IsComponent(System.Type)">
            <summary>
            Specifies that a particular type should be mapped as a component rather than
            an entity.
            </summary>
            <param name="type">Type</param>
            <returns>Type is a component?</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.GetComponentColumnPrefix(FluentNHibernate.Member)">
            <summary>
            Gets the column prefix for a component.
            </summary>
            <param name="member">Member defining the component</param>
            <returns>Component column prefix</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.IsDiscriminated(System.Type)">
            <summary>
            Specifies whether a particular type is mapped with a discriminator.
            This method will be called for every type that has already been
            approved by <see cref="M:FluentNHibernate.Automapping.IAutomappingConfiguration.ShouldMap(System.Type)"/>.
            </summary>
            <param name="type">Type to check</param>
            <returns>Whether the type is to be discriminated</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.GetDiscriminatorColumn(System.Type)">
            <summary>
            Gets the column name of the discriminator.
            </summary>
            <param name="type">Type</param>
            <returns>Discriminator column name</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.AbstractClassIsLayerSupertype(System.Type)">
            <summary>
            Specifies whether an abstract type is considered a Layer Supertype
            (http://martinfowler.com/eaaCatalog/layerSupertype.html). Defaults to
            true for all abstract classes. Override this method if you have an
            abstract class that you want mapping as a regular entity.
            </summary>
            <param name="type">Abstract class type</param>
            <returns>Whether the type is a Layer Supertype</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.SimpleTypeCollectionValueColumn(FluentNHibernate.Member)">
            <summary>
            Gets the value column for a collection of simple types.
            </summary>
            <remarks>
            This is the name of the &lt;element&gt; column.
            </remarks>
            <param name="member">Collection property</param>
            <returns>Value column name</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.IsVersion(FluentNHibernate.Member)">
            <summary>
            Specifies whether the current member is a version property
            </summary>
            <param name="member">Candidate member</param>
            <returns>Is member a version</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.IAutomappingConfiguration.GetMappingSteps(FluentNHibernate.Automapping.AutoMapper,FluentNHibernate.Conventions.IConventionFinder)">
            <summary>
            Gets the steps that are executed to map a type.
            </summary>
            <returns>Collection of mapping steps</returns>
        </member>
        <member name="P:FluentNHibernate.PersistenceModel.ValidationEnabled">
            <summary>
            Gets or sets whether validation of mappings is performed. 
            </summary>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.Alterations(System.Action{FluentNHibernate.Automapping.AutoMappingAlterationCollection})">
            <summary>
            Specify alterations to be used with this AutoPersisteceModel
            </summary>
            <param name="alterationDelegate">Lambda to declare alterations</param>
            <returns>AutoPersistenceModel</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.UseOverridesFromAssemblyOf``1">
            <summary>
            Use auto mapping overrides defined in the assembly of T.
            </summary>
            <typeparam name="T">Type to get assembly from</typeparam>
            <returns>AutoPersistenceModel</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.UseOverridesFromAssembly(System.Reflection.Assembly)">
            <summary>
            Use auto mapping overrides defined in the assembly of T.
            </summary>
            <param name="assembly">Assembly to scan</param>
            <returns>AutoPersistenceModel</returns>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.Setup(System.Action{FluentNHibernate.Automapping.AutoMappingExpressions})">
            <summary>
            Alter some of the configuration options that control how the automapper works.
            Depreciated in favour of supplying your own IAutomappingConfiguration instance to AutoMap: <see cref="M:FluentNHibernate.Automapping.AutoMap.AssemblyOf``1(FluentNHibernate.Automapping.IAutomappingConfiguration)"/>.
            Cannot be used in combination with a user-defined configuration.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.Where(System.Func{System.Type,System.Boolean})">
            <summary>
            Supply a criteria for which types will be mapped.
            Cannot be used in combination with a user-defined configuration.
            </summary>
            <param name="where">Where clause</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.AddEntityAssembly(System.Reflection.Assembly)">
            <summary>
            Adds all entities from a specific assembly.
            </summary>
            <param name="assembly">Assembly to load from</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.AddTypeSource(FluentNHibernate.ITypeSource)">
            <summary>
            Adds all entities from the <see cref="T:FluentNHibernate.ITypeSource"/>.
            </summary>
            <param name="source"><see cref="T:FluentNHibernate.ITypeSource"/> to load from</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.Override``1(System.Action{FluentNHibernate.Automapping.AutoMapping{``0}})">
            <summary>
            Override the mapping of a specific entity.
            </summary>
            <remarks>This may affect subclasses, depending on the alterations you do.</remarks>
            <typeparam name="T">Entity who's mapping to override</typeparam>
            <param name="populateMap">Lambda performing alterations</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.Override(System.Type)">
            <summary>
            Adds an IAutoMappingOverride reflectively
            </summary>
            <param name="overrideType">Override type, expected to be an IAutoMappingOverride</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.OverrideAll(System.Action{FluentNHibernate.Automapping.IPropertyIgnorer})">
            <summary>
            Override all mappings.
            </summary>
            <remarks>Currently only supports ignoring properties on all entities.</remarks>
            <param name="alteration">Lambda performing alterations</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.IgnoreBase``1">
            <summary>
            Ignore a base type. This removes it from any mapped inheritance hierarchies, good for non-abstract layer
            supertypes.
            </summary>
            <typeparam name="T">Type to ignore</typeparam>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.IgnoreBase(System.Type)">
            <summary>
            Ignore a base type. This removes it from any mapped inheritance hierarchies, good for non-abstract layer
            supertypes.
            </summary>
            <param name="baseType">Type to ignore</param>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.IncludeBase``1">
            <summary>
            Explicitly includes a type to be used as part of a mapped inheritance hierarchy.
            </summary>
            <remarks>
            Abstract classes are probably what you'll be using this method with. Fluent NHibernate considers abstract
            classes to be layer supertypes, so doesn't automatically map them as part of an inheritance hierarchy. You
            can use this method to override that behavior for a specific type; otherwise you should consider using the
            <see cref="M:FluentNHibernate.Automapping.IAutomappingConfiguration.AbstractClassIsLayerSupertype(System.Type)"/> setting.
            </remarks>
            <typeparam name="T">Type to include</typeparam>
        </member>
        <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.IncludeBase(System.Type)">
            <summary>
            Explicitly includes a type to be used as part of a mapped inheritance hierarchy.
            </summary>
            <remarks>
            Abstract classes are probably what you'll be using this method with. Fluent NHibernate considers abstract
            classes to be layer supertypes, so doesn't automatically map them as part of an inheritance hierarchy. You
            can use this method to override that behavior for a specific type; otherwise you should consider using the
            <see cref="F:FluentNHibernate.Automapping.AutoMappingExpressions.AbstractClassIsLayerSupertype"/> setting.
            </remarks>
            <param name="baseType">Type to include</param>
        </member>
        <member name="P:FluentNHibernate.Automapping.AutoPersistenceModel.Conventions">
            <summary>
            Alter convention discovery
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubClassPart`1.LazyLoad">
            <summary>
            Sets whether this subclass is lazy loaded
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubClassPart`1.EntityName(System.String)">
            <summary>
            Specifies an entity-name.
            </summary>
            <remarks>See http://nhforge.org/blogs/nhibernate/archive/2008/10/21/entity-name-in-action-a-strongly-typed-entity.aspx</remarks>
        </member>
        <member name="P:FluentNHibernate.Mapping.SubClassPart`1.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.Dialect(System.String)">
            <summary>
            Sets the database dialect. This shouldn't be necessary
            if you've used one of the provided database configurations.
            </summary>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.Dialect``1">
            <summary>
            Sets the database dialect. This shouldn't be necessary
            if you've used one of the provided database configurations.
            </summary>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.DefaultSchema(System.String)">
            <summary>
            Sets the default database schema
            </summary>
            <param name="schema">Default schema name</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.UseOuterJoin">
            <summary>
            Enables the outer-join option.
            </summary>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.MaxFetchDepth(System.Int32)">
            <summary>
            Sets the max fetch depth.
            </summary>
            <param name="maxFetchDepth">Max fetch depth</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.UseReflectionOptimizer">
            <summary>
            Enables the reflection optimizer.
            </summary>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.QuerySubstitutions(System.String)">
            <summary>
            Sets any query stubstitutions that NHibernate should
            perform.
            </summary>
            <param name="substitutions">Substitutions</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.ShowSql">
            <summary>
            Enables the show SQL option.
            </summary>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.FormatSql">
            <summary>
            Enables the format SQL option.
            </summary>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.Provider(System.String)">
            <summary>
            Sets the database provider. This shouldn't be necessary
            if you're using one of the provided database configurations.
            </summary>
            <param name="provider">Provider type</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.Provider``1">
            <summary>
            Sets the database provider. This shouldn't be necessary
            if you're using one of the provided database configurations.
            </summary>
            <typeparam name="T">Provider type</typeparam>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.Driver(System.String)">
            <summary>
            Specify the database driver. This isn't necessary
            if you're using one of the provided database configurations.
            </summary>
            <param name="driverClass">Driver type</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.Driver``1">
            <summary>
            Specify the database driver. This isn't necessary
            if you're using one of the provided database configurations.
            </summary>
            <typeparam name="T">Driver type</typeparam>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.ConnectionString(System.Action{`1})">
            <summary>
            Configure the connection string
            </summary>
            <example>
                ConnectionString(x =>
                {
                  x.Server("db_server");
                  x.Database("Products");
                });
            </example>
            <param name="connectionStringExpression">Closure for building the connection string</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.ConnectionString(System.String)">
            <summary>
            Set the connection string.
            </summary>
            <param name="value">Connection string to use</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.Raw(System.String,System.String)">
            <summary>
            Sets a raw property on the NHibernate configuration. Use this method
            if there isn't a specific option available in the API.
            </summary>
            <param name="key">Setting key</param>
            <param name="value">Setting value</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.AdoNetBatchSize(System.Int32)">
            <summary>
            Sets the adonet.batch_size property.
            </summary>
            <param name="size">Batch size</param>
            <returns>Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.IsolationLevel(System.Data.IsolationLevel)">
            <summary>
            Sets the connection isolation level. NHibernate setting: connection.isolation
            </summary>
            <param name="connectionIsolation">Isolation level</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.IsolationLevel(System.String)">
            <summary>
            Sets the connection isolation level. NHibernate setting: connection.isolation
            </summary>
            <param name="connectionIsolation">Isolation level</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="P:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.DoNot">
            <summary>
            Negates the next boolean option.
            </summary>
        </member>
        <member name="T:FluentNHibernate.CombinedAssemblyTypeSource">
            <summary>
            Provides types for mapping from multiple assemblies
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IConvention`2">
            <summary>
            Basic convention interface. Don't use directly.
            </summary>
            <typeparam name="TInspector">Inspector instance for use in retrieving values and setting expectations</typeparam>
            <typeparam name="TInstance">Apply instance</typeparam>
        </member>
        <member name="T:FluentNHibernate.Conventions.IConvention">
            <summary>
            Ignore - this is used for generic restrictions only
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConvention`2.Apply(`1)">
            <summary>
            Apply changes to the target
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionAcceptance`1.Accept(FluentNHibernate.Conventions.AcceptanceCriteria.IAcceptanceCriteria{`0})">
            <summary>
            Whether this convention will be applied to the target.
            </summary>
            <param name="criteria">Instace that could be supplied</param>
            <returns>Apply on this target?</returns>
        </member>
        <member name="P:FluentNHibernate.Conventions.Inspections.IInspector.StringIdentifierForModel">
            <summary>
            Represents a string identifier for the model instance, used in conventions for a lazy
            shortcut.
            
            e.g. for a ColumnMapping the StringIdentifierForModel would be the Name attribute,
            this allows the user to find any columns with the matching name.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Diagnostics.DiagnosticsConfiguration">
            <summary>
            Diagnostic logging configuration
            </summary>
        </member>
        <member name="M:FluentNHibernate.Diagnostics.DiagnosticsConfiguration.Enable(System.Boolean)">
            <summary>
            Conditionally enable logging
            </summary>
            <param name="enable">Enable logging</param>
        </member>
        <member name="M:FluentNHibernate.Diagnostics.DiagnosticsConfiguration.Enable">
            <summary>
            Enable logging
            </summary>
        </member>
        <member name="M:FluentNHibernate.Diagnostics.DiagnosticsConfiguration.Disable">
            <summary>
            Disable logging
            </summary>
        </member>
        <member name="M:FluentNHibernate.Diagnostics.DiagnosticsConfiguration.RegisterListener(FluentNHibernate.Diagnostics.IDiagnosticListener)">
            <summary>
            Register a logging listener
            </summary>
            <param name="listener">Listener</param>
        </member>
        <member name="M:FluentNHibernate.Diagnostics.DiagnosticsConfiguration.OutputToConsole">
            <summary>
            Register a default Console.Write listener
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Diagnostics.DiagnosticsConfiguration.OutputToConsole(FluentNHibernate.Diagnostics.IDiagnosticResultsFormatter)">
            <summary>
            Register a Console.Write listener with a custom result formatter
            </summary>
            <param name="formatter">Result formatter</param>
        </member>
        <member name="M:FluentNHibernate.Diagnostics.DiagnosticsConfiguration.OutputToFile(System.String)">
            <summary>
            Register a default file output listener
            </summary>
            <param name="path">Output path</param>
        </member>
        <member name="M:FluentNHibernate.Diagnostics.DiagnosticsConfiguration.OutputToFile(FluentNHibernate.Diagnostics.IDiagnosticResultsFormatter,System.String)">
            <summary>
            Register a file output listener with a custom result formatter
            </summary>
            <param name="formatter">Result formatter</param>
            <param name="path">Output path</param>
        </member>
        <member name="T:FluentNHibernate.Conventions.AttributeCollectionConvention`1">
            <summary>
            Base class for attribute based conventions. Create a subclass of this to supply your own
            attribute based conventions.
            </summary>
            <typeparam name="T">Attribute identifier</typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.AttributeCollectionConvention`1.Apply(`0,FluentNHibernate.Conventions.Instances.ICollectionInstance)">
            <summary>
            Apply changes to a property with an attribute matching T.
            </summary>
            <param name="attribute">Instance of attribute found on property.</param>
            <param name="instance">Property with attribute</param>
        </member>
        <member name="T:FluentNHibernate.Conventions.IIdConvention">
            <summary>
            Convention for identities, implement this interface to apply changes to
            identity mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IVersionConvention">
            <summary>
            Version convention, implement this interface to apply changes to vesion mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IPropertyConvention">
            <summary>
            Property convention, implement this interface to apply changes to
            property mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IComponentConvention">
            <summary>
            Convention for a component mapping. Implement this interface to
            apply changes to components.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IDynamicComponentConvention">
            <summary>
            Convention for dynamic components. Implement this member to apply changes
            to dynamic components.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IReferenceConvention">
            <summary>
            Reference convention, implement this interface to apply changes to Reference/many-to-one
            relationships.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IHasOneConvention">
            <summary>
            HasOne convention, used for applying changes to one-to-one relationships.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IHibernateMappingConvention">
            <summary>
            Convention for the hibernate-mapping container for a class, this can be used to
            set some class-wide settings such as lazy-load and access strategies.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IJoinedSubclassConvention">
            <summary>
            Joined subclass convention, implement this interface to alter joined-subclass mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IJoinConvention">
            <summary>
            Join convention, implement this interface to alter join mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IClassConvention">
            <summary>
            Convention for a single class mapping. Implement this interface to apply
            changes to class mappings.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.ISubclassConvention">
            <summary>
            Subclass convention, implement this interface to alter subclass mappings.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.ProxyConvention.Apply(FluentNHibernate.Conventions.Instances.IClassInstance)">
            <summary>
            Apply changes to the target
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.ProxyConvention.Apply(FluentNHibernate.Conventions.Instances.ISubclassInstance)">
            <summary>
            Apply changes to the target
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.ProxyConvention.Apply(FluentNHibernate.Conventions.Instances.IManyToOneInstance)">
            <summary>
            Apply changes to the target
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.ProxyConvention.Apply(FluentNHibernate.Conventions.Instances.ICollectionInstance)">
            <summary>
            Apply changes to the target
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.ProxyConvention.Apply(FluentNHibernate.Conventions.Instances.IOneToOneInstance)">
            <summary>
            Apply changes to the target
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.Inspections.CollectionInspector.IsSet(FluentNHibernate.Member)">
            <summary>
            Represents a string identifier for the model instance, used in conventions for a lazy
            shortcut.
            
            e.g. for a ColumnMapping the StringIdentifierForModel would be the Name attribute,
            this allows the user to find any columns with the matching name.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.Inspections.ColumnBasedInspector.GetValueFromColumns``1(System.Func{FluentNHibernate.MappingModel.ColumnMapping,System.Object})">
            <summary>
            Gets the requested value off the first column, as all columns are (currently) created equal
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:FluentNHibernate.Conventions.Inspections.IManyToManyInspector.Where">
            <summary>
            Applies to the joining table for this many-to-many. 
            </summary>
        </member>
        <member name="P:FluentNHibernate.Conventions.Inspections.IManyToManyInspector.OrderBy">
            <summary>
            Applies to the joining table for this many-to-many. 
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Increment">
            <summary>
            generates identifiers of any integral type that are unique only when no other 
            process is inserting data into the same table. Do not use in a cluster.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Increment(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            generates identifiers of any integral type that are unique only when no other 
            process is inserting data into the same table. Do not use in a cluster.
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Identity">
            <summary>
            supports identity columns in DB2, MySQL, MS SQL Server and Sybase.
            The identifier returned by the database is converted to the property type using 
            Convert.ChangeType. Any integral property type is thus supported.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Identity(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            supports identity columns in DB2, MySQL, MS SQL Server and Sybase.
            The identifier returned by the database is converted to the property type using 
            Convert.ChangeType. Any integral property type is thus supported.
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Sequence(System.String)">
            <summary>
            uses a sequence in DB2, PostgreSQL, Oracle or a generator in Firebird.
            The identifier returned by the database is converted to the property type 
            using Convert.ChangeType. Any integral property type is thus supported.
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Sequence(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses a sequence in DB2, PostgreSQL, Oracle or a generator in Firebird.
            The identifier returned by the database is converted to the property type 
            using Convert.ChangeType. Any integral property type is thus supported.
            </summary>
            <param name="sequenceName"></param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.HiLo(System.String,System.String,System.String,System.String)">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type,
            given a table and column (by default hibernate_unique_key and next_hi respectively)
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="table">The table.</param>
            <param name="column">The column.</param>
            <param name="maxLo">The max lo.</param>
            <param name="where">The where.</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.HiLo(System.String,System.String,System.String)">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="table"></param>
            <param name="column"></param>
            <param name="maxLo"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.HiLo(System.String,System.String,System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="table"></param>
            <param name="column"></param>
            <param name="maxLo"></param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.HiLo(System.String)">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="maxLo"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.HiLo(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="maxLo"></param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.SeqHiLo(System.String,System.String)">
            <summary>
            uses an Oracle-style sequence (where supported)
            </summary>
            <param name="sequence"></param>
            <param name="maxLo"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.SeqHiLo(System.String,System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses an Oracle-style sequence (where supported)
            </summary>
            <param name="sequence"></param>
            <param name="maxLo"></param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.UuidHex(System.String)">
            <summary>
            uses System.Guid and its ToString(string format) method to generate identifiers
            of type string. The length of the string returned depends on the configured format. 
            </summary>
            <param name="format">http://msdn.microsoft.com/en-us/library/97af8hh4.aspx</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.UuidHex(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses System.Guid and its ToString(string format) method to generate identifiers
            of type string. The length of the string returned depends on the configured format. 
            </summary>
            <param name="format">http://msdn.microsoft.com/en-us/library/97af8hh4.aspx</param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.UuidString">
            <summary>
            uses a new System.Guid to create a byte[] that is converted to a string.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.UuidString(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses a new System.Guid to create a byte[] that is converted to a string.  
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Guid">
            <summary>
            uses a new System.Guid as the identifier. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Guid(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses a new System.Guid as the identifier. 
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.GuidComb">
            <summary>
            Recommended for Guid identifiers!
            uses the algorithm to generate a new System.Guid described by Jimmy Nilsson 
            in the article http://www.informit.com/articles/article.asp?p=25862. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.GuidComb(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            Recommended for Guid identifiers!
            uses the algorithm to generate a new System.Guid described by Jimmy Nilsson 
            in the article http://www.informit.com/articles/article.asp?p=25862. 
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.GuidNative">
            <summary>
            Generator that uses the RDBMS native function to generate a GUID.
            The behavior is similar to the sequence generator. When a new
            object is saved NH run two queries: the first to retrieve the GUID
            value and the second to insert the entity using the Guid retrieved
            from the RDBMS. Your entity Id must be System.Guid and the SQLType
            will depend on the dialect (RAW(16) in Oracle, UniqueIdentifier in
            MsSQL for example).
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.GuidNative(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            Generator that uses the RDBMS native function to generate a GUID.
            The behavior is similar to the sequence generator. When a new
            object is saved NH run two queries: the first to retrieve the GUID
            value and the second to insert the entity using the Guid retrieved
            from the RDBMS. Your entity Id must be System.Guid and the SQLType
            will depend on the dialect (RAW(16) in Oracle, UniqueIdentifier in
            MsSQL for example).
            </summary>
            <example>
                GuidNative(x =>
                {
                  x.AddParam("key", "value");
                });
            </example>
            <param name="paramValues">Parameter builder closure</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Select">
            <summary>
            A deviation of the trigger-identity. This generator works
            together with the <see cref="M:FluentNHibernate.Mapping.ClassMap`1.NaturalId"/> feature.
            The difference with trigger-identity is that the POID value
            is retrieved by a SELECT using the natural-id fields as filter.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Select(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            A deviation of the trigger-identity. This generator works
            together with the <see cref="M:FluentNHibernate.Mapping.ClassMap`1.NaturalId"/> feature.
            The difference with trigger-identity is that the POID value
            is retrieved by a SELECT using the natural-id fields as filter.
            </summary>
            <example>
                Select(x =&gt;
                {
                  x.AddParam("key", "value");
                });
            </example>
            <param name="paramValues">Parameter builder closure</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.SequenceIdentity">
            <summary>
            Based on sequence but works like an identity. The POID
            value is retrieved with an INSERT query. Your entity Id must
            be an integral type.
            "hibernate_sequence" is the default name for the sequence, unless
            another is provided.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.SequenceIdentity(System.String)">
            <summary>
            Based on sequence but works like an identity. The POID
            value is retrieved with an INSERT query. Your entity Id must
            be an integral type.
            "hibernate_sequence" is the default name for the sequence, unless
            another is provided.
            </summary>
            <param name="sequence">Custom sequence name</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.SequenceIdentity(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            Based on sequence but works like an identity. The POID
            value is retrieved with an INSERT query. Your entity Id must
            be an integral type.
            "hibernate_sequence" is the default name for the sequence, unless
            another is provided.
            </summary>
            <param name="paramValues">Parameter builder closure</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.SequenceIdentity(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            Based on sequence but works like an identity. The POID
            value is retrieved with an INSERT query. Your entity Id must
            be an integral type.
            "hibernate_sequence" is the default name for the sequence, unless
            another is provided.
            </summary>
            <param name="sequence">Custom sequence name</param>
            <param name="paramValues">Parameter builder closure</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.TriggerIdentity">
            <summary>
            trigger-identity is a NHibernate specific feature where the POID
            is generated by the RDBMS with an INSERT query through a
            BEFORE INSERT trigger. In this case you can use any supported type,
            including a custom type, with the limitation of a single column usage.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.TriggerIdentity(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            trigger-identity is a NHibernate specific feature where the POID
            is generated by the RDBMS with an INSERT query through a
            BEFORE INSERT trigger. In this case you can use any supported type,
            including a custom type, with the limitation of a single column usage.
            </summary>
            <param name="paramValues">Parameter builder closure</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Assigned">
            <summary>
            lets the application to assign an identifier to the object before Save() is called. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Assigned(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            lets the application to assign an identifier to the object before Save() is called. 
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Native">
            <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Native(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Native(System.String)">
            <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Native(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Foreign(System.String)">
            <summary>
            uses the identifier of another associated object. Usually used in conjunction with a one-to-one primary key association. 
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Foreign(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses the identifier of another associated object. Usually used in conjunction with a one-to-one primary key association. 
            </summary>
            <param name="property"></param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IManyToManyInstance.Where(System.String)">
            <summary>
            Applies to the joining table for this many-to-many. 
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IManyToManyInstance.OrderBy(System.String)">
            <summary>
            Applies to the joining table for this many-to-many. 
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IManyToManyCollectionInstance.ApplyFilter(System.String,System.String)">
            <summary>
            Applies a filter to this relationship given its name.
            </summary>
            <param name="name">The filter's name</param>
            <param name="condition">The condition to apply</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IManyToManyCollectionInstance.ApplyFilter(System.String)">
            <summary>
            Applies a filter to this relationship given its name.
            </summary>
            <param name="name">The filter's name</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IManyToManyCollectionInstance.ApplyFilter``1(System.String)">
            <summary>
            Applies a named filter to this relationship.
            </summary>
            <param name="condition">The condition to apply</param>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IManyToManyCollectionInstance.ApplyFilter``1">
            <summary>
            Applies a named filter to this relationship.
            </summary>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IClassInstance.ApplyFilter(System.String,System.String)">
            <summary>
            Applies a filter to this entity given its name.
            </summary>
            <param name="name">The filter's name</param>
            <param name="condition">The condition to apply</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IClassInstance.ApplyFilter(System.String)">
            <summary>
            Applies a filter to this entity given its name.
            </summary>
            <param name="name">The filter's name</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IClassInstance.ApplyFilter``1(System.String)">
            <summary>
            Applies a named filter to this entity.
            </summary>
            <param name="condition">The condition to apply</param>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IClassInstance.ApplyFilter``1">
            <summary>
            Applies a named filter to this entity.
            </summary>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IManyToOneInstance.LazyLoad">
            <summary>
            Specify the lazy behaviour of this relationship.
            </summary>
            <remarks>
            Defaults to Proxy lazy-loading. Use the <see cref="P:FluentNHibernate.Conventions.Instances.IManyToOneInstance.Not"/> modifier to disable
            lazy-loading, and use the <see cref="M:FluentNHibernate.Conventions.Instances.IManyToOneInstance.LazyLoad(FluentNHibernate.Mapping.Laziness)"/>
            overload to specify alternative lazy strategies.
            </remarks>
            <example>
            LazyLoad();
            Not.LazyLoad();
            </example>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IManyToOneInstance.LazyLoad(FluentNHibernate.Mapping.Laziness)">
            <summary>
            Specify the lazy behaviour of this relationship. Cannot be used
            with the <see cref="P:FluentNHibernate.Conventions.Instances.IManyToOneInstance.Not"/> modifier.
            </summary>
            <param name="laziness">Laziness strategy</param>
            <example>
            LazyLoad(Laziness.NoProxy);
            </example>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IndexInstance.Column(System.String)">
            <summary>
            Adds a column to the index if columns have not yet been specified
            </summary>
            <param name="columnName">The column name to add</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IndexManyToManyInstance.Column(System.String)">
            <summary>
            Adds a column to the index if columns have not yet been specified
            </summary>
            <param name="columnName">The column name to add</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IOneToOneInstance.LazyLoad">
            <summary>
            Specify the lazy behaviour of this relationship.
            </summary>
            <remarks>
            Defaults to Proxy lazy-loading. Use the <see cref="P:FluentNHibernate.Conventions.Instances.IOneToOneInstance.Not"/> modifier to disable
            lazy-loading, and use the <see cref="M:FluentNHibernate.Conventions.Instances.IOneToOneInstance.LazyLoad(FluentNHibernate.Mapping.Laziness)"/>
            overload to specify alternative lazy strategies.
            </remarks>
            <example>
            LazyLoad();
            Not.LazyLoad();
            </example>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IOneToOneInstance.LazyLoad(FluentNHibernate.Mapping.Laziness)">
            <summary>
            Specify the lazy behaviour of this relationship. Cannot be used
            with the <see cref="P:FluentNHibernate.Conventions.Instances.IOneToOneInstance.Not"/> modifier.
            </summary>
            <param name="laziness">Laziness strategy</param>
            <example>
            LazyLoad(Laziness.NoProxy);
            </example>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IOneToManyCollectionInstance.ApplyFilter(System.String,System.String)">
            <summary>
            Applies a filter to this relationship given its name.
            </summary>
            <param name="name">The filter's name</param>
            <param name="condition">The condition to apply</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IOneToManyCollectionInstance.ApplyFilter(System.String)">
            <summary>
            Applies a filter to this relationship given its name.
            </summary>
            <param name="name">The filter's name</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IOneToManyCollectionInstance.ApplyFilter``1(System.String)">
            <summary>
            Applies a named filter to this relationship.
            </summary>
            <param name="condition">The condition to apply</param>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.IOneToManyCollectionInstance.ApplyFilter``1">
            <summary>
            Applies a named filter to this relationship.
            </summary>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.ISubclassInstance.Extends``1">
            <summary>
            (optional) Specifies the entity from which this subclass descends/extends.
            </summary>
            <typeparam name="T">Type of the entity to extend</typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.ISubclassInstance.Extends(System.Type)">
            <summary>
            (optional) Specifies the entity from which this subclass descends/extends.
            </summary>
            <param name="type">Type of the entity to extend</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.EnumerableExtensionsForConventions.Contains``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Checks whether a collection contains an inspector identified by the string value.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="expected"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.EnumerableExtensionsForConventions.Contains``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Checks whether a collection contains an inspector identified by a predicate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="prediate"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.SubclassInstance.Extends``1">
            <summary>
            (optional) Specifies the entity from which this subclass descends/extends.
            </summary>
            <typeparam name="T">Type of the entity to extend</typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.Instances.SubclassInstance.Extends(System.Type)">
            <summary>
            (optional) Specifies the entity from which this subclass descends/extends.
            </summary>
            <param name="type">Type of the entity to extend</param>
        </member>
        <member name="T:FluentNHibernate.Conventions.ManyToManyTableNameConvention">
            <summary>
            Base convention for specifying your own many-to-many table naming style. Implement
            the abstract members defined by this class to control how your join tables are named
            for uni and bi-directional many-to-many's.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.ManyToManyTableNameConvention.GetBiDirectionalTableName(FluentNHibernate.Conventions.Inspections.IManyToManyCollectionInspector,FluentNHibernate.Conventions.Inspections.IManyToManyCollectionInspector)">
            <summary>
            Gets the name used for bi-directional many-to-many tables. Implement this member to control how
            your join table is named for bi-directional relationships.
            </summary>
            <remarks>
            This method will be called once per bi-directional relationship; once one side of the relationship
            has been saved, then the other side will assume that name aswell.
            </remarks>
            <param name="collection">Main collection</param>
            <param name="otherSide">Inverse collection</param>
            <returns>Many-to-many table name</returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.ManyToManyTableNameConvention.GetUniDirectionalTableName(FluentNHibernate.Conventions.Inspections.IManyToManyCollectionInspector)">
            <summary>
            Gets the name used for uni-directional many-to-many tables. Implement this member to control how
            your join table is named for uni-directional relationships.
            </summary>
            <param name="collection">Main collection</param>
            <returns>Many-to-many table name</returns>
        </member>
        <member name="T:FluentNHibernate.MappingModel.ClassBased.ExternalComponentMapping">
            <summary>
            A component that is declared external to a class mapping.
            </summary>
        </member>
        <member name="T:FluentNHibernate.MappingModel.Collections.Lazy">
            <summary>
            Determines the lazy-loading strategy for a collection mapping.
            </summary>
        </member>
        <member name="F:FluentNHibernate.MappingModel.Collections.Lazy.False">
            <summary>
            Collection will be eager loaded (lazy=false).
            </summary>
        </member>
        <member name="F:FluentNHibernate.MappingModel.Collections.Lazy.True">
            <summary>
            Collection will lazy loaded (lazy=true).
            </summary>
        </member>
        <member name="F:FluentNHibernate.MappingModel.Collections.Lazy.Extra">
            <summary>
            collection will be extra lazy loaded (lazy=extra).
            </summary>
            <remarks>
            "Extra" lazy collections are mostly similar to lazy=true, except certain operations on the collection will not load the whol collection
            but issue a smarter SQL statement. For example, invoking Count on an extra-lazy collection will issue a "SELECT COUNT(*)..." rather than selecting 
            and loading the whole collection of entities.
            </remarks>
        </member>
        <member name="M:FluentNHibernate.Visitors.IMappingModelVisitor.Visit(System.Collections.Generic.IEnumerable{FluentNHibernate.MappingModel.HibernateMapping})">
            <summary>
            This bad boy is the entry point to the visitor
            </summary>
            <param name="mappings"></param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ListIndexPart.Offset(System.Int32)">
            <summary>
            offset added to index in column
            </summary>
            <remarks>mutual exclusive with Type()</remarks>
            <param name="offset">offset</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ListIndexPart.Column(System.String)">
            <summary>
            Specifies the column name for the index or key of the dictionary.
            </summary>
            <param name="indexColumnName">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ListIndexPart.Type``1">
            <summary>
            Specifies the type of the index/key column
            </summary>
            <remarks>mutual exclusive with offset</remarks>
            <typeparam name="TIndex">Index type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ListIndexPart.Type(System.Type)">
            <summary>
            Specifies the type of the index/key column
            </summary>
            <remarks>mutual exclusive with offset</remarks>
            <param name="type">Type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ListIndexPart.Type(System.String)">
            <summary>
            Specifies the type of the index/key column
            </summary>
            <remarks>mutual exclusive with offset</remarks>
            <param name="type">Type</param>
        </member>
        <member name="T:FluentNHibernate.Mapping.Laziness">
            <summary>
            Laziness strategy for relationships
            </summary>
        </member>
        <member name="F:FluentNHibernate.Mapping.Laziness.False">
            <summary>
            No lazy loading
            </summary>
        </member>
        <member name="F:FluentNHibernate.Mapping.Laziness.Proxy">
            <summary>
            Proxy-based lazy-loading
            </summary>
        </member>
        <member name="F:FluentNHibernate.Mapping.Laziness.NoProxy">
            <summary>
            No proxy lazy loading
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.NaturalIdPart`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Defines a property to be used for this natural-id.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <returns>The natural id part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.NaturalIdPart`1.Property(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
            <summary>
            Defines a property to be used for this natural-id with an explicit column name.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <param name="columnName">The column name in the database to use for this natural id, or null to use the property name</param>
            <returns>The natural id part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.NaturalIdPart`1.Reference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Defines a reference to be used as a many-to-one key for this natural-id with an explicit column name.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <returns>The natural ID part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.NaturalIdPart`1.Reference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
            <summary>
            Defines a reference to be used as a many-to-one key for this natural-id with an explicit column name.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <param name="columnName">The column name in the database to use for this key, or null to use the property name</param>
            <returns>The natural id part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.NaturalIdPart`1.ReadOnly">
            <summary>
            Specifies that this id is read-only
            </summary>
            <remarks>This is the same as setting the mutable attribute to false</remarks>
        </member>
        <member name="P:FluentNHibernate.Mapping.NaturalIdPart`1.Not">
            <summary>
            Inverts the next boolean operation
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.TuplizerPart.Type(System.Type)">
            <summary>
            Sets the tuplizer type.
            </summary>
            <param name="type">Type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.TuplizerPart.Type(System.String)">
            <summary>
            Sets the tuplizer type.
            </summary>
            <param name="type">Type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.TuplizerPart.Type``1">
            <summary>
            Sets the tuplizer type.
            </summary>
            <typeparam name="T">Type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.TuplizerPart.Mode(FluentNHibernate.MappingModel.TuplizerMode)">
            <summary>
            Sets the tuplizer mode
            </summary>
            <param name="mode">Mode</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.TuplizerPart.EntityName(System.String)">
            <summary>
            Specifies an entity-name.
            </summary>
            <remarks>See http://nhforge.org/blogs/nhibernate/archive/2008/10/21/entity-name-in-action-a-strongly-typed-entity.aspx</remarks>
        </member>
        <member name="M:FluentNHibernate.Utils.StringLikeness.EditDistance(System.String,System.String)">
            <SUMMARY>Computes the Levenshtein Edit Distance between two enumerables.</SUMMARY>
            <TYPEPARAM name="T">The type of the items in the enumerables.</TYPEPARAM>
            <PARAM name="x">The first enumerable.</PARAM>
            <PARAM name="y">The second enumerable.</PARAM>
            <RETURNS>The edit distance.</RETURNS>
        </member>
        <member name="T:FluentNHibernate.MappingModel.ClassBased.ReferenceComponentMapping">
            <summary>
            A reference to a component which is declared externally. Contains properties
            that can't be declared externally (property name, for example)
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ColumnPart.Name(System.String)">
            <summary>
            Specify the column name
            </summary>
            <param name="columnName">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ColumnPart.Length(System.Int32)">
            <summary>
            Specify the column length
            </summary>
            <param name="length">Column length</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ColumnPart.Nullable">
            <summary>
            Specify the nullability of the column
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ColumnPart.Unique">
            <summary>
            Specify the uniquness of the column
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ColumnPart.UniqueKey(System.String)">
            <summary>
            Specify the unique key constraint name
            </summary>
            <param name="key">Constraint name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ColumnPart.SqlType(System.String)">
            <summary>
            Specify the SQL type for the column
            </summary>
            <param name="sqlType">SQL type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ColumnPart.Index(System.String)">
            <summary>
            Specify the index name
            </summary>
            <param name="index">Index name</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.ColumnPart.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.ComponentMap`1">
            <summary>
            Defines a mapping for a component. Derive from this class to create a mapping,
            and use the constructor to control how your component is persisted.
            </summary>
            <example>
            public class AddressMap : ComponentMap&lt;Address&gt;
            {
              public AddressMap()
              {
                Map(x => x.Street);
                Map(x => x.City);
              }
            }
            </example>
            <typeparam name="T">Component type to map</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ComponentPartBase`2.ParentReference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Specify a parent reference for this component
            </summary>
            <param name="expression">Parent property</param>
            <example>
            ParentReference(x => x.Parent);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ComponentPartBase`2.ReadOnly">
            <summary>
            Specifies that this component is read-only
            </summary>
            <remarks>
            This is the same as calling both Not.Insert() and Not.Update()
            </remarks>
        </member>
        <member name="M:FluentNHibernate.Mapping.ComponentPartBase`2.Insert">
            <summary>
            Specifies that this component is insertable.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ComponentPartBase`2.Update">
            <summary>
            Specifies that this component is updatable
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ComponentPartBase`2.Unique">
            <summary>
            Specifies the uniqueness of this component
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ComponentPartBase`2.OptimisticLock">
            <summary>
            Specify that this component should be optimistically locked on access
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ComponentPartBase`2.Access">
            <summary>
            Set the access and naming strategy for this component.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ComponentPartBase`2.Not">
            <summary>
            Invert the next boolean operation
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ComponentMap`1.Component``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Creates a component reference. This is a place-holder for a component that is defined externally with a
            <see cref="T:FluentNHibernate.Mapping.ComponentMap`1"/>; the mapping defined in said <see cref="T:FluentNHibernate.Mapping.ComponentMap`1"/> will be merged
            with any options you specify from this call.
            </summary>
            <typeparam name="TComponent">Component type</typeparam>
            <param name="member">Property exposing the component</param>
            <returns>Component reference builder</returns>
        </member>
        <member name="T:FluentNHibernate.Mapping.ReferenceComponentPart`1">
            <summary>
            The fluent-interface part for a external component reference. These are
            components which have their bulk/body declared external to a class mapping
            and are reusable.
            </summary>
            <typeparam name="T">Component type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ReferenceComponentPart`1.ColumnPrefix(System.String)">
            <summary>
            Sets the prefix for any columns defined within the component. To refer to the property
            that exposes this component use {property}.
            </summary>
            <example>
            // Entity using Address component
            public class Person
            {
              public Address PostalAddress { get; set; }
            }
            
            ColumnPrefix("{property}_") will result in any columns of Person.Address being prefixed with "PostalAddress_".
            </example>
            <param name="prefix">Prefix for column names</param>
        </member>
        <member name="T:FluentNHibernate.Mapping.FilterPart">
            <summary>
            Maps to the Filter element in NH 2.0
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.KeyManyToOnePart.EntityName(System.String)">
            <summary>
            Specifies an entity-name.
            </summary>
            <remarks>See http://nhforge.org/blogs/nhibernate/archive/2008/10/21/entity-name-in-action-a-strongly-typed-entity.aspx</remarks>
        </member>
        <member name="P:FluentNHibernate.Mapping.KeyManyToOnePart.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.KeyManyToOnePart.Access">
            <summary>
            Defines how NHibernate will access the object for persisting/hydrating (Defaults to Property)
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PolymorphismBuilder`1.Implicit">
            <summary>
            Implicit polymorphism
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PolymorphismBuilder`1.Explicit">
            <summary>
            Explicit polymorphism
            </summary>
        </member>
        <member name="M:FluentNHibernate.Visitors.SeparateSubclassVisitor.SortByDistanceFrom(System.Type,System.Collections.Generic.IEnumerable{FluentNHibernate.Mapping.Providers.IIndeterminateSubclassMappingProvider})">
            <summary>
            Takes a type that represents the level in the class/subclass-hiearchy that we're starting from, the parent,
            this can be a class or subclass; also takes a list of subclass providers. The providers are then iterated
            and added to a dictionary key'd by the types "distance" from the parentType; distance being the number of levels
            between parentType and the subclass-type.
            
            By default if the Parent type is an interface the level will always be zero. At this time there is no check for
            hierarchical interface inheritance.
            </summary>
            <param name="parentType">Starting point, parent type.</param>
            <param name="subProviders">List of subclasses</param>
            <returns>Dictionary key'd by the distance from the parentType.</returns>
        </member>
        <member name="M:FluentNHibernate.Visitors.SeparateSubclassVisitor.DistanceFromParentInterface(System.Type,System.Type,System.Int32@)">
            <summary>
            The evalType starts out as the original subclass. The class hiearchy is only
            walked if the subclass inherits from a class that is included in the subclassProviders.
            </summary>
            <param name="parentType"></param>
            <param name="evalType"></param>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Visitors.SeparateSubclassVisitor.DistanceFromParentBase(System.Type,System.Type,System.Int32@)">
            <summary>
            The evalType is always one class higher in the hiearchy starting from the original subclass. The class 
            hiearchy is walked until the IsTopLevel (base class is Object) is met. The level is only incremented if 
            the subclass inherits from a class that is also in the subclassProviders.
            </summary>
            <param name="parentType"></param>
            <param name="evalType"></param>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="T:FluentNHibernate.Mapping.SubclassMap`1">
            <summary>
            Defines a mapping for an entity subclass. Derive from this class to create a mapping,
            and use the constructor to control how your entity is persisted.
            </summary>
            <example>
            public class EmployeeMap : SubclassMap&lt;Employee&gt;
            {
              public EmployeeMap()
              {
                Map(x => x.Name);
                Map(x => x.Age);
              }
            }
            </example>
            <typeparam name="T">Entity type to map</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Abstract">
            <summary>
            (optional) Specifies that this subclass is abstract
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.DynamicInsert">
            <summary>
            Sets the dynamic insert behaviour
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.DynamicUpdate">
            <summary>
            Sets the dynamic update behaviour
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.LazyLoad">
            <summary>
            Specifies that this entity should be lazy loaded
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Proxy``1">
            <summary>
            Specify a proxy type for this entity
            </summary>
            <typeparam name="TProxy">Proxy type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Proxy(System.Type)">
            <summary>
            Specify a proxy type for this entity
            </summary>
            <param name="proxyType">Proxy type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.SelectBeforeUpdate">
            <summary>
            Specify that a select should be performed before an update of this entity
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.DiscriminatorValue(System.Object)">
            <summary>
            Set the discriminator value, if this entity is in a table-per-class-hierarchy
            mapping strategy.
            </summary>
            <param name="discriminatorValue">Discriminator value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Table(System.String)">
            <summary>
            Sets the table name
            </summary>
            <param name="table">Table name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Schema(System.String)">
            <summary>
            Sets the schema
            </summary>
            <param name="schema">Schema</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Check(System.String)">
            <summary>
            Specifies a check constraint
            </summary>
            <param name="constraint">Constraint name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.KeyColumn(System.String)">
            <summary>
            Adds a column to the key for this subclass, if used
            in a table-per-subclass strategy.
            </summary>
            <param name="column">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Subselect(System.String)">
            <summary>
            Subselect query
            </summary>
            <param name="subselect">Subselect query</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Persister``1">
            <summary>
            Specifies a persister for this entity
            </summary>
            <typeparam name="TPersister">Persister type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Persister(System.Type)">
            <summary>
            Specifies a persister for this entity
            </summary>
            <param name="type">Persister type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Persister(System.String)">
            <summary>
            Specifies a persister for this entity
            </summary>
            <param name="type">Persister type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.BatchSize(System.Int32)">
            <summary>
            Set the query batch size
            </summary>
            <param name="batchSize">Batch size</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.EntityName(System.String)">
            <summary>
            Specifies an entity-name.
            </summary>
            <remarks>See http://nhforge.org/blogs/nhibernate/archive/2008/10/21/entity-name-in-action-a-strongly-typed-entity.aspx</remarks>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Join(System.String,System.Action{FluentNHibernate.Mapping.JoinPart{`0}})">
            <summary>
            Links this entity to another table, to create a composite entity from two or
            more tables. This only works if you're in a table-per-inheritance-hierarchy
            strategy.
            </summary>
            <param name="tableName">Joined table name</param>
            <param name="action">Joined table mapping</param>
            <example>
            Join("another_table", join =>
            {
              join.Map(x => x.Name);
              join.Map(x => x.Age);
            });
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Extends``1">
            <summary>
            (optional) Specifies the entity from which this subclass descends/extends.
            </summary>
            <typeparam name="TOther">Type of the entity to extend</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Extends(System.Type)">
            <summary>
            (optional) Specifies the entity from which this subclass descends/extends.
            </summary>
            <param name="type">Type of the entity to extend</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.SubclassMap`1.Not">
            <summary>
            Inverts the next boolean setting
            </summary>
        </member>
        <member name="T:FluentNHibernate.Cfg.AutoMappingsContainer">
            <summary>
            Container for automatic mappings
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.Add(System.Func{FluentNHibernate.Automapping.AutoPersistenceModel})">
            <summary>
            Add automatic mappings
            </summary>
            <param name="model">Lambda returning an auto mapping setup</param>
            <returns>Auto mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.Add(FluentNHibernate.Automapping.AutoPersistenceModel)">
            <summary>
            Add automatic mappings
            </summary>
            <param name="model">Auto mapping setup</param>
            <returns>Auto mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.ExportTo(System.String)">
            <summary>
            Sets the export location for generated mappings
            </summary>
            <param name="path">Path to folder for mappings</param>
            <returns>Auto mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.ExportTo(System.IO.TextWriter)">
            <summary>
            Sets the text writer to write the generated mappings to.
            </summary>                
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.Apply(NHibernate.Cfg.Configuration,FluentNHibernate.PersistenceModel)">
            <summary>
            Applies any added mappings to the NHibernate Configuration
            </summary>
            <param name="cfg">NHibernate Configuration instance</param>
            <param name="model"></param>
        </member>
        <member name="P:FluentNHibernate.Cfg.AutoMappingsContainer.WasUsed">
            <summary>
            Gets whether any mappings were added
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.Db.OracleClientConfiguration.Oracle9">
            <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleClientConfiguration"/> class using the
            MS Oracle Client (System.Data.OracleClient) library specifying the Oracle 9i dialect.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.Db.OracleClientConfiguration.Oracle10">
            <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleClientConfiguration"/> class using the
            MS Oracle Client (System.Data.OracleClient) library specifying the Oracle 10g dialect.
            This allows for ANSI join syntax.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.Db.OracleConfiguration.Oracle8">
            <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleConfiguration"/> class using the
            Oracle Data Provider (Oracle.DataAccess) library specifying the Oracle 8i dialect.
            The Oracle.DataAccess library must be available to the calling application/library.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.Db.OracleConfiguration.Oracle9">
            <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleConfiguration"/> class using the
            Oracle Data Provider (Oracle.DataAccess) library specifying the Oracle 9i dialect.
            The Oracle.DataAccess library must be available to the calling application/library.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.Db.OracleConfiguration.Oracle10">
            <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleConfiguration"/> class using the
            Oracle Data Provider (Oracle.DataAccess) library specifying the Oracle 10g dialect.
            The Oracle.DataAccess library must be available to the calling application/library.
            This allows for ANSI join syntax.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Server(System.String)">
            <summary>
            Specifies the server to connect. This can be either the DNS name of the
            server or the IP (as a string).
            </summary>
            <param name="server">The server.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Instance(System.String)">
            <summary>
            Specifies the instance (database name) to use.  This can be the short name or the
            fully qualified name (Oracle service name).
            </summary>
            <param name="instance">The instance.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Username(System.String)">
            <summary>
            Specifies the name of the user account accessing the database.
            </summary>
            <param name="username">The username.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Password(System.String)">
            <summary>
            Specifies the password of the user account accessing the database.
            </summary>
            <param name="password">The password.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Port(System.Int32)">
            <summary>
            Optional. Ports the specified port the oracle database is running on.  This defaults to 1521.
            </summary>
            <param name="port">The port.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Pooling(System.Boolean)">
            <summary>
            Enable or disable pooling connections for this data configuration.
            </summary>
            <param name="pooling">if set to <c>true</c> enable pooling.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.StatementCacheSize(System.Int32)">
            <summary>
            Specifies the SQL statement cache size to use for this connection.
            </summary>
            <param name="cacheSize">Size of the cache.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.OtherOptions(System.String)">
            <summary>
            Specifies, as a string, other Oracle options to pass to the connection.
            </summary>
            <param name="otherOptions">The other options.</param>
            <returns></returns>
        </member>
        <member name="P:FluentNHibernate.Cfg.Db.OracleDataClientConfiguration.Oracle9">
            <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleDataClientConfiguration"/> class using the
            Oracle Data Provider (Oracle.DataAccess) library specifying the Oracle 9i dialect. 
            The Oracle.DataAccess library must be available to the calling application/library. 
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.Db.OracleDataClientConfiguration.Oracle10">
            <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleDataClientConfiguration"/> class using the
            Oracle Data Provider (Oracle.DataAccess) library specifying the Oracle 10g dialect. 
            The Oracle.DataAccess library must be available to the calling application/library. 
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder.Authentication(System.String)">
            <summary>
            The type of authentication to be used. Acceptable values:
            <list type="bullet">
            <item>
                SERVER
            </item>
            <item>
                SERVER_ENCRYPT
            </item>
            <item>
                DATA_ENCRYPT
            </item>
            <item>
                KERBEROS
            </item>
            <item>
                GSSPLUGIN
            </item>
            </list>
            </summary>
            <param name="authentication"></param>
            <returns>IfxDRDAConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder.Database(System.String)">
            <summary>
            The name of the database within the server instance.
            </summary>
            <param name="database"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder.HostVarParameter(System.String)">
            <summary>
            <list type="bullet">
            <item>
                <term>true</term>
                <description> - host variable (:param) support enabled.</description>
            </item>
            <item>
                <term>false (default)</term>
                <description> - host variable support disabled.</description>
            </item>
            </list>
            </summary>
            <param name="hostVarParameter"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder.IsolationLevel(System.String)">
            <summary>
            Isolation level for the connection. Possible values:
            <list type="bullet">
            <item>
                ReadCommitted
            </item>
            <item>
                ReadUncommitted
            </item>
            <item>
                RepeatableRead
            </item>
            <item>
                Serializable
            </item>
            <item>
                Transaction
            </item>
            </list>
            This keyword is only supported for applications participating in a
            distributed transaction.
            </summary>
            <param name="isolationLevel"></param>
            <returns>IfxDRDAConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder.MaxPoolSize(System.String)">
            <summary>
            The maximum number of connections allowed in the pool.
            </summary>
            <param name="maxPoolSize"></param>
            <returns>IfxDRDAConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder.MinPoolSize(System.String)">
            <summary>
            The minimum number of connections allowed in the pool. Default value 0.
            </summary>
            <param name="minPoolSize"></param>
            <returns>IfxDRDAConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder.Password(System.String)">
            <summary>
            The password associated with the User ID.
            </summary>
            <param name="password"></param>
            <returns>IfxDRDAConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder.Pooling(System.String)">
            <summary>
            When set to true, the IfxConnection object is drawn from
            the appropriate pool, or if necessary, it is created and added
            to the appropriate pool. Default value 'true'.
            </summary>
            <param name="pooling"></param>
            <returns>IfxDRDAConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder.Server(System.String)">
            <summary>
            Server name with optional port number for direct connection using either
            IPv4 notation (<![CDATA[<server name/ip address>[:<port>]]]>) or IPv6 notation.
            </summary>
            <param name="server"></param>
            <returns>IfxDRDAConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder.Username(System.String)">
            <summary>
            The login account.
            </summary>
            <param name="username"></param>
            <returns>IfxDRDAConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder.OtherOptions(System.String)">
            <summary>
            Other options: Connection Lifetime, Connection Reset, Connection Timeout, CurrentSchema, Enlist,
            Interrupt, Persist Security Info, ResultArrayAsReturnValue, Security, TrustedContextSystemUserID,
            TrustedContextSystemPassword
            </summary>
            <param name="otherOptions"></param>
            <returns>IfxDRDAConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.ClientLocale(System.String)">
            <summary>
            Client locale, default value is en_us.CP1252 (Windows)
            </summary>
            <param name="clientLocale"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.Database(System.String)">
            <summary>
            The name of the database within the server instance.
            </summary>
            <param name="database"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.DatabaseLocale(System.String)">
            <summary>
            The language locale of the database. Default value is en_US.8859-1
            </summary>
            <param name="databaseLocale"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.Delimident(System.Boolean)">
            <summary>
            When set to true or y for yes, any string within double
            quotes (") is treated as an identifier, and any string within
            single quotes (') is treated as a string literal. Default value 'y'.
            </summary>
            <param name="delimident"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.Host(System.String)">
            <summary>
            The name or IP address of the machine on which the
            Informix server is running. Required.
            </summary>
            <param name="host"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.MaxPoolSize(System.String)">
            <summary>
            The maximum number of connections allowed in the pool. Default value 100.
            </summary>
            <param name="maxPoolSize"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.MinPoolSize(System.String)">
            <summary>
            The minimum number of connections allowed in the pool. Default value 0.
            </summary>
            <param name="minPoolSize"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.Password(System.String)">
            <summary>
            The password associated with the User ID. Required if the
            client machine or user account is not trusted by the host.
            Prohibited if a User ID is not given.
            </summary>
            <param name="password"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.Pooling(System.String)">
            <summary>
            When set to true, the IfxConnection object is drawn from
            the appropriate pool, or if necessary, it is created and added
            to the appropriate pool. Default value 'true'.
            </summary>
            <param name="pooling"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.Server(System.String)">
            <summary>
            The name or alias of the instance of the Informix server to
            which to connect. Required.
            </summary>
            <param name="server"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.Service(System.String)">
            <summary>
            The service name or port number through which the server
            is listening for connection requests.
            </summary>
            <param name="service"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.Username(System.String)">
            <summary>
            The login account. Required, unless the client machine is
            trusted by the host machine.
            </summary>
            <param name="username"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder.OtherOptions(System.String)">
            <summary>
            Other options like: Connection Lifetime, Enlist, Exclusive, Optimize OpenFetchClose,
            Fetch Buffer Size, Persist Security Info, Protocol, Single Threaded, Skip Parsing
            </summary>
            <param name="otherOptions"></param>
            <returns>IfxSQLIConnectionStringBuilder object</returns>
        </member>
        <member name="T:FluentNHibernate.Cfg.FluentConfiguration">
            <summary>
            Fluent configuration API for NHibernate
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.Diagnostics(System.Action{FluentNHibernate.Diagnostics.DiagnosticsConfiguration})">
            <summary>
            Configure diagnostic logging
            </summary>
            <param name="diagnosticsSetup">Diagnostic configuration</param>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.Database(System.Func{FluentNHibernate.Cfg.Db.IPersistenceConfigurer})">
            <summary>
            Apply database settings
            </summary>
            <param name="config">Lambda returning database configuration</param>
            <returns>Fluent configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.Database(FluentNHibernate.Cfg.Db.IPersistenceConfigurer)">
            <summary>
            Apply database settings
            </summary>
            <param name="config">Database configuration instance</param>
            <returns>Fluent configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.Cache(System.Action{FluentNHibernate.Cfg.Db.CacheSettingsBuilder})">
            <summary>
            Configure caching.
            </summary>
            <example>
                Cache(x =>
                {
                  x.UseQueryCache();
                  x.UseMinimalPuts();
                });
            </example>
            <param name="cacheExpression">Closure for configuring caching</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.CollectionTypeFactory(System.String)">
            <summary>
            Sets the collectiontype.factory_class property.
            NOTE: NHibernate 2.1 only
            </summary>
            <param name="collectionTypeFactoryClass">factory class</param>
            <returns>Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.CollectionTypeFactory(System.Type)">
            <summary>
            Sets the collectiontype.factory_class property.
            NOTE: NHibernate 2.1 only
            </summary>
            <param name="collectionTypeFactoryClass">factory class</param>
            <returns>Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.CollectionTypeFactory``1">
            <summary>
            Sets the collectiontype.factory_class property.
            NOTE: NHibernate 2.1 only
            </summary>
            <typeparam name="TCollectionTypeFactory">factory class</typeparam>
            <returns>Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.ProxyFactoryFactory(System.String)">
            <summary>
            Sets the proxyfactory.factory_class property.
            NOTE: NHibernate 2.1 only
            </summary>
            <param name="proxyFactoryFactoryClass">factory class</param>
            <returns>Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.ProxyFactoryFactory(System.Type)">
            <summary>
            Sets the proxyfactory.factory_class property.
            NOTE: NHibernate 2.1 only
            </summary>
            <param name="proxyFactoryFactory">factory class</param>
            <returns>Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.ProxyFactoryFactory``1">
            <summary>
            Sets the proxyfactory.factory_class property.
            NOTE: NHibernate 2.1 only
            </summary>
            <typeparam name="TProxyFactoryFactory">factory class</typeparam>
            <returns>Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.CurrentSessionContext(System.String)">
            <summary>
            Sets the current_session_context_class property.
            </summary>
            <param name="currentSessionContextClass">current session context class</param>
            <returns>Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.CurrentSessionContext``1">
            <summary>
            Sets the current_session_context_class property.
            </summary>
            <typeparam name="TSessionContext">Implementation of ICurrentSessionContext to use</typeparam>
            <returns>Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.Mappings(System.Action{FluentNHibernate.Cfg.MappingConfiguration})">
            <summary>
            Apply mappings to NHibernate
            </summary>
            <param name="mappings">Lambda used to apply mappings</param>
            <returns>Fluent configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.ExposeConfiguration(System.Action{NHibernate.Cfg.Configuration})">
            <summary>
            Allows altering of the raw NHibernate Configuration object before creation
            </summary>
            <param name="config">Lambda used to alter Configuration</param>
            <returns>Fluent configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.BuildSessionFactory">
            <summary>
            Verify's the configuration and instructs NHibernate to build a SessionFactory.
            </summary>
            <returns>ISessionFactory from supplied settings.</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.BuildConfiguration">
            <summary>
            Verifies the configuration and populates the NHibernate Configuration instance.
            </summary>
            <returns>NHibernate Configuration instance</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentConfiguration.CreateConfigurationException(System.Exception)">
            <summary>
            Creates an exception based on the current state of the configuration.
            </summary>
            <param name="innerException">Inner exception</param>
            <returns>FluentConfigurationException with state</returns>
        </member>
        <member name="T:FluentNHibernate.Cfg.Fluently">
            <summary>
            Fluently configure NHibernate
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.Fluently.Configure">
            <summary>
            Begin fluently configuring NHibernate
            </summary>
            <returns>Fluent Configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.Fluently.Configure(NHibernate.Cfg.Configuration)">
            <summary>
            Begin fluently configuring NHibernate
            </summary>
            <param name="cfg">Instance of an NHibernate Configuration</param>
            <returns>Fluent Configuration</returns>
        </member>
        <member name="T:FluentNHibernate.Cfg.FluentMappingsContainer">
            <summary>
            Container for fluent mappings
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.AddFromAssemblyOf``1">
            <summary>
            Add all fluent mappings in the assembly that contains T.
            </summary>
            <typeparam name="T">Type from the assembly</typeparam>
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.AddFromAssembly(System.Reflection.Assembly)">
            <summary>
            Add all fluent mappings in the assembly
            </summary>
            <param name="assembly">Assembly to add mappings from</param>
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.Add``1">
            <summary>
            Adds a single <see cref="T:FluentNHibernate.IMappingProvider"/> represented by the specified type.
            </summary>
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.Add(System.Type)">
            <summary>
            Adds a single <see cref="T:FluentNHibernate.IMappingProvider"/> represented by the specified type.
            </summary>
            <param name="type">The type.</param>
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.ExportTo(System.String)">
            <summary>
            Sets the export location for generated mappings
            </summary>
            <param name="path">Path to folder for mappings</param>
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.ExportTo(System.IO.TextWriter)">
            <summary>
            Sets the text writer to write the generated mappings to.
            </summary>                
            <returns>Fluent mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.Apply(FluentNHibernate.PersistenceModel)">
            <summary>
            Applies any added mappings to the NHibernate Configuration
            </summary>
            <param name="model">PersistenceModel to alter</param>
        </member>
        <member name="P:FluentNHibernate.Cfg.FluentMappingsContainer.Conventions">
            <summary>
            Alter convention discovery
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.FluentMappingsContainer.WasUsed">
            <summary>
            Gets whether any mappings were added
            </summary>
        </member>
        <member name="T:FluentNHibernate.Cfg.HbmMappingsContainer">
            <summary>
            Container for Hbm mappings
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.AddClasses(System.Type[])">
            <summary>
            Add explicit classes with Hbm mappings
            </summary>
            <param name="types">List of types to map</param>
            <returns>Hbm mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.AddFromAssemblyOf``1">
            <summary>
            Add all Hbm mappings in the assembly that contains T.
            </summary>
            <typeparam name="T">Type from the assembly</typeparam>
            <returns>Hbm mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.AddFromAssembly(System.Reflection.Assembly)">
            <summary>
            Add all Hbm mappings in the assembly
            </summary>
            <param name="assembly">Assembly to add mappings from</param>
            <returns>Hbm mappings configuration</returns>
        </member>
        <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.Apply(NHibernate.Cfg.Configuration)">
            <summary>
            Applies any added mappings to the NHibernate Configuration
            </summary>
            <param name="cfg">NHibernate Configuration instance</param>
        </member>
        <member name="P:FluentNHibernate.Cfg.HbmMappingsContainer.WasUsed">
            <summary>
            Gets whether any mappings were added
            </summary>
        </member>
        <member name="T:FluentNHibernate.Cfg.MappingConfiguration">
            <summary>
            Fluent mapping configuration
            </summary>
        </member>
        <member name="M:FluentNHibernate.Cfg.MappingConfiguration.Apply(NHibernate.Cfg.Configuration)">
            <summary>
            Applies any mappings to the NHibernate Configuration
            </summary>
            <param name="cfg">NHibernate Configuration instance</param>
        </member>
        <member name="P:FluentNHibernate.Cfg.MappingConfiguration.FluentMappings">
            <summary>
            Fluent mappings
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.MappingConfiguration.AutoMappings">
            <summary>
            Automatic mapping configurations
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.MappingConfiguration.HbmMappings">
            <summary>
            Hbm mappings
            </summary>
        </member>
        <member name="P:FluentNHibernate.Cfg.MappingConfiguration.WasUsed">
            <summary>
            Get whether any mappings of any kind were added
            </summary>
        </member>
        <member name="T:FluentNHibernate.Conventions.IConventionFinder">
            <summary>
            Convention finder - used to search through assemblies for types that implement a specific convention interface.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.AddSource(FluentNHibernate.ITypeSource)">
            <summary>
            Add a source to be queried.
            </summary>
            <param name="source">Source to query</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Add an assembly to be queried.
            </summary>
            <remarks>
            All convention types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder"/>.
            </remarks>
            <param name="assembly">Assembly instance to query</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.AddFromAssemblyOf``1">
            <summary>
            Adds all conventions found in the assembly that contains <typeparam name="T"/>.
            </summary>
            <remarks>
            All convention types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder"/>.
            </remarks>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.Add``1">
            <summary>
            Add a single convention by type.
            </summary>
            <remarks>
            Type must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder"/>.
            </remarks>
            <typeparam name="T">Convention type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.Add(System.Type)">
            <summary>
            Add a single convention by type.
            </summary>
            <remarks>
            Types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder"/>.
            </remarks>
            <param name="type">Type of convention</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.Add``1(``0)">
            <summary>
            Add an instance of a convention.
            </summary>
            <remarks>
            Useful for supplying conventions that require extra constructor parameters.
            </remarks>
            <typeparam name="T">Convention type</typeparam>
            <param name="instance">Instance of convention</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.IConventionFinder.Find``1">
            <summary>
            Find any conventions implementing T.
            </summary>
            <typeparam name="T">Convention interface type</typeparam>
            <returns>IEnumerable of T</returns>
        </member>
        <member name="T:FluentNHibernate.Conventions.DefaultConventionFinder">
            <summary>
            Default convention finder - doesn't do anything special.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Find``1">
            <summary>
            Find any conventions implementing T.
            </summary>
            <typeparam name="T">Convention interface type</typeparam>
            <returns>IEnumerable of T</returns>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Add an assembly to be queried.
            </summary>
            <remarks>
            All convention types must have a parameterless constructor, or a single parameter of IConventionFinder.
            </remarks>
            <param name="assembly">Assembly instance to query</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.AddFromAssemblyOf``1">
            <summary>
            Adds all conventions found in the assembly that contains T.
            </summary>
            <remarks>
            All convention types must have a parameterless constructor, or a single parameter of IConventionFinder.
            </remarks>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Add``1">
            <summary>
            Add a single convention by type.
            </summary>
            <remarks>
            Type must have a parameterless constructor, or a single parameter of IConventionFinder.
            </remarks>
            <typeparam name="T">Convention type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Add(System.Type)">
            <summary>
            Add a single convention by type.
            </summary>
            <remarks>
            Types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder"/>.
            </remarks>
            <param name="type">Type of convention</param>
        </member>
        <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Add``1(``0)">
            <summary>
            Add an instance of a convention.
            </summary>
            <remarks>
            Useful for supplying conventions that require extra constructor parameters.
            </remarks>
            <typeparam name="T">Convention type</typeparam>
            <param name="instance">Instance of convention</param>
        </member>
        <member name="M:FluentNHibernate.Data.Entity.Equals(FluentNHibernate.Data.Entity)">
            <summary>
            Indicates whether the current <see cref="T:FluentNHibernate.Data.Entity" /> is equal to another <see cref="T:FluentNHibernate.Data.Entity" />.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
            <param name="obj">An Entity to compare with this object.</param>
        </member>
        <member name="M:FluentNHibernate.Data.Entity.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:FluentNHibernate.Data.Entity" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
            <returns>
            true if the specified <see cref="T:FluentNHibernate.Data.Entity" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. </param>
            <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:FluentNHibernate.Data.Entity.GetHashCode">
            <summary>
            Serves as a hash function for a Entity. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:FluentNHibernate.MappingModel.ClassBased.SubclassMapping.Extends">
            <summary>
            Set which type this subclass extends.
            Note: This doesn't actually get output into the XML, it's
            instead used as a marker for the <see cref="T:FluentNHibernate.Visitors.SeparateSubclassVisitor"/>
            to pair things up.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.AnyPart`1">
            <summary>
            Represents the "Any" mapping in NHibernate. It is impossible to specify a foreign key constraint for this kind of association. For more information
            please reference chapter 5.2.4 in the NHibernate online documentation
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AnyPart`1.MetaType``1">
            <summary>
            Sets the meta-type value for this any mapping.
            </summary>
            <typeparam name="TMetaType">Meta type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.AnyPart`1.MetaType(System.String)">
            <summary>
            Sets the meta-type value for this any mapping.
            </summary>
            <param name="metaType">Meta type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AnyPart`1.MetaType(System.Type)">
            <summary>
            Sets the meta-type value for this any mapping.
            </summary>
            <param name="metaType">Meta type</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.AnyPart`1.Access">
            <summary>
            Defines how NHibernate will access the object for persisting/hydrating (Defaults to Property)
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.AnyPart`1.Cascade">
            <summary>
            Cascade style (Defaults to none)
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.AccessStrategyBuilder">
            <summary>
            Access strategy mapping builder.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.#ctor(System.Action{System.String})">
            <summary>
            Access strategy mapping builder.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.Property">
            <summary>
            Sets the access-strategy to property.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.Field">
            <summary>
            Sets the access-strategy to field.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.BackingField">
            <summary>
            Sets the access-strategy to use the backing-field of an auto-property.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.ReadOnly">
            <summary>
            Sets the access-strategy to readonly.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.CamelCaseField">
            <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase (field.camelcase).
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.CamelCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.LowerCaseField">
            <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.LowerCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.PascalCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.ReadOnlyPropertyThroughCamelCaseField">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.ReadOnlyPropertyThroughCamelCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.ReadOnlyPropertyThroughLowerCaseField">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.ReadOnlyPropertyThroughLowerCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.ReadOnlyPropertyThroughPascalCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.Using(System.String)">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <param name="propertyAccessorAssemblyQualifiedClassName">Assembly qualified name of the type to use as the access-strategy</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.Using(System.Type)">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <param name="propertyAccessorClassType">Type to use as the access-strategy</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.Using``1">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <typeparam name="TPropertyAccessorClass">Type to use as the access-strategy</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.AlwaysSelectWithValue">
            <summary>
            Force NHibernate to always select using the discriminator value, even when selecting all subclasses. This
            can be useful when your table contains more discriminator values than you have classes (legacy).
            </summary>
            <remarks>Sets the "force" attribute.</remarks>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.ReadOnly">
            <summary>
            Set this discriminator as read-only. Call this if your discriminator column is also part of a mapped composite identifier.
            </summary>
            <returns>Sets the "insert" attribute.</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.Formula(System.String)">
            <summary>
            An arbitrary SQL expression that is executed when a type has to be evaluated. Allows content-based discrimination.
            </summary>
            <param name="sql">SQL expression</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.Precision(System.Int32)">
            <summary>
            Sets the precision for decimals
            </summary>
            <param name="precision">Decimal precision</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.Scale(System.Int32)">
            <summary>
            Specifies the scale for decimals
            </summary>
            <param name="scale">Decimal scale</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.Length(System.Int32)">
            <summary>
            Specify the column length
            </summary>
            <param name="length">Column length</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.Nullable">
            <summary>
            Specify the nullability of this column
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.Unique">
            <summary>
            Specifies the uniqueness of this column
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.UniqueKey(System.String)">
            <summary>
            Specifies the unique key constraint name
            </summary>
            <param name="keyColumns">Constraint columns</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.Index(System.String)">
            <summary>
            Specifies the index name
            </summary>
            <param name="index">Index name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.Check(System.String)">
            <summary>
            Specifies a check constraint name
            </summary>
            <param name="constraint">Constraint name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.Default(System.Object)">
            <summary>
            Specifies the default value for the discriminator
            </summary>
            <param name="value">Default value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.CustomType``1">
            <summary>
            Specifies a custom type for the discriminator
            </summary>
            <remarks>
            This is often used with <see cref="T:NHibernate.UserTypes.IUserType"/>
            </remarks>
            <typeparam name="T">Custom type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.CustomType(System.Type)">
            <summary>
            Specifies a custom type for the discriminator
            </summary>
            <remarks>
            This is often used with <see cref="T:NHibernate.UserTypes.IUserType"/>
            </remarks>
            <param name="type">Custom type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.CustomType(System.String)">
            <summary>
            Specifies a custom type for the discriminator
            </summary>
            <remarks>
            This is often used with <see cref="T:NHibernate.UserTypes.IUserType"/>
            </remarks>
            <param name="type">Custom type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.SqlType(System.String)">
            <summary>
            Specifies a custom SQL type for the discriminator.
            </summary>
            <param name="type">Custom SQL type.</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.DiscriminatorPart.Not">
            <summary>
            Invert the next boolean operation
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.DiscriminatorValue">
            <summary>
            Pre-defined discriminator values
            </summary>
        </member>
        <member name="F:FluentNHibernate.Mapping.DiscriminatorValue.Null">
            <summary>
            Null discriminator value
            </summary>
        </member>
        <member name="F:FluentNHibernate.Mapping.DiscriminatorValue.NotNull">
            <summary>
            Non-null discriminator value
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ElementPart.Column(System.String)">
            <summary>
            Specify the element column name
            </summary>
            <param name="elementColumnName">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ElementPart.Type``1">
            <summary>
            Specify the element type
            </summary>
            <typeparam name="TElement">Element type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ElementPart.Length(System.Int32)">
            <summary>
            Specify the element column length
            </summary>
            <param name="length">Column length</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ElementPart.Formula(System.String)">
            <summary>
            Specify the element column formula
            </summary>
            <param name="formula">Formula</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.ElementPart.Columns">
            <summary>
            Modify the columns for this element
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CachePart.ReadWrite">
            <summary>
            Sets caching to read-write
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CachePart.NonStrictReadWrite">
            <summary>
            Sets caching to non-strict read-write
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CachePart.ReadOnly">
            <summary>
            Sets caching to read-only
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CachePart.Transactional">
            <summary>
            Sets caching to transactional
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CachePart.CustomUsage(System.String)">
            <summary>
            Specifies a custom cache behaviour
            </summary>
            <param name="custom">Custom behaviour</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.CachePart.Region(System.String)">
            <summary>
            Specifies the cache region
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CachePart.IncludeAll">
            <summary>
            Include all properties for caching
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CachePart.IncludeNonLazy">
            <summary>
            Include only non-lazy properties for caching
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CachePart.CustomInclude(System.String)">
            <summary>
            Specify a custom property inclusion strategy
            </summary>
            <param name="custom">Inclusion strategy</param>
        </member>
        <member name="T:FluentNHibernate.Conventions.UserTypeConvention`1">
            <summary>
            Base class for user type conventions. Create a subclass of this to automatically
            map all properties that the user type can be used against. Override Accept or
            Apply to alter the behavior.
            </summary>
            <typeparam name="TUserType">IUserType implementation</typeparam>
        </member>
        <member name="T:FluentNHibernate.Conventions.AttributePropertyConvention`1">
            <summary>
            Base class for attribute based conventions. Create a subclass of this to supply your own
            attribute based conventions.
            </summary>
            <typeparam name="T">Attribute identifier</typeparam>
        </member>
        <member name="M:FluentNHibernate.Conventions.AttributePropertyConvention`1.Apply(`0,FluentNHibernate.Conventions.Instances.IPropertyInstance)">
            <summary>
            Apply changes to a property with an attribute matching T.
            </summary>
            <param name="attribute">Instance of attribute found on property.</param>
            <param name="instance">Property with attribute</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.CascadeExpression`1.All">
            <summary>
            Cascade all actions
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CascadeExpression`1.None">
            <summary>
            Cascade no actions
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CascadeExpression`1.SaveUpdate">
            <summary>
            Cascade saves and updates
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CascadeExpression`1.Delete">
            <summary>
            Cascade deletes
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CascadeExpression`1.Merge">
            <summary>
            Cascade deletes
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CollectionCascadeExpression`1.AllDeleteOrphan">
            <summary>
            Cascade all actions, deleting any orphaned records
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CollectionCascadeExpression`1.DeleteOrphan">
            <summary>
            Cascade deletes, deleting any orphaned records
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.DynamicComponentPart`1.Map(System.String)">
            <summary>
            Map a property
            </summary>
            <param name="key">Dictionary key</param>
            <example>
            Map("Age");
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.DynamicComponentPart`1.Map``1(System.String)">
            <summary>
            Map a property
            </summary>
            <param name="key">Dictionary key</param>
            <typeparam name="TProperty">Property type</typeparam>
            <example>
            Map&lt;int&gt;("Age");
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.FetchTypeExpression`1.Join">
            <summary>
            Join fetching
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.FetchTypeExpression`1.Select">
            <summary>
            Select fetching
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.FetchTypeExpression`1.Subselect">
            <summary>
            Subselect/subquery fetching
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IndexManyToManyPart.EntityName(System.String)">
            <summary>
            Specifies an entity-name.
            </summary>
            <remarks>See http://nhforge.org/blogs/nhibernate/archive/2008/10/21/entity-name-in-action-a-strongly-typed-entity.aspx</remarks>
        </member>
        <member name="T:FluentNHibernate.Mapping.InvalidPrefixException">
            <summary>
            Thrown when a prefix is specified for an access-strategy that isn't supported.
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.Prefix">
            <summary>
            Naming strategy prefix.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyGeneratedBuilder.Never">
            <summary>
            Property is never database generated
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyGeneratedBuilder.Insert">
            <summary>
            Property is only generated on insert
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyGeneratedBuilder.Always">
            <summary>
            Property is always database generated
            </summary>
        </member>
        <member name="M:FluentNHibernate.Testing.PersistenceSpecificationExtensions.CheckComponentList``2(FluentNHibernate.Testing.PersistenceSpecification{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Collections.Generic.IEnumerable{``1},System.Collections.IEqualityComparer)">
            <summary>
            Checks a list of components for validity.
            </summary>
            <typeparam name="T">Entity type</typeparam>
            <typeparam name="TListElement">Type of list element</typeparam>
            <param name="spec">Persistence specification</param>
            <param name="expression">Property</param>
            <param name="propertyValue">Value to save</param>
            <param name="elementComparer">Equality comparer</param>
        </member>
        <member name="T:FluentNHibernate.Utils.ExpressionToSql">
            <summary>
            Converts an expression to a best guess SQL string
            </summary>
        </member>
        <member name="M:FluentNHibernate.Utils.ExpressionToSql.Convert``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Converts a Func expression to a best guess SQL string
            </summary>
        </member>
        <member name="M:FluentNHibernate.Utils.ExpressionToSql.Convert``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Converts a boolean Func expression to a best guess SQL string
            </summary>
        </member>
        <member name="M:FluentNHibernate.Utils.ExpressionToSql.Convert(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Gets the value of a method call.
            </summary>
            <param name="body">Method call expression</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ImportPart.As(System.String)">
            <summary>
            Specify an alternative name for the type
            </summary>
            <param name="alternativeName">Alternative name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.NotFoundExpression`1.Ignore">
            <summary>
            Used to set the Not-Found attribute to ignore.  This tells NHibernate to 
            return a null object rather then throw an exception when the join fails
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.NotFoundExpression`1.Exception">
            <summary>
            Used to set the Not-Found attribute to exception (Nhibernate default).  This 
            tells NHibernate to throw an exception when the join fails
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToOnePart`1.Class``1">
            <summary>
            Specifies the child class
            </summary>
            <typeparam name="T">Child</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToOnePart`1.Class(System.Type)">
            <summary>
            Specifies the child class
            </summary>
            <param name="type">Child</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToOnePart`1.ForeignKey">
            <summary>
            Specifies that this relationship should be created with a default-named
            foreign-key
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToOnePart`1.ForeignKey(System.String)">
            <summary>
            Specify the foreign-key constraint name
            </summary>
            <param name="foreignKeyName">Foreign-key constraint</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToOnePart`1.PropertyRef(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Sets the property reference
            </summary>
            <param name="expression">Property</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToOnePart`1.PropertyRef(System.String)">
            <summary>
            Sets the property reference
            </summary>
            <param name="propertyName">Property</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToOnePart`1.Constrained">
            <summary>
            Specifies that this relationship is constrained
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToOnePart`1.LazyLoad">
            <summary>
            Specify the lazy behaviour of this relationship.
            </summary>
            <remarks>
            Defaults to Proxy lazy-loading. Use the <see cref="P:FluentNHibernate.Mapping.OneToOnePart`1.Not"/> modifier to disable
            lazy-loading, and use the <see cref="M:FluentNHibernate.Mapping.OneToOnePart`1.LazyLoad(FluentNHibernate.Mapping.Laziness)"/>
            overload to specify alternative lazy strategies.
            </remarks>
            <example>
            LazyLoad();
            Not.LazyLoad();
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToOnePart`1.LazyLoad(FluentNHibernate.Mapping.Laziness)">
            <summary>
            Specify the lazy behaviour of this relationship. Cannot be used
            with the <see cref="P:FluentNHibernate.Mapping.OneToOnePart`1.Not"/> modifier.
            </summary>
            <param name="laziness">Laziness strategy</param>
            <example>
            LazyLoad(Laziness.NoProxy);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToOnePart`1.EntityName(System.String)">
            <summary>
            Specifies an entity-name.
            </summary>
            <remarks>See http://nhforge.org/blogs/nhibernate/archive/2008/10/21/entity-name-in-action-a-strongly-typed-entity.aspx</remarks>
        </member>
        <member name="P:FluentNHibernate.Mapping.OneToOnePart`1.Fetch">
            <summary>
            Sets the fetch behaviour for this relationship
            </summary>
            <example>
            Fetch.Select();
            </example>
        </member>
        <member name="P:FluentNHibernate.Mapping.OneToOnePart`1.Cascade">
            <summary>
            Sets the cascade behaviour for this relationship
            </summary>
            <example>
            Cascade.All();
            </example>
        </member>
        <member name="P:FluentNHibernate.Mapping.OneToOnePart`1.Access">
            <summary>
            Specifies the access strategy for this relationship
            </summary>
            <example>
            Access.Field();
            </example>
        </member>
        <member name="P:FluentNHibernate.Mapping.OneToOnePart`1.Not">
            <summary>
            Inverts the next boolean operation
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder.None">
            <summary>
            No optimistic locking
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder.Version">
            <summary>
            Version locking
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder.Dirty">
            <summary>
            Dirty locking
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder.All">
            <summary>
            Lock on everything
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder`1.None">
            <summary>
            Use no locking strategy
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder`1.Version">
            <summary>
            Use version locking
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder`1.Dirty">
            <summary>
            Use dirty locking
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder`1.All">
            <summary>
            Use all locking
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.PropertyRef(System.String)">
            <summary>
            This method is used to set a different key column in this table to be used for joins.
            The output is set as the property-ref attribute in the "key" subelement of the collection
            </summary>
            <param name="propertyRef">The name of the column in this table which is linked to the foreign key</param>
            <returns>OneToManyPart</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.LazyLoad">
            <summary>
            Specify the lazy-load behaviour
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.ExtraLazyLoad">
            <summary>
            Specify extra lazy loading
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Inverse">
            <summary>
            Inverse the ownership of this entity. Make the other side of the relationship
            responsible for saving.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsSet">
            <summary>
            Use a set collection
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsSet(FluentNHibernate.MappingModel.Collections.SortType)">
            <summary>
            Use a set collection
            </summary>
            <param name="sort">Sorting</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsSet``1">
            <summary>
            Use a set collection
            </summary>
            <typeparam name="TComparer">Item comparer</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsBag">
            <summary>
            Use a bag collection
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsList">
            <summary>
            Use a list collection
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsList(System.Action{FluentNHibernate.Mapping.ListIndexPart})">
            <summary>
            Use a list collection with an index
            </summary>
            <param name="customIndexMapping">Index mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsMap``1(System.Linq.Expressions.Expression{System.Func{`1,``0}})">
            <summary>
            Use a map collection
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <param name="indexSelector">Index property</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsMap``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},FluentNHibernate.MappingModel.Collections.SortType)">
            <summary>
            Use a map collection
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <param name="indexSelector">Index property</param>
            <param name="sort">Sorting</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsMap(System.String)">
            <summary>
            Use a map collection
            </summary>
            <param name="indexColumnName">Index column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsMap(System.String,FluentNHibernate.MappingModel.Collections.SortType)">
            <summary>
            Use a map collection
            </summary>
            <param name="indexColumnName">Index column name</param>
            <param name="sort">Sorting</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsMap``1(System.String)">
            <summary>
            Use a map collection
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <param name="indexColumnName">Index column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsMap``1(System.String,FluentNHibernate.MappingModel.Collections.SortType)">
            <summary>
            Use a map collection
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <param name="indexColumnName">Index column name</param>
            <param name="sort">Sorting</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsMap``2(System.String)">
            <summary>
            Use a map collection
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <typeparam name="TComparer">Comparer</typeparam>
            <param name="indexColumnName">Index column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsMap``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Action{FluentNHibernate.Mapping.IndexPart})">
            <summary>
            Use a map collection
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <param name="indexSelector">Index property</param>
            <param name="customIndexMapping">Index mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsMap``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Action{FluentNHibernate.Mapping.IndexPart},FluentNHibernate.MappingModel.Collections.SortType)">
            <summary>
            Use a map collection
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <param name="indexSelector">Index property</param>
            <param name="customIndexMapping">Index mapping</param>
            <param name="sort">Sorting</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsMap``1(System.Action{FluentNHibernate.Mapping.IndexPart},System.Action{FluentNHibernate.Mapping.ElementPart})">
            <summary>
            Use a map collection
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <param name="customIndexMapping">Index mapping</param>
            <param name="customElementMapping">Element mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsArray``1(System.Linq.Expressions.Expression{System.Func{`1,``0}})">
            <summary>
            Use an array
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <param name="indexSelector">Index property</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsArray``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Action{FluentNHibernate.Mapping.IndexPart})">
            <summary>
            Use an array
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <param name="indexSelector">Index property</param>
            <param name="customIndexMapping">Index mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsIndexedCollection``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Action{FluentNHibernate.Mapping.IndexPart})">
            <summary>
            Make this collection indexed
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <param name="indexSelector">Index property</param>
            <param name="customIndexMapping">Index mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.AsIndexedCollection``1(System.String,System.Action{FluentNHibernate.Mapping.IndexPart})">
            <summary>
            Make this collection index
            </summary>
            <typeparam name="TIndex">Index type</typeparam>
            <param name="indexColumn">Index column</param>
            <param name="customIndexMapping">Index mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Element(System.String)">
            <summary>
            Map an element/value type
            </summary>
            <param name="columnName">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Element(System.String,System.Action{FluentNHibernate.Mapping.ElementPart})">
            <summary>
            Map an element/value type
            </summary>
            <param name="columnName">Column name</param>
            <param name="customElementMapping">Custom mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Component(System.Action{FluentNHibernate.Mapping.CompositeElementPart{`1}})">
            <summary>
            Maps this collection as a collection of components.
            </summary>
            <param name="action">Component mapping</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Table(System.String)">
            <summary>
            Sets the table name for this one-to-many.
            </summary>
            <param name="name">Table name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.ForeignKeyCascadeOnDelete">
            <summary>
            Specify that the deletes should be cascaded
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.OptimisticLock">
            <summary>
            Specifies whether this collection should be optimistically locked.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Persister``1">
            <summary>
            Specify a custom persister
            </summary>
            <typeparam name="TPersister">Persister</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Check(System.String)">
            <summary>
            Specify a check constraint
            </summary>
            <param name="constraintName">Constraint name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Generic">
            <summary>
            Specify that this collection is generic (optional)
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Where(System.String)">
            <summary>
            Sets the where clause for this one-to-many relationship.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.BatchSize(System.Int32)">
            <summary>
            Specify the select batch size
            </summary>
            <param name="size">Batch size</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.CollectionType``1">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.CollectionType(System.Type)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.CollectionType(System.String)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.CollectionType(FluentNHibernate.MappingModel.TypeReference)">
            <summary>
            Sets a custom collection type
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.Schema(System.String)">
            <summary>
            Specify the table schema
            </summary>
            <param name="schema">Schema name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.EntityName(System.String)">
            <summary>
            Specifies an entity-name.
            </summary>
            <remarks>See http://nhforge.org/blogs/nhibernate/archive/2008/10/21/entity-name-in-action-a-strongly-typed-entity.aspx</remarks>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.ApplyFilter(System.String,System.String)">
            <overloads>
            Applies a filter to this entity given it's name.
            </overloads>
            <summary>
            Applies a filter to this entity given it's name.
            </summary>
            <param name="name">The filter's name</param>
            <param name="condition">The condition to apply</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.ApplyFilter(System.String)">
            <overloads>
            Applies a filter to this entity given it's name.
            </overloads>
            <summary>
            Applies a filter to this entity given it's name.
            </summary>
            <param name="name">The filter's name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.ApplyFilter``1(System.String)">
            <overloads>
            Applies a named filter to this one-to-many.
            </overloads>
            <summary>
            Applies a named filter to this one-to-many.
            </summary>
            <param name="condition">The condition to apply</param>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ToManyBase`2.ApplyFilter``1">
            <summary>
            Applies a named filter to this one-to-many.
            </summary>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="P:FluentNHibernate.Mapping.ToManyBase`2.EntityType">
            <summary>
            Return the type of the owning entity
            </summary>
            <returns>Type</returns>
        </member>
        <member name="P:FluentNHibernate.Mapping.ToManyBase`2.Cache">
            <summary>
            Specify caching for this entity.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ToManyBase`2.Cascade">
            <summary>
            Specify the cascade behaviour
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ToManyBase`2.Fetch">
            <summary>
            Specify the fetching behaviour
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ToManyBase`2.Access">
            <summary>
            Set the access and naming strategy for this one-to-many.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.ToManyBase`2.Not">
            <summary>
            Inverts the next boolean operation
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.AccessStrategyBuilder`1">
            <summary>
            Access strategy mapping builder.
            </summary>
            <typeparam name="T">Mapping part to be applied to</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.#ctor(`0,System.Action{System.String})">
            <summary>
            Access strategy mapping builder.
            </summary>
            <param name="parent">Instance of the parent mapping part.</param>
            <param name="setter">Setter for altering the model</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Property">
            <summary>
            Sets the access-strategy to property.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Field">
            <summary>
            Sets the access-strategy to field.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.BackingField">
            <summary>
            Sets the access-strategy to use the backing-field of an auto-property.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.ReadOnly">
            <summary>
            Sets the access-strategy to readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.CamelCaseField">
            <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase (field.camelcase).
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.CamelCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.LowerCaseField">
            <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.LowerCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.PascalCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to field and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.ReadOnlyPropertyThroughCamelCaseField">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.ReadOnlyPropertyThroughCamelCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.ReadOnlyPropertyThroughLowerCaseField">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.ReadOnlyPropertyThroughLowerCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.ReadOnlyPropertyThroughPascalCaseField(FluentNHibernate.Mapping.Prefix)">
            <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
            <param name="prefix">Naming-strategy prefix</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Using(System.String)">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <param name="propertyAccessorAssemblyQualifiedClassName">Assembly qualified name of the type to use as the access-strategy</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Using(System.Type)">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <param name="propertyAccessorClassType">Type to use as the access-strategy</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Using``1">
            <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
            <typeparam name="TPropertyAccessorClass">Type to use as the access-strategy</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ComponentPart`1.LazyLoad">
            <summary>
            Specify the lazy-load behaviour
            </summary>
        </member>
        <member name="T:FluentNHibernate.Mapping.CompositeElementPart`1">
            <summary>
            Component-element for component HasMany's.
            </summary>
            <typeparam name="T">Component type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeElementPart`1.Map(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Map a property
            </summary>
            <param name="expression">Property</param>
            <example>
            Map(x => x.Age);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeElementPart`1.Map(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
            <summary>
            Map a property
            </summary>
            <param name="expression">Property</param>
            <param name="columnName">Column name</param>
            <example>
            Map(x => x.Age, "person_age");
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeElementPart`1.References``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Create a reference to another entity. In database terms, this is a many-to-one
            relationship.
            </summary>
            <typeparam name="TOther">Other entity</typeparam>
            <param name="expression">Property on the current entity</param>
            <example>
            References(x => x.Company);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeElementPart`1.References``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String)">
            <summary>
            Create a reference to another entity. In database terms, this is a many-to-one
            relationship.
            </summary>
            <typeparam name="TOther">Other entity</typeparam>
            <param name="expression">Property on the current entity</param>
            <param name="columnName">Column name</param>
            <example>
            References(x => x.Company, "person_company_id");
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeElementPart`1.ParentReference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Maps a property of the component class as a reference back to the containing entity
            </summary>
            <param name="expression">Parent reference property</param>
            <returns>Component being mapped</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeElementPart`1.Component``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Action{FluentNHibernate.Mapping.CompositeElementPart{``0}})">
            <summary>
            Create a nested component mapping.
            </summary>
            <param name="property">Component property</param>
            <param name="nestedCompositeElementAction">Action for creating the component</param>
            <example>
            HasMany(x => x.Locations)
              .Component(c =>
              {
                c.Map(x => x.Name);
                c.Component(x => x.Address, addr =>
                {
                  addr.Map(x => x.Street);
                  addr.Map(x => x.PostCode);
                });
              });
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.KeyProperty(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Defines a property to be used as a key for this composite-id.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <returns>The composite identity part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.KeyProperty(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
            <summary>
            Defines a property to be used as a key for this composite-id with an explicit column name.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <param name="columnName">The column name in the database to use for this key, or null to use the property name</param>
            <returns>The composite identity part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.KeyProperty(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{FluentNHibernate.Mapping.KeyPropertyPart})">
            <summary>
            Defines a property to be used as a key for this composite-id with an explicit column name.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>        
            <param name="keyPropertyAction">Additional settings for the key property</param>
            <returns>The composite identity part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.KeyReference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Defines a reference to be used as a many-to-one key for this composite-id with an explicit column name.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <returns>The composite identity part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.KeyReference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String[])">
            <summary>
            Defines a reference to be used as a many-to-one key for this composite-id with an explicit column name.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <param name="columnNames">A list of column names used for this key</param>
            <returns>The composite identity part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.KeyReference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{FluentNHibernate.Mapping.KeyManyToOnePart},System.String[])">
            <summary>
            Defines a reference to be used as a many-to-one key for this composite-id with an explicit column name.
            </summary>
            <param name="expression">A member access lambda expression for the property</param>
            <param name="customMapping">A lambda expression specifying additional settings for the key reference</param>
            <param name="columnNames">A list of column names used for this key</param>
            <returns>The composite identity part fluent interface</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.Mapped">
            <summary>
            Specifies that this composite id is "mapped"; aka, a composite id where
            the properties exist in the identity class as well as in the entity itself
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.UnsavedValue(System.String)">
            <summary>
            Specifies the unsaved value for the identity
            </summary>
            <param name="value">Unsaved value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.ComponentCompositeIdentifier``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
             <summary>
             You may use a component as an identifier of an entity class. Your component class must
             satisfy certain requirements:
            
               * It must be Serializable.
               * It must re-implement Equals() and GetHashCode(), consistently with the database's
                 notion of composite key equality. 
             
             You can't use an IIdentifierGenerator to generate composite keys. Instead the application
             must assign its own identifiers. Since a composite identifier must be assigned to the object
             before saving it, we can't use unsaved-value of the identifier to distinguish between newly
             instantiated instances and instances saved in a previous session. You may instead implement
             IInterceptor.IsUnsaved() if you wish to use SaveOrUpdate() or cascading save / update. As an
             alternative, you may also set the unsaved-value attribute on a version or timestamp to specify
             a value that indicates a new transient instance. In this case, the version of the entity is
             used instead of the (assigned) identifier and you don't have to implement
             IInterceptor.IsUnsaved() yourself. 
             </summary>
             <param name="expression">The property of component type that holds the composite identifier.</param>        
             <remarks>
             Your persistent class must override Equals() and GetHashCode() to implement composite identifier
             equality. It must also be Serializable.
             </remarks>
        </member>
        <member name="P:FluentNHibernate.Mapping.CompositeIdentityPart`1.Access">
            <summary>
            Set the access and naming strategy for this identity.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.CompositeIdentityPart`1.Not">
            <summary>
            Invert the next boolean operation
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Increment">
            <summary>
            generates identifiers of any integral type that are unique only when no other 
            process is inserting data into the same table. Do not use in a cluster.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Increment(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            generates identifiers of any integral type that are unique only when no other 
            process is inserting data into the same table. Do not use in a cluster.
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Identity">
            <summary>
            supports identity columns in DB2, MySQL, MS SQL Server and Sybase.
            The identifier returned by the database is converted to the property type using 
            Convert.ChangeType. Any integral property type is thus supported.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Identity(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            supports identity columns in DB2, MySQL, MS SQL Server and Sybase.
            The identifier returned by the database is converted to the property type using 
            Convert.ChangeType. Any integral property type is thus supported.
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Sequence(System.String)">
            <summary>
            uses a sequence in DB2, PostgreSQL, Oracle or a generator in Firebird.
            The identifier returned by the database is converted to the property type 
            using Convert.ChangeType. Any integral property type is thus supported.
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Sequence(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses a sequence in DB2, PostgreSQL, Oracle or a generator in Firebird.
            The identifier returned by the database is converted to the property type 
            using Convert.ChangeType. Any integral property type is thus supported.
            </summary>
            <param name="sequenceName"></param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.HiLo(System.String,System.String,System.String,System.String)">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type,
            given a table and column (by default hibernate_unique_key and next_hi respectively)
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="table">The table.</param>
            <param name="column">The column.</param>
            <param name="maxLo">The max lo.</param>
            <param name="where">The where.</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.HiLo(System.String,System.String,System.String)">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="table"></param>
            <param name="column"></param>
            <param name="maxLo"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.HiLo(System.String,System.String,System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="table"></param>
            <param name="column"></param>
            <param name="maxLo"></param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.HiLo(System.String)">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="maxLo"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.HiLo(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
            <param name="maxLo"></param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.SeqHiLo(System.String,System.String)">
            <summary>
            uses an Oracle-style sequence (where supported)
            </summary>
            <param name="sequence"></param>
            <param name="maxLo"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.SeqHiLo(System.String,System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses an Oracle-style sequence (where supported)
            </summary>
            <param name="sequence"></param>
            <param name="maxLo"></param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.UuidHex(System.String)">
            <summary>
            uses System.Guid and its ToString(string format) method to generate identifiers
            of type string. The length of the string returned depends on the configured format. 
            </summary>
            <param name="format">http://msdn.microsoft.com/en-us/library/97af8hh4.aspx</param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.UuidHex(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses System.Guid and its ToString(string format) method to generate identifiers
            of type string. The length of the string returned depends on the configured format. 
            </summary>
            <param name="format">http://msdn.microsoft.com/en-us/library/97af8hh4.aspx</param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.UuidString">
            <summary>
            uses a new System.Guid to create a byte[] that is converted to a string.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.UuidString(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses a new System.Guid to create a byte[] that is converted to a string.  
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Guid">
            <summary>
            uses a new System.Guid as the identifier. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Guid(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses a new System.Guid as the identifier. 
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.GuidComb">
            <summary>
            Recommended for Guid identifiers!
            uses the algorithm to generate a new System.Guid described by Jimmy Nilsson 
            in the article http://www.informit.com/articles/article.asp?p=25862. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.GuidComb(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            Recommended for Guid identifiers!
            uses the algorithm to generate a new System.Guid described by Jimmy Nilsson 
            in the article http://www.informit.com/articles/article.asp?p=25862. 
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Assigned">
            <summary>
            lets the application to assign an identifier to the object before Save() is called. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Assigned(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            lets the application to assign an identifier to the object before Save() is called. 
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Native">
            <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Native(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Native(System.String)">
            <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Native(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Foreign(System.String)">
            <summary>
            uses the identifier of another associated object. Usually used in conjunction with a one-to-one primary key association. 
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Foreign(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            uses the identifier of another associated object. Usually used in conjunction with a one-to-one primary key association. 
            </summary>
            <param name="property"></param>
            <param name="paramValues">Params configuration</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.GuidNative">
            <summary>
            Generator that uses the RDBMS native function to generate a GUID.
            The behavior is similar to the sequence generator. When a new
            object is saved NH run two queries: the first to retrieve the GUID
            value and the second to insert the entity using the Guid retrieved
            from the RDBMS. Your entity Id must be System.Guid and the SQLType
            will depend on the dialect (RAW(16) in Oracle, UniqueIdentifier in
            MsSQL for example).
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.GuidNative(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            Generator that uses the RDBMS native function to generate a GUID.
            The behavior is similar to the sequence generator. When a new
            object is saved NH run two queries: the first to retrieve the GUID
            value and the second to insert the entity using the Guid retrieved
            from the RDBMS. Your entity Id must be System.Guid and the SQLType
            will depend on the dialect (RAW(16) in Oracle, UniqueIdentifier in
            MsSQL for example).
            </summary>
            <example>
                GuidNative(x =>
                {
                  x.AddParam("key", "value");
                });
            </example>
            <param name="paramValues">Parameter builder closure</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Select">
            <summary>
            A deviation of the trigger-identity. This generator works
            together with the <see cref="M:FluentNHibernate.Mapping.ClassMap`1.NaturalId"/> feature.
            The difference with trigger-identity is that the POID value
            is retrieved by a SELECT using the natural-id fields as filter.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Select(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            A deviation of the trigger-identity. This generator works
            together with the <see cref="M:FluentNHibernate.Mapping.ClassMap`1.NaturalId"/> feature.
            The difference with trigger-identity is that the POID value
            is retrieved by a SELECT using the natural-id fields as filter.
            </summary>
            <example>
                Select(x =&gt;
                {
                  x.AddParam("key", "value");
                });
            </example>
            <param name="paramValues">Parameter builder closure</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.SequenceIdentity">
            <summary>
            Based on sequence but works like an identity. The POID
            value is retrieved with an INSERT query. Your entity Id must
            be an integral type.
            "hibernate_sequence" is the default name for the sequence, unless
            another is provided.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.SequenceIdentity(System.String)">
            <summary>
            Based on sequence but works like an identity. The POID
            value is retrieved with an INSERT query. Your entity Id must
            be an integral type.
            "hibernate_sequence" is the default name for the sequence, unless
            another is provided.
            </summary>
            <param name="sequence">Custom sequence name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.SequenceIdentity(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            Based on sequence but works like an identity. The POID
            value is retrieved with an INSERT query. Your entity Id must
            be an integral type.
            "hibernate_sequence" is the default name for the sequence, unless
            another is provided.
            </summary>
            <param name="paramValues">Parameter builder closure</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.SequenceIdentity(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            Based on sequence but works like an identity. The POID
            value is retrieved with an INSERT query. Your entity Id must
            be an integral type.
            "hibernate_sequence" is the default name for the sequence, unless
            another is provided.
            </summary>
            <param name="sequence">Custom sequence name</param>
            <param name="paramValues">Parameter builder closure</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.TriggerIdentity">
            <summary>
            trigger-identity is a NHibernate specific feature where the POID
            is generated by the RDBMS with an INSERT query through a
            BEFORE INSERT trigger. In this case you can use any supported type,
            including a custom type, with the limitation of a single column usage.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.TriggerIdentity(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
            <summary>
            trigger-identity is a NHibernate specific feature where the POID
            is generated by the RDBMS with an INSERT query through a
            BEFORE INSERT trigger. In this case you can use any supported type,
            including a custom type, with the limitation of a single column usage.
            </summary>
            <param name="paramValues">Parameter builder closure</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.UnsavedValue(System.Object)">
            <summary>
            Sets the unsaved-value of the identity.
            </summary>
            <param name="unsavedValue">Value that represents an unsaved value.</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.Column(System.String)">
            <summary>
            Sets the column name for the identity field.
            </summary>
            <param name="columnName">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.Length(System.Int32)">
            <summary>
            Specify the identity column length
            </summary>
            <param name="length">Column length</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.Precision(System.Int32)">
            <summary>
            Specify the decimal precision
            </summary>
            <param name="precision">Decimal precision</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.Scale(System.Int32)">
            <summary>
            Specify the decimal scale
            </summary>
            <param name="scale">Decimal scale</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.Nullable">
            <summary>
            Specify the nullability of the identity column
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.Unique">
            <summary>
            Specify the uniqueness of the identity column
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.UniqueKey(System.String)">
            <summary>
            Specify a unique key constraint
            </summary>
            <param name="keyColumns">Constraint columns</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.CustomSqlType(System.String)">
            <summary>
            Specify a custom SQL type
            </summary>
            <param name="sqlType">SQL type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.Index(System.String)">
            <summary>
            Specify an index name
            </summary>
            <param name="key">Index name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.Check(System.String)">
            <summary>
            Specify a check constraint
            </summary>
            <param name="constraint">Constraint name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.Default(System.Object)">
            <summary>
            Specify a default value
            </summary>
            <param name="value">Default value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.CustomType``1">
            <summary>
            Specify a custom type
            </summary>
            <remarks>
            This is usually used with an <see cref="T:NHibernate.UserTypes.IUserType"/>
            </remarks>
            <typeparam name="T">Custom type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.CustomType(System.Type)">
            <summary>
            Specify a custom type
            </summary>
            <remarks>
            This is usually used with an <see cref="T:NHibernate.UserTypes.IUserType"/>
            </remarks>
            <param name="type">Custom type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.IdentityPart.CustomType(System.String)">
            <summary>
            Specify a custom type
            </summary>
            <remarks>
            This is usually used with an <see cref="T:NHibernate.UserTypes.IUserType"/>
            </remarks>
            <param name="type">Custom type</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.IdentityPart.GeneratedBy">
            <summary>
            Specify the generator
            </summary>
            <example>
            Id("PersonId")
              .GeneratedBy.Assigned();
            </example>
        </member>
        <member name="P:FluentNHibernate.Mapping.IdentityPart.Access">
            <summary>
            Set the access and naming strategy for this identity.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.IdentityPart.Not">
            <summary>
            Invert the next boolean operation
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.ChildKeyColumn(System.String)">
            <summary>
            Sets a single child key column. If there are multiple columns, use ChildKeyColumns.Add
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.ParentKeyColumn(System.String)">
            <summary>
            Sets a single parent key column. If there are multiple columns, use ParentKeyColumns.Add
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.OrderBy(System.String)">
            <summary>
            Sets the order-by clause on the collection element.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.ChildOrderBy(System.String)">
            <summary>
            Sets the order-by clause on the many-to-many element.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.ApplyChildFilter(System.String,System.String)">
            <overloads>
            Applies a filter to the child element of this entity given it's name.
            </overloads>
            <summary>
            Applies a filter to the child element of this entity given it's name.
            </summary>
            <param name="name">The filter's name</param>
            <param name="condition">The condition to apply</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.ApplyChildFilter(System.String)">
            <overloads>
            Applies a filter to the child element of this entity given it's name.
            </overloads>
            <summary>
            Applies a filter to the child element of this entity given it's name.
            </summary>
            <param name="name">The filter's name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.ApplyChildFilter``1(System.String)">
            <overloads>
            Applies a named filter to the child element of this many-to-many.
            </overloads>
            <summary>
            Applies a named filter to the child element of this many-to-many.
            </summary>
            <param name="condition">The condition to apply</param>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.ApplyChildFilter``1">
            <summary>
            Applies a named filter to the child element of this many-to-many.
            </summary>
            <typeparam name="TFilter">
            The type of a <see cref="T:FluentNHibernate.Mapping.FilterDefinition"/> implementation
            defining the filter to apply.
            </typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.ChildWhere(System.String)">
            <summary>
            Sets the where clause for this relationship, on the many-to-many element.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.ChildWhere(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Sets the where clause for this relationship, on the many-to-many element.
            Note: This only supports simple cases, use the string overload for more complex clauses.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.Unique">
            <summary>
            Sets whether this relationship is unique
            </summary>
            <example>
            Unique();
            Not.Unique();
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.UniqueKey(System.String)">
            <summary>
            Specifies the name of a multi-column unique constraint.
            </summary>
            <param name="keyName">Name of constraint</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.Index(System.String)">
            <summary>
            Specifies the index name
            </summary>
            <param name="indexName">Index name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.Class``1">
            <summary>
            Specifies the child class of this relationship
            </summary>
            <typeparam name="T">Child</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.Class(System.Type)">
            <summary>
            Specifies the child class of this relationship
            </summary>
            <param name="type">Child</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.ReadOnly">
            <summary>
            Sets this relationship to read-only
            </summary>
            <remarks>
            This is the same as calling both Not.Insert() and Not.Update()
            </remarks>
            <example>
            ReadOnly();
            Not.ReadOnly();
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.LazyLoad">
            <summary>
            Specify the lazy behaviour of this relationship.
            </summary>
            <remarks>
            Defaults to Proxy lazy-loading. Use the <see cref="P:FluentNHibernate.Mapping.ManyToOnePart`1.Not"/> modifier to disable
            lazy-loading, and use the <see cref="M:FluentNHibernate.Mapping.ManyToOnePart`1.LazyLoad(FluentNHibernate.Mapping.Laziness)"/>
            overload to specify alternative lazy strategies.
            </remarks>
            <example>
            LazyLoad();
            Not.LazyLoad();
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.LazyLoad(FluentNHibernate.Mapping.Laziness)">
            <summary>
            Specify the lazy behaviour of this relationship. Cannot be used
            with the <see cref="P:FluentNHibernate.Mapping.ManyToOnePart`1.Not"/> modifier.
            </summary>
            <param name="laziness">Laziness strategy</param>
            <example>
            LazyLoad(Laziness.NoProxy);
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.ForeignKey">
            <summary>
            Specifies this relationship should be created with a default-named
            foreign key.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.ForeignKey(System.String)">
            <summary>
            Specifies the foreign-key constraint name
            </summary>
            <param name="foreignKeyName">Constraint name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.Insert">
            <summary>
            Specifies that this relationship is insertable
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.Update">
            <summary>
            Specifies that this relationship is updatable
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.Column(System.String)">
            <summary>
            Sets the single column used in this relationship. Use <see cref="M:FluentNHibernate.Mapping.ManyToOnePart`1.Columns(System.String[])"/>
            if you need to specify more than one column.
            </summary>
            <param name="name">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.Columns(System.String[])">
            <summary>
            Specifies the columns used in this relationship
            </summary>
            <param name="newColumns">Columns</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.Columns(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Specifies the columns used in this relationship
            </summary>
            <param name="newColumns">Columns</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.Formula(System.String)">
            <summary>
            Specifies the sql formula used for this relationship
            </summary>
            <param name="formula">Formula</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.PropertyRef(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Specifies the property reference
            </summary>
            <param name="expression">Property</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.PropertyRef(System.String)">
            <summary>
            Specifies the property reference
            </summary>
            <param name="property">Property</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.Nullable">
            <summary>
            Sets this relationship to nullable
            </summary>
            <example>
            Nullable();
            Not.Nullable();
            </example>
        </member>
        <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.EntityName(System.String)">
            <summary>
            Specifies an entity-name.
            </summary>
            <remarks>See http://nhforge.org/blogs/nhibernate/archive/2008/10/21/entity-name-in-action-a-strongly-typed-entity.aspx</remarks>
        </member>
        <member name="P:FluentNHibernate.Mapping.ManyToOnePart`1.Fetch">
            <summary>
            Set the fetching strategy
            </summary>
            <example>
            Fetch.Select();
            </example>
        </member>
        <member name="P:FluentNHibernate.Mapping.ManyToOnePart`1.NotFound">
            <summary>
            Set the behaviour for when this relationship is null in the database
            </summary>
            <example>
            NotFound.Exception();
            </example>
        </member>
        <member name="P:FluentNHibernate.Mapping.ManyToOnePart`1.Cascade">
            <summary>
            Specifies the cascade behaviour for this relationship
            </summary>
            <example>
            Cascade.All();
            </example>
        </member>
        <member name="P:FluentNHibernate.Mapping.ManyToOnePart`1.Access">
            <summary>
            Specifies the access strategy for this relationship
            </summary>
            <example>
            Access.Field();
            </example>
        </member>
        <member name="P:FluentNHibernate.Mapping.ManyToOnePart`1.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.AsTernaryAssociation">
            <summary>
            Specify that this is a ternary association
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.AsTernaryAssociation(System.String)">
            <summary>
            Specify that this is a ternary association
            </summary>
            <param name="indexColumnName">Index column</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.AsEntityMap">
            <summary>
            Specify this as an entity map
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.AsEntityMap(System.String)">
            <summary>
            Specify this as an entity map
            </summary>
            <param name="indexColumnName">Index column</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.KeyColumn(System.String)">
            <summary>
            Specify the key column name
            </summary>
            <param name="columnName">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.ForeignKeyConstraintName(System.String)">
            <summary>
            Specify a foreign key constraint
            </summary>
            <param name="foreignKeyName">Constraint name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.OrderBy(System.String)">
            <summary>
            Sets the order-by clause for this one-to-many relationship.
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.ReadOnly">
            <summary>
            Specify that this collection is read-only
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.Subselect(System.String)">
            <summary>
            Specify a sub-select query for fetching this collection
            </summary>
            <param name="subselect">Query</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.KeyUpdate">
            <summary>
            Specify that the key is updatable
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.KeyNullable">
            <summary>
            Specify that the key is nullable
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.Where(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Sets the where clause for this one-to-many relationship.
            Note: This only supports simple cases, use the string overload for more complex clauses.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.OneToManyPart`1.NotFound">
            <summary>
            Specifies the behaviour for if this collection is not found
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.OneToManyPart`1.Cascade">
            <summary>
            Specify the cascade behaviour
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.OneToManyPart`1.KeyColumns">
            <summary>
            Modify the key columns collection
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Column(System.String)">
            <summary>
            Specify the property column name
            </summary>
            <param name="columnName">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Insert">
            <summary>
            Specify that this property is insertable
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Update">
            <summary>
            Specify that this property is updatable
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Length(System.Int32)">
            <summary>
            Specify the column length
            </summary>
            <param name="length">Column length</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Nullable">
            <summary>
            Specify the nullability of this property
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.ReadOnly">
            <summary>
            Specify that this property is read-only
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Formula(System.String)">
            <summary>
            Specify the property formula
            </summary>
            <param name="formula">Formula</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.LazyLoad">
            <summary>
            Specify the lazy-loading behaviour
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Index(System.String)">
            <summary>
            Specify an index name
            </summary>
            <param name="index">Index name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.CustomType``1">
            <summary>
            Specifies that a custom type (an implementation of <see cref="T:NHibernate.UserTypes.IUserType"/>) should be used for this property for mapping it to/from one or more database columns whose format or type doesn't match this .NET property.
            </summary>
            <typeparam name="TCustomtype">A type which implements <see cref="T:NHibernate.UserTypes.IUserType"/>.</typeparam>
            <returns>This property mapping to continue the method chain</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.CustomType(System.Type)">
            <summary>
            Specifies that a custom type (an implementation of <see cref="T:NHibernate.UserTypes.IUserType"/>) should be used for this property for mapping it to/from one or more database columns whose format or type doesn't match this .NET property.
            </summary>
            <param name="type">A type which implements <see cref="T:NHibernate.UserTypes.IUserType"/>.</param>
            <returns>This property mapping to continue the method chain</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.CustomType(System.String)">
            <summary>
            Specifies that a custom type (an implementation of <see cref="T:NHibernate.UserTypes.IUserType"/>) should be used for this property for mapping it to/from one or more database columns whose format or type doesn't match this .NET property.
            </summary>
            <param name="type">A type which implements <see cref="T:NHibernate.UserTypes.IUserType"/>.</param>
            <returns>This property mapping to continue the method chain</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.CustomType(System.Func{System.Type,System.Type})">
            <summary>
            Specifies that a custom type (an implementation of <see cref="T:NHibernate.UserTypes.IUserType"/>) should be used for this property for mapping it to/from one or more database columns whose format or type doesn't match this .NET property.
            </summary>
            <param name="typeFunc">A function which returns a type which implements <see cref="T:NHibernate.UserTypes.IUserType"/>. The argument of the function is the mapped property type</param>
            <returns>This property mapping to continue the method chain</returns>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.CustomSqlType(System.String)">
            <summary>
            Specify a custom SQL type
            </summary>
            <param name="sqlType">SQL type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Unique">
            <summary>
            Specify that this property has a unique constranit
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Precision(System.Int32)">
            <summary>
            Specify decimal precision
            </summary>
            <param name="precision">Decimal precision</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Scale(System.Int32)">
            <summary>
            Specify decimal scale
            </summary>
            <param name="scale">Decimal scale</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Default(System.String)">
            <summary>
            Specify a default value
            </summary>
            <param name="value">Default value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.UniqueKey(System.String)">
            <summary>
            Specifies the name of a multi-column unique constraint.
            </summary>
            <param name="keyName">Name of constraint</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.OptimisticLock">
            <summary>
            Specify that this property is optimistically locked
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.PropertyPart.Check(System.String)">
            <summary>
            Specify a check constraint
            </summary>
            <param name="constraint">Constraint name</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.PropertyPart.Generated">
            <summary>
            Specify if this property is database generated
            </summary>
            <example>
            Generated.Insert();
            </example>
        </member>
        <member name="P:FluentNHibernate.Mapping.PropertyPart.Columns">
            <summary>
            Modify the columns collection
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.PropertyPart.Access">
            <summary>
            Set the access and naming strategy for this property.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.PropertyPart.Not">
            <summary>
            Inverts the next boolean
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.Column(System.String)">
            <summary>
            Specify the column name
            </summary>
            <param name="name">Column name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.UnsavedValue(System.String)">
            <summary>
            Specify the unsaved value
            </summary>
            <param name="value">Unsaved value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.Length(System.Int32)">
            <summary>
            Specify the column length
            </summary>
            <param name="length">Column length</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.Precision(System.Int32)">
            <summary>
            Specify decimal precision
            </summary>
            <param name="precision">Decimal precision</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.Scale(System.Int32)">
            <summary>
            Specify decimal scale
            </summary>
            <param name="scale">Decimal scale</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.Nullable">
            <summary>
            Specify the nullability of the column
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.Unique">
            <summary>
            Specify the uniqueness of the column
            </summary>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.UniqueKey(System.String)">
            <summary>
            Specify a unique key constraint
            </summary>
            <param name="keyColumns">Constraint columns</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.Index(System.String)">
            <summary>
            Specify an index name
            </summary>
            <param name="index">Index name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.Check(System.String)">
            <summary>
            Specify a check constraint
            </summary>
            <param name="constraint">Constraint name</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.Default(System.Object)">
            <summary>
            Specify a default value
            </summary>
            <param name="value">Default value</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.CustomType``1">
            <summary>
            Specify a custom type
            </summary>
            <remarks>Usually used with an <see cref="T:NHibernate.UserTypes.IUserType"/></remarks>
            <typeparam name="T">Custom type</typeparam>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.CustomType(System.Type)">
            <summary>
            Specify a custom type
            </summary>
            <remarks>Usually used with an <see cref="T:NHibernate.UserTypes.IUserType"/></remarks>
            <param name="type">Custom type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.CustomType(System.String)">
            <summary>
            Specify a custom type
            </summary>
            <remarks>Usually used with an <see cref="T:NHibernate.UserTypes.IUserType"/></remarks>
            <param name="type">Custom type</param>
        </member>
        <member name="M:FluentNHibernate.Mapping.VersionPart.CustomSqlType(System.String)">
            <summary>
            Specify a custom SQL type
            </summary>
            <param name="sqlType">SQL type</param>
        </member>
        <member name="P:FluentNHibernate.Mapping.VersionPart.Generated">
            <summary>
            Specify if this version is database generated
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.VersionPart.Access">
            <summary>
            Specify the access strategy
            </summary>
        </member>
        <member name="P:FluentNHibernate.Mapping.VersionPart.Not">
            <summary>
            Invert the next boolean operation
            </summary>
        </member>
        <member name="M:FluentNHibernate.Reveal.Member``1(System.String)">
            <summary>
            Reveals a hidden property or field for use instead of expressions.
            </summary>
            <typeparam name="TEntity">Entity type</typeparam>
            <param name="name">Name of property or field</param>
            <returns>Expression for the hidden property or field</returns>
        </member>
        <member name="M:FluentNHibernate.Reveal.Member``2(System.String)">
            <summary>
            Reveals a hidden property or field with a specific return type for use instead of expressions.
            </summary>
            <typeparam name="TEntity">Entity type</typeparam>
            <typeparam name="TReturn">Property or field return type</typeparam>
            <param name="name">Name of property or field</param>
            <returns>Expression for the hidden property or field</returns>
        </member>
        <member name="T:FluentNHibernate.Visitors.ValidationVisitor">
            <summary>
            Visitor that performs validation against the mapping model.
            </summary>
        </member>
        <member name="P:FluentNHibernate.Visitors.ValidationVisitor.Enabled">
            <summary>
            Gets or sets whether validation is performed.
            </summary>
        </member>
    </members>
</doc>
