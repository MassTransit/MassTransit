<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.Windsor</name>
    </assembly>
    <members>
        <member name="T:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator">
            <summary>
              Attempts to dynamically load a UserControl by invoking Page.LoadControl.  
              There are two uses of this class.  
              <para>
                1) Add a component to the Kernel and add a VirtualPath attribute specifying 
                the relative path of the .ascx file for the associated UserControl. (easy)
              </para>
              <example>
                <code>
                  &lt;component id="BasketView" 
                  service="Castle.ShoppingCart.IBasketView, Castle.ShoppingCart"
                  type="Castle.ShoppingCart.BasketView, Castle.ShoppingCart" 
                  lifestyle="transient"
                  virtualPath="~/Views/BasketView.ascx"
                  /&gt;
                </code>
              </example>
              <para>
                2) Precompile a UserControl and add the pre-compiled class to the Kernel. (hard)  
                Has not been tested with proxies.
              </para>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator">
            <summary>
              Standard implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>.
              Handles the selection of the best constructor, fills the
              writable properties the component exposes, run the commission 
              and decommission lifecycles, etc.
            </summary>
            <remarks>
              Custom implementors can just override the <c>CreateInstance</c> method.
              Please note however that the activator is responsible for the proxy creation
              when needed.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator">
            <summary>
              Abstract implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>.
              The implementors must only override the InternalCreate and 
              InternalDestroy methods in order to perform their creation and
              destruction logic.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IComponentActivator">
            <summary>
              Implements the instance creation logic. The default
              implementation should rely on an ordinary call to 
              Activator.CreateInstance().
            </summary>
            <remarks>
              This interface is provided in order to allow custom components
              to be created using a different logic, such as using a specific factory
              or builder.
              <para>
                The constructor for implementation has the following signature:
              </para>
              <code>
                ComponentModel model, IKernel kernel, 
                ComponentInstanceDelegate onCreation, 
                ComponentInstanceDelegate onDestruction
              </code>
              <para>
                The Activator should raise the events onCreation and onDestruction
                in order to correctly implement the contract. Usually the best
                way of creating a custom activator is by extending the existing ones.
              </para>
              <seealso cref="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator"/>
              <seealso cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator"/>
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IComponentActivator.Create(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.Burden)">
            <summary>
              Should return a new component instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IComponentActivator.Destroy(System.Object)">
            <summary>
              Should perform all necessary work to dispose the instance
              and/or any resource related to it.
            </summary>
            <param name = "instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
              Constructs an AbstractComponentActivator
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator"/> class.
            </summary>
            <param name="model"></param>
            <param name="kernel"></param>
            <param name="onCreation"></param>
            <param name="onDestruction"></param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The on creation.</param>
            <param name="onDestruction">The on destruction.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator.CreateInstance(Castle.MicroKernel.Context.CreationContext,Castle.Core.ConstructorCandidate,System.Object[])">
            <summary>
              Creates the instance.
            </summary>
            <param name = "context">The context.</param>
            <param name = "constructor"></param>
            <param name = "arguments">The arguments.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.Core.BoundToAttribute">
            <summary>
              Indicates that the target components wants instance lifetime and reuse scope to be bound to another component further up the object graph.
              Good scenario for this would be unit of work bound to a presenter in a two tier MVP application.
              The <see cref="P:Castle.Core.BoundToAttribute.ScopeRootBinderType"/> attribute must point to a type
              having default accessible constructor and public method matching signature of <code>Func&lt;IHandler[], IHandler&gt;</code> delegate.
            </summary>
        </member>
        <member name="T:Castle.Core.LifestyleAttribute">
            <summary>
              Base for Attributes that want to express lifestyle
              chosen by the component.
            </summary>
        </member>
        <member name="M:Castle.Core.LifestyleAttribute.#ctor(Castle.Core.LifestyleType)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.LifestyleAttribute"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="P:Castle.Core.LifestyleAttribute.Lifestyle">
            <summary>
              Gets or sets the lifestyle.
            </summary>
            <value>The lifestyle.</value>
        </member>
        <member name="M:Castle.Core.BoundToAttribute.#ctor(System.Type)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.BoundToAttribute"/> class.
            </summary>
            <param name="scopeRootBinderType">type having default accessible constructor and public method matching signature of <code>Func&lt;IHandler[], IHandler&gt;</code> delegate. The method will be used to pick <see cref="T:Castle.MicroKernel.IHandler"/> of the component current instance should be bound to.</param>
        </member>
        <member name="P:Castle.Core.BoundToAttribute.ScopeRootBinderType">
            <summary>
              type having default accessible constructor and public method matching signature of <code>Func&lt;IHandler[], IHandler&gt;</code> delegate. The method will be used to pick <see cref="T:Castle.MicroKernel.IHandler"/> of the component current instance should be bound to.
            </summary>
        </member>
        <member name="T:Castle.Core.DependencyModel">
            <summary>
              Represents a dependency (other component or a 
              fixed value available through external configuration).
            </summary>
        </member>
        <member name="M:Castle.Core.DependencyModel.#ctor(System.String,System.Type,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.DependencyModel"/> class.
            </summary>
            <param name="dependencyKey">The dependency key.</param>
            <param name="targetType">Type of the target.</param>
            <param name="isOptional">if set to <c>true</c> [is optional].</param>
        </member>
        <member name="M:Castle.Core.DependencyModel.ToString">
            <summary>
              Returns a <see cref = "T:System.String" /> that represents the current <see cref = "T:System.Object" />.
            </summary>
            <returns>
              A <see cref = "T:System.String" /> that represents the current <see cref = "T:System.Object" />.
            </returns>
        </member>
        <member name="P:Castle.Core.DependencyModel.DependencyKey">
            <summary>
              Gets or sets the dependency key.
            </summary>
            <value>The dependency key.</value>
        </member>
        <member name="P:Castle.Core.DependencyModel.IsOptional">
            <summary>
              Gets or sets whether this dependency is optional.
            </summary>
            <value>
              <c>true</c> if this dependency is optional; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.DependencyModel.TargetItemType">
            <summary>
              Gets the service type of the dependency.
              This is the same type as <see cref="P:Castle.Core.DependencyModel.TargetType"/> or if <see cref="P:Castle.Core.DependencyModel.TargetType"/> is by ref,
              then it's the element type of the reference. (in other words if dependency 
              is <c>out IFoo foo</c> this will be <c>IFoo</c>, while <see cref="P:Castle.Core.DependencyModel.TargetType"/> will be <c>&amp;IFoo</c>);
            </summary>
        </member>
        <member name="P:Castle.Core.DependencyModel.TargetType">
            <summary>
              Gets the type of the target.
            </summary>
            <value>The type of the target.</value>
        </member>
        <member name="T:Castle.Core.CustomLifestyleAttribute">
            <summary>
              Indicates that the target components wants a
              custom lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.CustomLifestyleAttribute.#ctor(System.Type)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.CustomLifestyleAttribute"/> class.
            </summary>
            <param name="lifestyleHandlerType">The lifestyle handler.</param>
        </member>
        <member name="P:Castle.Core.CustomLifestyleAttribute.LifestyleHandlerType">
            <summary>
              Gets the type of the lifestyle handler.
            </summary>
            <value>The type of the lifestyle handler.</value>
        </member>
        <member name="T:Castle.Core.CastleComponentAttribute">
            <summary>
              This attribute is useful only when you want to register all components
              on an assembly as a batch process. 
              By doing so, the batch register will look 
              for this attribute to distinguish components from other classes.
            </summary>
        </member>
        <member name="T:Castle.Core.ComponentActivatorAttribute">
            <summary>
              Associates a custom activator with a component
            </summary>
        </member>
        <member name="M:Castle.Core.ComponentActivatorAttribute.#ctor(System.Type)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ComponentActivatorAttribute"/> class.
            </summary>
            <param name="componentActivatorType">Type of the component activator.</param>
        </member>
        <member name="P:Castle.Core.ComponentActivatorAttribute.ComponentActivatorType">
            <summary>
              Gets the type of the component activator.
            </summary>
            <value>The type of the component activator.</value>
        </member>
        <member name="M:Castle.Core.ComponentName.DefaultFor(System.Type)">
            <summary>
              Gets the default name for component implemented by <paramref name = "componentType" /> which will be used in case when user does not provide one explicitly.
            </summary>
            <param name = "componentType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.ComponentName.DefaultNameFor(System.Type)">
            <summary>
              Gets the default name for component implemented by <paramref name = "componentType" /> which will be used in case when user does not provide one explicitly.
            </summary>
            <param name = "componentType"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.Core.ComponentProxyBehaviorAttribute">
            <summary>
              Specifies the proxying behavior for a component.
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.UseMarshalByRefProxy">
            <summary>
              Gets or sets a value indicating whether the generated 
              interface proxy should inherit from <see cref="T:System.MarshalByRefObject"/>.
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.AdditionalInterfaces">
            <summary>
              Gets or sets the additional interfaces used during proxy generation.
            </summary>
        </member>
        <member name="T:Castle.Core.DoNotWireAttribute">
            <summary>
              Marks as property to be skipped and not be wired
              by the IoC container
            </summary>
        </member>
        <member name="T:Castle.Core.ICommissionConcern">
            <summary>
              Represents a concern that will be applied to a component instance
              during commission phase (right after component instance is activated).
            </summary>
        </member>
        <member name="M:Castle.Core.ICommissionConcern.Apply(Castle.Core.ComponentModel,System.Object)">
            <summary>
              Implementors should act on the instance in response to 
              a commission phase.
            </summary>
            <param name = "model">The model.</param>
            <param name = "component">The component.</param>
        </member>
        <member name="T:Castle.Core.IDecommissionConcern">
            <summary>
              Represents a concern that will be applied to a component instance
              during decommission phase (right before component instance is destroyed).
            </summary>
        </member>
        <member name="M:Castle.Core.IDecommissionConcern.Apply(Castle.Core.ComponentModel,System.Object)">
            <summary>
              Implementors should act on the instance in response to 
              a decommission phase.
            </summary>
            <param name = "model">The model.</param>
            <param name = "component">The component.</param>
        </member>
        <member name="T:Castle.Core.IInitializable">
            <summary>
              Lifecycle interface. If implemented by a component,
              the method Initialized will be invoked by the container
              before making the component available to the external world.
            </summary>
        </member>
        <member name="M:Castle.Core.IInitializable.Initialize">
            <summary>
              Implementors should perform any initialization logic.
            </summary>
        </member>
        <member name="T:Castle.Core.InterceptorAttribute">
            <summary>
              Used to declare that a component wants interceptors acting on it.
            </summary>
        </member>
        <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.String)">
            <summary>
              Constructs the InterceptorAttribute pointing to
              a key to a interceptor
            </summary>
            <param name = "componentKey"></param>
        </member>
        <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.Type)">
            <summary>
              Constructs the InterceptorAttribute pointing to
              a service
            </summary>
            <param name = "interceptorType"></param>
        </member>
        <member name="T:Castle.Core.Internal.SimpleThreadSafeDictionary`2">
            <summary>
              Simple type for thread safe adding/reading to/from keyed store.
              The difference between this and built in concurrent dictionary is that in this case
              adding is happening under a lock so never more than one thread will be adding at a time.
            </summary>
            <typeparam name = "TKey"></typeparam>
            <typeparam name = "TValue"></typeparam>
        </member>
        <member name="M:Castle.Core.Internal.SimpleThreadSafeDictionary`2.Dispose">
            <summary>
              returns all values and clears the dictionary
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Internal.StringExtensions.EqualsText(System.String,System.String)">
            <summary>
              Performs string comparison using <see cref="P:System.StringComparer.OrdinalIgnoreCase"/>
            </summary>
            <param name="one"></param>
            <param name="two"></param>
            <returns></returns>
        </member>
        <member name="F:Castle.Core.Internal.ThreadSafeFlag.signaled">
            <summary>
              0 == false, 1 = =true
            </summary>
        </member>
        <member name="M:Castle.Core.Internal.ThreadSafeFlag.Signal">
            <summary>
              Signals (sets) the flag.
            </summary>
            <returns><c>true</c> if the current thread signaled the flag, <c>false</c> if some other thread signaled the flag before.</returns>
        </member>
        <member name="T:Castle.Core.Internal.LateBoundComponent">
            <summary>
              Marker class used to denote components that have late bound type
              That is the actual type is not known exactly at the time when <see cref="T:Castle.Core.ComponentModel"/>
              is created. Those are for example components instantiated via abstract factory.
            </summary>
        </member>
        <member name="M:Castle.Core.Internal.ReflectionUtil.GetCompatibleArrayItemType(System.Type)">
            <summary>
              If the extended type is a Foo[] or IEnumerable{Foo} which is assignable from Foo[] this method will return typeof(Foo)
              otherwise <c>null</c>.
            </summary>
            <param name = "type"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.Core.LifestyleType">
            <summary>
              Enumeration used to mark the component's lifestyle.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Undefined">
            <summary>
              No lifestyle specified.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Singleton">
            <summary>
              Singleton components are instantiated once, and shared
              between all clients.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Thread">
            <summary>
              Thread components have a unique instance per thread.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Transient">
            <summary>
              Transient components are created on demand.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Pooled">
            <summary>
              Optimization of transient components that keeps
              instance in a pool instead of always creating them.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.PerWebRequest">
            <summary>
              PerWebRequest components are created once per Http Request
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Custom">
            <summary>
              Any other logic to create/release components.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Scoped">
            <summary>
              Instances are reused within the scope provided.
            </summary>
        </member>
        <member name="F:Castle.Core.LifestyleType.Bound">
            <summary>
              Instance lifetime and reuse scope is bound to another component further up the object graph.
              Good scenario for this would be unit of work bound to a presenter in a two tier MVP application.
              When specified in xml a <c>scopeRootBinderType</c> attribute must be specified pointing to a type
              having default accessible constructor and public method matching signature of <code>Func&lt;IHandler[], IHandler&gt;</code> delegate.
            </summary>
        </member>
        <member name="T:Castle.Core.PerThreadAttribute">
            <summary>
              Indicates that the target components wants a
              per thread lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.PerThreadAttribute.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.PerThreadAttribute"/> class.
            </summary>
        </member>
        <member name="T:Castle.Core.PerWebRequestAttribute">
            <summary>
              Indicates that the target components wants a
              per web request lifestyle.
            </summary>
        </member>
        <member name="T:Castle.Core.PooledAttribute">
            <summary>
              Indicates that the target components wants a
              pooled lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.PooledAttribute.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute"/> class
              using the default initial pool size (5) and the max pool size (15).
            </summary>
        </member>
        <member name="M:Castle.Core.PooledAttribute.#ctor(System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute"/> class.
            </summary>
            <param name="initialPoolSize">Initial size of the pool.</param>
            <param name="maxPoolSize">Max pool size.</param>
        </member>
        <member name="P:Castle.Core.PooledAttribute.InitialPoolSize">
            <summary>
              Gets the initial size of the pool.
            </summary>
            <value>The initial size of the pool.</value>
        </member>
        <member name="P:Castle.Core.PooledAttribute.MaxPoolSize">
            <summary>
              Gets the maximum pool size.
            </summary>
            <value>The size of the max pool.</value>
        </member>
        <member name="T:Castle.Core.PropertyFilter">
            <summary>
              Specifies rules for designating settable properties on a component as dependencies, and controlling whether they are requred or not.
              This is a shortcut for most common scenarios. More advanced/custom scenarios can be defined dynamically in the registration API.
            </summary>
        </member>
        <member name="F:Castle.Core.PropertyFilter.Default">
            <summary>
              Takes no action. By default that means all settable properties will be exposed as optional dependencies.
            </summary>
        </member>
        <member name="F:Castle.Core.PropertyFilter.RequireAll">
            <summary>
              Makes all property dependencies required.
            </summary>
        </member>
        <member name="F:Castle.Core.PropertyFilter.RequireBase">
            <summary>
              Makes all property dependencies defined at a base class/interfaces level required.
            </summary>
        </member>
        <member name="F:Castle.Core.PropertyFilter.IgnoreAll">
            <summary>
              Makes all properties ignored.
            </summary>
        </member>
        <member name="F:Castle.Core.PropertyFilter.IgnoreBase">
            <summary>
              Ignores all properties defined at a base class/interface level.
            </summary>
            <remarks>
              This option is particularily useful in scenarios like UI controls which in .NET UI frameworks tend to have byzantine inheritance hierarchies.
            </remarks>
        </member>
        <member name="T:Castle.Core.ScopedAttribute">
            <summary>
              Indicates that the target components wants a
              per thread lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.ScopedAttribute.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.PerThreadAttribute"/> class.
            </summary>
        </member>
        <member name="T:Castle.Core.SingletonAttribute">
            <summary>
              Indicates that the target components wants a
              singleton lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.SingletonAttribute.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.SingletonAttribute"/> class.
            </summary>
        </member>
        <member name="T:Castle.Core.TransientAttribute">
            <summary>
              Indicates that the target components wants a
              transient lifestyle.
            </summary>
        </member>
        <member name="M:Castle.Core.TransientAttribute.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.TransientAttribute"/> class.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction">
            <summary>
              Implementors must inspect the component for 
              a given information or parameter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Usually the implementation will look in the configuration property 
              of the model or the service interface, or the implementation looking for
              something.
            </summary>
            <param name = "kernel">The kernel instance</param>
            <param name = "model">The component model</param>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector.SelectComponent(System.Reflection.MethodInfo,System.Type,System.Object[])">
            <summary>
              Selects one or both of component name and type, for given method 
              called on given typed factory type.
              When component should be requested by type only,
              componentName should be null.
              When component should be requested by name only,
              componentType should be null.
            </summary>
            <param name = "method"></param>
            <param name = "type"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.#ctor(System.Boolean,System.Boolean)">
            <param name = "getMethodsResolveByName">If set to <c>true</c>, all methods with names like 'GetSomething' will try to resolve by name component 'something'. Defaults to <c>true</c>.</param>
            <param name = "fallbackToResolveByTypeIfNameNotFound">If set to <c>true</c>, will fallback to resolving by type, if can not find component with specified name. This property is here for backward compatibility. It is recommended not to use it. Defaults to <c>false</c>.</param>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.BuildFactoryComponent(System.Reflection.MethodInfo,System.String,System.Type,System.Collections.IDictionary)">
            <summary>
              Builds <see cref="T:Castle.Facilities.TypedFactory.TypedFactoryComponentResolver"/> for given call.
              By default if <paramref name="componentType"/> is a collection
              returns factory calling <see cref="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type)"/> on collection's item type,
              otherwise standard <see cref="T:Castle.Facilities.TypedFactory.TypedFactoryComponentResolver"/>.
            </summary>
            <param name="method"></param>
            <param name="componentName"></param>
            <param name="componentType"></param>
            <param name="additionalArguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.GetArguments(System.Reflection.MethodInfo,System.Object[])">
            <summary>
              Selects arguments to be passed to resolution pipeline.
              By default passes all given <paramref name = "arguments" /> 
              keyed by names of their corresponding <paramref name = "method" /> parameters.
            </summary>
            <param name = "method"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.GetComponentName(System.Reflection.MethodInfo,System.Object[])">
            <summary>
              Selects name of the component to resolve.
              If <paramref name = "method" /> Name is GetFoo returns "Foo", otherwise <c>null</c>.
            </summary>
            <param name = "method"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.GetComponentType(System.Reflection.MethodInfo,System.Object[])">
            <summary>
              Selects type of the component to resolve. Uses <paramref name = "method" /> return type.
            </summary>
            <param name = "method"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.FallbackToResolveByTypeIfNameNotFound">
            <summary>
              If set to <c>true</c>, will fallback to resolving by type, if can not find component with specified name. This property is here for backward compatibility. It is recommended not to use it.
            </summary>
        </member>
        <member name="P:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.GetMethodsResolveByName">
            <summary>
              If set to <c>true</c>, all methods with names like 'GetSomething' will try to resolve by name component 'something'.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.IDependencyAwareActivator">
            <summary>
            Implemented by <see cref="T:Castle.MicroKernel.IComponentActivator"/> which don't necessarily need dependencies from the container to activate new instances of the component.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.IDependencyAwareActivator.CanProvideRequiredDependencies(Castle.Core.ComponentModel)">
            <summary>
            Should return <c>true</c> if the activator can provide dependencies for the <paramref name="component"/>.
            </summary>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.IDependencyAwareActivator.IsManagedExternally(Castle.Core.ComponentModel)">
            <summary>
            Should return <c>true</c> if the activated instances of the <see cref="T:Castle.Core.ComponentModel"/> are managed externally to the container. That means container will not try to track the objects in <see cref="T:Castle.MicroKernel.IReleasePolicy"/>.
            </summary>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.ILazyComponentLoader">
            <summary>
              Provides lazy registration capabilities to the container.
            </summary>
            <remarks>
              When a component is requested from a container and it was not registered, 
              container loads up all registered implementers of this interface and asks 
              them in turn whether they can provide that component, until it finds one that will.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.ILazyComponentLoader.Load(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
              Used by container to allow the loader to register component for given <paramref name = "name" /> and <paramref
               name = "service" /> to the container at the time when it is requested
            </summary>
            <param name = "name">Name of the requested component or null</param>
            <param name = "service">Type of requested service or null</param>
            <param name = "arguments">User supplied arguments or null</param>
            <returns>Registration that registers component for given key and/or service or null.</returns>
            <remarks>
              While either key or service can be null reference it is guaranteed that at least one of them will not be null.
              When implementer opts in to provide the requested component (by returning not-null registration) it is required
              to register component for requested key/service combination (when one of the elements is null, it should be ignored as well).
              When implementer does not want to register the requested component it must return null.
            </remarks>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.FactoryAttribute">
            <summary>
              Specifies default configuration for a typed factory. All Selector* properties are mutually exclusive, that is you're only meant to set one.
            </summary>
        </member>
        <member name="P:Castle.Facilities.TypedFactory.FactoryAttribute.SelectorComponentName">
            <summary>
              Specifies component to use as selector for given factory. This works like any named service override.
            </summary>
        </member>
        <member name="P:Castle.Facilities.TypedFactory.FactoryAttribute.SelectorComponentType">
            <summary>
              Specifies component to use as selector for given factory. This works like any typed service override.
            </summary>
        </member>
        <member name="P:Castle.Facilities.TypedFactory.FactoryAttribute.SelectorType">
            <summary>
              Specifies type of the selector to use for given factory. The type will be instantiated using default constructor. It must implement <see cref="T:Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.ComponentActivatorException">
            <summary>
              Exception thrown whe a component could not be activated. THis should come from the component activator.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentResolutionException">
            <summary>
              Exception thrown when resolution process for a component was unsuccessful at some point for whatever reason.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Burden.RequiresPolicyRelease">
            <summary>
              If
              <c>true</c>
              requires release by
              <see cref="T:Castle.MicroKernel.IReleasePolicy"/>
              . If
              <c>false</c>
              , the object has a well defined, detectable end of life (web-request end, disposal of the container etc), and will be released externally.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Arguments">
            <summary>
              Represents collection of arguments used when resolving a component.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.NoResolvableConstructorFoundException">
            <summary>
              Exception thrown when component has no resolvable constructor that can be used to create an instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.HandlerState">
            <summary>
              Possible states for a IHandler instance
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.HandlerState.Valid">
            <summary>
              The component can be requested
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.HandlerState.WaitingDependency">
            <summary>
              The component can not be requested 
              as it still depending on a external 
              dependency not yet available
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.IDependencyInspector">
            <summary>
              Inspects missings dependencies in the container. Default implementation is used to
              construct helpful message for exceptions and debugger views, but other implementations
              are also possible if needed.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultHandler">
            <summary>
              Summary description for DefaultHandler.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.AbstractHandler">
            <summary>
              Implements the basis of
              <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandler">
            <summary>
              Contract for the IHandler, which manages an
              component state and coordinates its creation 
              and destruction (dispatching to activators, lifestyle managers)
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ISubDependencyResolver">
            <summary>
              Implementors should use a strategy to obtain 
              valid references to properties and/or services 
              requested in the dependency model.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ISubDependencyResolver.CanResolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
              Returns true if the resolver is able to satisfy this dependency.
            </summary>
            <param name = "context">Creation context, which is a resolver itself</param>
            <param name = "contextHandlerResolver">Parent resolver - normally the IHandler implementation</param>
            <param name = "model">Model of the component that is requesting the dependency</param>
            <param name = "dependency">The dependency model</param>
            <returns><c>true</c> if the dependency can be satisfied</returns>
        </member>
        <member name="M:Castle.MicroKernel.ISubDependencyResolver.Resolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
              Should return an instance of a service or property values as
              specified by the dependency model instance. 
              It is also the responsibility of <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
              to throw an exception in the case a non-optional dependency 
              could not be resolved.
            </summary>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="contextHandlerResolver">Parent resolver - normally the IHandler implementation</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns>The dependency resolved value or null</returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Init(Castle.MicroKernel.IKernelInternal)">
            <summary>
              Initializes the handler with a reference to the
              kernel.
            </summary>
            <param name = "kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.IsBeingResolvedInContext(Castle.MicroKernel.Context.CreationContext)">
            <summary>
              Tests whether the handler is already being resolved in given context.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Release(Castle.MicroKernel.Burden)">
            <summary>
              Implementors should dispose the component instance
            </summary>
            <param name = "burden"></param>
            <returns>true if destroyed.</returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Resolve(Castle.MicroKernel.Context.CreationContext)">
            <summary>
              Implementors should return a valid instance 
              for the component the handler is responsible.
              It should throw an exception in the case the component
              can't be created for some reason
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Supports(System.Type)">
            <summary>
              Returns true if this handler supports <paramref name = "service" />
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.TryResolve(Castle.MicroKernel.Context.CreationContext)">
            <summary>
              Implementors should return a valid instance 
              for the component the handler is responsible.
              It should return null in the case the component
              can't be created for some reason. No exception should be thrown.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.ComponentModel">
            <summary>
              Gets the model of the component being 
              managed by this handler.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.CurrentState">
            <summary>
              Gets the state of the handler
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.IExposeDependencyInfo">
            <summary>
              Might be implemented by a handler 
              so it can expose access to dependency information 
              which is used to construct meaningful error messages
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.IExposeDependencyInfo.ObtainDependencyDetails(Castle.MicroKernel.Handlers.IDependencyInspector)">
            <summary>
              Informs the <paramref name = "inspector" /> about missing dependencies.
              Implementers should ignore the call if no dependencies are missing and 
              call back the inspector with the information required otherwise
            </summary>
            <param name = "inspector"></param>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.missingDependencies">
            <summary>
              Dictionary of key (string) to
              <see cref="T:Castle.Core.DependencyModel"/>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.#ctor(Castle.Core.ComponentModel)">
            <summary>
              Constructs and initializes the handler
            </summary>
            <param name = "model"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.ReleaseCore(Castle.MicroKernel.Burden)">
            <summary>
              Should be implemented by derived classes: 
              disposes the component instance (or recycle it)
            </summary>
            <param name = "burden"></param>
            <returns>true if destroyed.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Resolve(Castle.MicroKernel.Context.CreationContext,System.Boolean)">
            <summary>
              Returns an instance of the component this handler
              is responsible for
            </summary>
            <param name = "context"></param>
            <param name = "instanceRequired">when <c>false</c>, handler can not create valid instance and return <c>null</c> instead </param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Init(Castle.MicroKernel.IKernelInternal)">
            <summary>
              Saves the kernel instance, subscribes to
              <see cref="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel"/>
              event,
              creates the lifestyle manager instance and computes
              the handler state.
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Release(Castle.MicroKernel.Burden)">
            <summary>
              disposes the component instance (or recycle it).
            </summary>
            <param name = "burden"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Resolve(Castle.MicroKernel.Context.CreationContext)">
            <summary>
              Returns an instance of the component this handler
              is responsible for
            </summary>
            <param name = "context"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.AddDependency(Castle.Core.DependencyModel)">
            <summary>
              Invoked by
              <see cref="M:Castle.MicroKernel.Handlers.AbstractHandler.InitDependencies"/>
              in order to check if a dependency can be satisfied.
              If not, the handler is set to a 'waiting dependency' state.
            </summary>
            <remarks>
              This method registers the dependencies within the correct collection 
              or dictionary and changes the handler state to
              <see cref="F:Castle.MicroKernel.HandlerState.WaitingDependency"/>
            </remarks>
            <param name="dependency"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.DependencySatisfied(System.Boolean@)">
            <summary>
              Invoked by the kernel
              when one of registered dependencies were satisfied by 
              new components registered.
            </summary>
            <remarks>
              Handler for the event
              <see cref="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered"/>
            </remarks>
            <param name="stateChanged"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.EnsureDependenciesCanBeSatisfied(Castle.MicroKernel.ComponentActivator.IDependencyAwareActivator)">
            <summary>
              Checks if the handler is able to, at very least, satisfy
              the dependencies for the constructor with less parameters
            </summary>
            <remarks>
              For each non*optional dependency, the implementation will invoke
              <see cref="M:Castle.MicroKernel.Handlers.AbstractHandler.AddDependency(Castle.Core.DependencyModel)"/>
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.OnAddedAsChildKernel(System.Object,System.EventArgs)">
            <summary>
              Invoked when the container receives a parent container reference.
            </summary>
            <remarks>
              This method implementation checks whether the parent container
              is able to supply the dependencies for this handler.
            </remarks>
            <param name = "sender"></param>
            <param name = "e"></param>
        </member>
        <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.ComponentModel">
            <summary>
              Gets the component model.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.CurrentState">
            <summary>
              Gets the handler state.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.DefaultHandler.lifestyleManager">
            <summary>
              Lifestyle manager instance
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.#ctor(Castle.Core.ComponentModel)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.Handlers.DefaultHandler"/>
              class.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.ReleaseCore(Castle.MicroKernel.Burden)">
            <summary>
              disposes the component instance (or recycle it)
            </summary>
            <param name="burden"></param>
            <returns>true if destroyed</returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.ResolveCore(Castle.MicroKernel.Context.CreationContext,System.Boolean,System.Boolean,Castle.MicroKernel.Burden@)">
            <summary>
              Returns an instance of the component this handler
              is responsible for
            </summary>
            <param name="context"></param>
            <param name="requiresDecommission"></param>
            <param name="instanceRequired"></param>
            <param name="burden"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.Handlers.DefaultHandler.LifestyleManager">
            <summary>
              Lifestyle manager instance
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.GenericHandlerTypeMismatchException">
            <summary>
              Thrown when <see cref="T:Castle.MicroKernel.Handlers.DefaultGenericHandler"/> can't create proper closed version of itself due to violation of generic constraints.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.HandlerException">
            <summary>
              Summary description for HandlerException.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.String,Castle.Core.ComponentName)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="name"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.String,Castle.Core.ComponentName,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="name"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.GenericHandlerTypeMismatchException.#ctor(System.String,Castle.Core.ComponentName)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="name"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.GenericHandlerTypeMismatchException.#ctor(System.String,Castle.Core.ComponentName,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="name"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.GenericHandlerTypeMismatchException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.Context.CreationContext">
            <summary>
              Used during a component request, passed along to the whole process.
              This allow some data to be passed along the process, which is used 
              to detected cycled dependency graphs and now it's also being used
              to provide arguments to components.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Context.CreationContext.handlerStack">
            <summary>
              The list of handlers that are used to resolve
              the component.
              We track that in order to try to avoid attempts to resolve a service
              with itself.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Context.CreationContext.#ctor(System.Type,Castle.MicroKernel.Context.CreationContext,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Context.CreationContext"/> class.
            </summary>
            <param name="requestedType">The type to extract generic arguments.</param>
            <param name="parentContext">The parent context.</param>
            <param name="propagateInlineDependencies">When set to <c>true</c> will clone <paramref name="parentContext"/> <see cref="P:Castle.MicroKernel.Context.CreationContext.AdditionalArguments"/>.</param>
        </member>
        <member name="M:Castle.MicroKernel.Context.CreationContext.#ctor(Castle.MicroKernel.IHandler,Castle.MicroKernel.IReleasePolicy,System.Type,System.Collections.IDictionary,Castle.MicroKernel.SubSystems.Conversion.ITypeConverter,Castle.MicroKernel.Context.CreationContext)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Context.CreationContext"/> class.
            </summary>
            <param name="handler">The handler.</param>
            <param name="releasePolicy">The release policy.</param>
            <param name="requestedType">The type to extract generic arguments.</param>
            <param name="additionalArguments">The additional arguments.</param>
            <param name="converter">The conversion manager.</param>
            <param name="parent">Parent context</param>
        </member>
        <member name="M:Castle.MicroKernel.Context.CreationContext.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Context.CreationContext"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Context.CreationContext.IsInResolutionContext(Castle.MicroKernel.IHandler)">
            <summary>
              Method used by handlers to test whether they are being resolved in the context.
            </summary>
            <param name="handler"></param>
            <returns></returns>
            <remarks>
              This method is provided as part of double dispatch mechanism for use by handlers.
              Outside of handlers, call <see cref="M:Castle.MicroKernel.IHandler.IsBeingResolvedInContext(Castle.MicroKernel.Context.CreationContext)"/> instead.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Context.CreationContext.CreateEmpty">
            <summary>
              Creates a new, empty <see cref="T:Castle.MicroKernel.Context.CreationContext"/> instance.
            </summary>
            <remarks>
              A new CreationContext should be created every time, as the contexts keeps some state related to dependency resolution.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.DefaultKernel">
            <summary>
              Default implementation of <see cref="T:Castle.MicroKernel.IKernel"/>. 
              This implementation is complete and also support a kernel 
              hierarchy (sub containers).
            </summary>
            <summary>
              Default implementation of <see cref="T:Castle.MicroKernel.IKernel"/>. 
              This implementation is complete and also support a kernel 
              hierarchy (sub containers).
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IKernel">
            <summary>
              The <c>IKernel</c> interface exposes all the functionality
              the MicroKernel implements.
            </summary>
            <remarks>
              It allows you to register components and
              request them by their name or the services they expose.
              It also allow you to register facilities and subsystem, thus 
              augmenting the functionality exposed by the kernel alone to fit 
              your needs.
              <seealso cref="T:Castle.MicroKernel.IFacility"/>
              <seealso cref="T:Castle.MicroKernel.ISubSystem"/>
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.IKernelEvents">
            <summary>
              Summary description for IKernelEvents.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentRegistered">
            <summary>
              Event fired when a new component is registered 
              on the kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated">
            <summary>
              Event fired after the ComponentModel is created.
              Allows customizations that may affect the handler.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel">
            <summary>
              Event fired when the kernel was added as child of
              another kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.RemovedAsChildKernel">
            <summary>
              Event fired when the kernel was removed from being a child
              of another kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentCreated">
            <summary>
              Event fired before the component is created.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed">
            <summary>
              Event fired when a component instance destroyed.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered">
            <summary>
              Event fired when a new handler is registered 
              (it might be in a valid or waiting dependency state)
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.HandlersChanged">
            <summary>
              Event fired when a new handler is registered 
              (it might be in a valid or waiting dependency state)
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.DependencyResolving">
            <summary>
              Event fired when a dependency is being resolved,
              it allows the dependency to be changed,
              but the client ComponentModel must not be changed.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.RegistrationCompleted">
            <summary>
              Event fired when registration / installation process is completed.
              That is when container is about to exit<see cref="M:Castle.MicroKernel.IKernel.Register(Castle.MicroKernel.Registration.IRegistration[])"/> method. This event is raised once regardless of how many components were registered.
              If the <see cref="M:Castle.MicroKernel.IKernel.Register(Castle.MicroKernel.Registration.IRegistration[])"/> is called by <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> the event is raised when that method exits.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.EmptyCollectionResolving">
            <summary>
              Event fired when a collection is being resolved (via <see cref="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type)"/> or another overload) and the collection is empty.
              Implementors would usually log that fact or potentially throw an exception (especially in development).
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddChildKernel(Castle.MicroKernel.IKernel)">
            <summary>
              Support for kernel hierarchy
            </summary>
            <param name = "kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility(Castle.MicroKernel.IFacility)">
            <summary>
              Adds a <see cref="T:Castle.MicroKernel.IFacility"/> to the kernel.
            </summary>
            <param name="facility"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.Action{``0})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddHandlerSelector(Castle.MicroKernel.IHandlerSelector)">
            <summary>
              Register a new component resolver that can take part in the decision
              making about which handler to resolve
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddHandlersFilter(Castle.MicroKernel.IHandlersFilter)">
            <summary>
              Register a new component resolver that can take part in the decision
              making about which handler(s) to resolve and in which order
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddSubSystem(System.String,Castle.MicroKernel.ISubSystem)">
            <summary>
              Adds (or replaces) an <see cref="T:Castle.MicroKernel.ISubSystem"/>
            </summary>
            <param name="name"></param>
            <param name="subsystem"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetAssignableHandlers(System.Type)">
            <summary>
              Return handlers for components that 
              implements the specified service. 
              The check is made using IsAssignableFrom
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetFacilities">
            <summary>
              Returns the facilities registered on the kernel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.String)">
            <summary>
              Returns the <see cref="T:Castle.MicroKernel.IHandler"/>
              for the specified component name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.Type)">
            <summary>
              Returns the <see cref="T:Castle.MicroKernel.IHandler"/>
              for the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandlers(System.Type)">
            <summary>
              Return handlers for components that 
              implements the specified service.
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetSubSystem(System.String)">
            <summary>
              Returns an implementation of <see cref="T:Castle.MicroKernel.ISubSystem"/>
              for the specified name. 
              <seealso cref="T:Castle.MicroKernel.SubSystemConstants"/>
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.String)">
            <summary>
              Returns <c>true</c> if a component with given <paramref name = "name" /> was registered, otherwise <c>false</c>.
            </summary>
            <param name = "name"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.Type)">
            <summary>
              Returns true if the specified service was registered
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Register(Castle.MicroKernel.Registration.IRegistration[])">
            <summary>
              Registers the components with the <see cref="T:Castle.MicroKernel.IKernel"/>. The instances of <see cref="T:Castle.MicroKernel.Registration.IRegistration"/> are produced by fluent registration API.
              Most common entry points are <see cref="M:Castle.MicroKernel.Registration.Component.For``1"/> method to register a single type or (recommended in most cases) 
              <see cref="M:Castle.MicroKernel.Registration.AllTypes.FromThisAssembly"/>.
              Let the Intellisense drive you through the fluent API past those entry points. For details see the documentation at http://j.mp/WindsorApi
            </summary>
            <example>
              <code>
                kernel.Register(Component.For&lt;IService&gt;().ImplementedBy&lt;DefaultService&gt;().LifestyleTransient());
              </code>
            </example>
            <example>
              <code>
                kernel.Register(Classes.FromThisAssembly().BasedOn&lt;IService&gt;().WithServiceDefaultInterfaces().Configure(c =&gt; c.LifestyleTransient()));
              </code>
            </example>
            <param name="registrations">The component registrations created by <see cref="M:Castle.MicroKernel.Registration.Component.For``1"/>, <see cref="M:Castle.MicroKernel.Registration.AllTypes.FromThisAssembly"/> or different entry method to the fluent API.</param>
            <returns>The kernel.</returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ReleaseComponent(System.Object)">
            <summary>
              Releases a component instance. This allows
              the kernel to execute the proper decommission 
              lifecycles on the component instance.
            </summary>
            <param name = "instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RemoveChildKernel(Castle.MicroKernel.IKernel)">
            <summary>
              Remove child kernel
            </summary>
            <param name = "kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility(System.String,Castle.MicroKernel.IFacility)">
            <summary>
              Adds a <see cref="T:Castle.MicroKernel.IFacility"/> to the kernel.
            </summary>
            <param name="key"></param>
            <param name="facility"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.String)">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.String,System.Action{``0})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
            <param name="onCreate">The callback for creation.</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Object)">
            <summary>
              Returns the component instance by the component key
              using dynamic arguments
            </summary>
            <param name = "key">Key to resolve</param>
            <param name = "argumentsAsAnonymousType">Arguments to resolve the services</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
              Returns the component instance by the component key
              using dynamic arguments
            </summary>
            <param name = "key"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type)">
            <summary>
              Returns the component instance by the service type
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type,System.Object)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name = "service">Service to resolve</param>
            <param name = "argumentsAsAnonymousType">Arguments to resolve the services</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.Collections.IDictionary)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.Object)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name = "argumentsAsAnonymousType">Arguments to resolve the services</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1">
            <summary>
              Returns the component instance by the component key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.String)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key">Component's key</param>
            <typeparam name = "T">Service type</typeparam>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.String,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <param name = "key">Component's key</param>
            <param name = "arguments"></param>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type)">
            <summary>
              Returns all the valid component instances by
              the service type
            </summary>
            <param name = "service">The service type</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type,System.Collections.IDictionary)">
            <summary>
              Returns all the valid component instances by
              the service type
            </summary>
            <param name = "service">The service type</param>
            <param name = "arguments">Arguments to resolve the services</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type,System.Object)">
            <summary>
              Returns all the valid component instances by
              the service type
            </summary>
            <param name = "service">The service type</param>
            <param name = "argumentsAsAnonymousType">Arguments to resolve the services</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1">
            <summary>
              Returns component instances that implement TService
            </summary>
            <typeparam name = "TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1(System.Collections.IDictionary)">
            <summary>
              Returns component instances that implement TService
            </summary>
            <typeparam name = "TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1(System.Object)">
            <summary>
              Returns component instances that implement TService
            </summary>
            <typeparam name = "TService"></typeparam>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ComponentModelBuilder">
            <summary>
              Returns the implementation of <see cref="T:Castle.MicroKernel.IComponentModelBuilder"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ConfigurationStore">
            <summary>
              Gets or sets the implementation of <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.GraphNodes">
            <summary>
              Graph of components and interactions.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.HandlerFactory">
            <summary>
              Returns the implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Parent">
            <summary>
              Returns the parent kernel
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ProxyFactory">
            <summary>
              Gets or sets the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
              allowing different strategies for proxy creation.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ReleasePolicy">
            <summary>
              Gets or sets the implementation for <see cref="T:Castle.MicroKernel.IReleasePolicy"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Resolver">
            <summary>
              Returns the implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Item(System.String)">
            <summary>
              Returns the component instance by the key
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Item(System.Type)">
            <summary>
              Returns the component instance by the service type
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IKernelInternal">
            <summary>
              Extended contract of kernel, used internally.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernelInternal.AddCustomComponent(Castle.Core.ComponentModel)">
            <summary>
              Adds a custom made <see cref="T:Castle.Core.ComponentModel"/>.
              Used by facilities.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernelInternal.CreateComponentActivator(Castle.Core.ComponentModel)">
            <summary>
              Constructs an implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>
              for the given <see cref="T:Castle.Core.ComponentModel"/>
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernelInternal.Resolve(System.String,System.Type,System.Collections.IDictionary,Castle.MicroKernel.IReleasePolicy)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <param name = "policy"></param>
            <returns></returns>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.childKernels">
            <summary>
              List of sub containers.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.facilities">
            <summary>
              List of <see cref="T:Castle.MicroKernel.IFacility"/> registered.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.subsystems">
            <summary>
              Map of subsystems registered.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.parentKernel">
            <summary>
              The parent kernel, if exists.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor">
            <summary>
              Constructs a DefaultKernel with no component
              proxy support.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IDependencyResolver,Castle.MicroKernel.IProxyFactory)">
            <summary>
              Constructs a DefaultKernel with the specified
              implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/> and <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            </summary>
            <param name="resolver"></param>
            <param name="proxyFactory"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IProxyFactory)">
            <summary>
              Constructs a DefaultKernel with the specified
              implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Dispose">
            <summary>
              Starts the process of component disposal.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetAssignableHandlers(System.Type)">
            <summary>
              Return handlers for components that 
              implements the specified service. 
              The check is made using IsAssignableFrom
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetFacilities">
            <summary>
              Returns the facilities registered on the kernel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetHandlers(System.Type)">
            <summary>
              Return handlers for components that 
              implements the specified service.
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Register(Castle.MicroKernel.Registration.IRegistration[])">
            <summary>
              Registers the components with the <see cref="T:Castle.MicroKernel.IKernel"/>. The instances of <see cref="T:Castle.MicroKernel.Registration.IRegistration"/> are produced by fluent registration API.
              Most common entry points are <see cref="M:Castle.MicroKernel.Registration.Component.For``1"/> method to register a single type or (recommended in most cases) 
              <see cref="M:Castle.MicroKernel.Registration.AllTypes.FromThisAssembly"/>.
              Let the Intellisense drive you through the fluent API past those entry points. For details see the documentation at http://j.mp/WindsorApi
            </summary>
            <example>
              <code>
                kernel.Register(Component.For&lt;IService&gt;().ImplementedBy&lt;DefaultService&gt;().LifestyleTransient());
              </code>
            </example>
            <example>
              <code>
                kernel.Register(Classes.FromThisAssembly().BasedOn&lt;IService&gt;().WithServiceDefaultInterfaces().Configure(c =&gt; c.LifestyleTransient()));
              </code>
            </example>
            <param name="registrations">The component registrations created by <see cref="M:Castle.MicroKernel.Registration.Component.For``1"/>, <see cref="M:Castle.MicroKernel.Registration.AllTypes.FromThisAssembly"/> or different entry method to the fluent API.</param>
            <returns>The kernel.</returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ReleaseComponent(System.Object)">
            <summary>
              Releases a component instance. This allows
              the kernel to execute the proper decommission
              lifecycles on the component instance.
            </summary>
            <param name = "instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.CreateLifestyleManager(Castle.Core.ComponentModel,Castle.MicroKernel.IComponentActivator)">
            <summary>
              Creates an implementation of
              <see cref="T:Castle.MicroKernel.ILifestyleManager"/>
              based
              on
              <see cref="T:Castle.Core.LifestyleType"/>
              and invokes
              <see cref="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)"/>
              to initialize the newly created manager.
            </summary>
            <param name="model"></param>
            <param name="activator"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.DisposeHandler(Castle.MicroKernel.IHandler)">
            <remarks>
              It is the responsibility of the kernel to ensure that handler is only ever disposed once.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
              Returns the component instance by the component key
              using dynamic arguments
            </summary>
            <param name = "key"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Object)">
            <summary>
              Returns the component instance by the component key
              using dynamic arguments
            </summary>
            <param name = "key"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.Collections.IDictionary)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.Object)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1">
            <summary>
              Returns the component instance by the component key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.String)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key">Component's key</param>
            <typeparam name = "T">Service type</typeparam>
            <returns>
              The Component instance
            </returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.String,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <param name = "key">Component's key</param>
            <param name = "arguments"></param>
            <returns>
              The Component instance
            </returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type)">
            <summary>
              Returns the component instance by the service type
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type,System.Object)">
            <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
            <param name = "service"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type)">
            <summary>
              Returns all the valid component instances by
              the service type
            </summary>
            <param name = "service">The service type</param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type,System.Collections.IDictionary)">
            <summary>
              Returns all the valid component instances by
              the service type
            </summary>
            <param name = "service">The service type</param>
            <param name = "arguments">
              Arguments to resolve the services
            </param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type,System.Object)">
            <summary>
              Returns all the valid component instances by
              the service type
            </summary>
            <param name = "service">The service type</param>
            <param name = "argumentsAsAnonymousType">
              Arguments to resolve the services
            </param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1(System.Object)">
            <summary>
              Returns component instances that implement TService
            </summary>
            <typeparam name = "TService"></typeparam>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1(System.Collections.IDictionary)">
            <summary>
              Returns component instances that implement TService
            </summary>
            <typeparam name = "TService"></typeparam>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1">
            <summary>
              Returns component instances that implement TService
            </summary>
            <typeparam name = "TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Castle#MicroKernel#IKernelInternal#Resolve(System.String,System.Type,System.Collections.IDictionary,Castle.MicroKernel.IReleasePolicy)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <param name = "policy"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.DefaultKernel.GraphNodes">
            <summary>
              Graph of components and interactions.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.CircularDependencyException">
            <summary>
              Exception throw when a circular dependency is detected
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.CircularDependencyException"/>
              class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.CircularDependencyException"/>
              class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor(System.String,Castle.Core.ComponentModel)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.CircularDependencyException"/>
              class.
            </summary>
            <param name="message"></param>
            <param name="component"></param>
        </member>
        <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.CircularDependencyException"/>
              class.
            </summary>
            <param name="info">The
              <see cref="T:System.Runtime.Serialization.SerializationInfo"/>
              that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The
              <see cref="T:System.Runtime.Serialization.StreamingContext"/>
              that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The
              <paramref name="info"/>
              parameter is
              <see langword="null"/>
              .</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is
              <see langword="null"/>
              or
              <see cref="P:System.Exception.HResult"/>
              is zero (0).</exception>
        </member>
        <member name="T:Castle.MicroKernel.ComponentNotFoundException">
            <summary>
              Exception threw when a request for a component
              cannot be satisfied because the component does not
              exist in the container
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.String,System.String)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/>
              class.
            </summary>
            <param name="name">The name.</param>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Type,System.String)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/>
              class.
            </summary>
            <param name="service">The service.</param>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Type)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/>
              class.
            </summary>
            <param name="service">The service.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/>
              class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentRegistrationException">
            <summary>
              Exception threw when there is a problem
              registering a component
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.IHandlersFilter">
            <summary>
              Implementation of this interface allows for extension of the way
              the container looks up multiple handlers. It provides the necessary
              hook to allow for business logic to prioritize, filter, and sort
              handlers when resolving multiple handlers.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IHandlersFilter.HasOpinionAbout(System.Type)">
            <summary>
              Whatever the selector has an opinion about resolving a component with the 
              specified service and key.
            </summary>
            <param name = "service">The service interface that we want to resolve</param>
        </member>
        <member name="M:Castle.MicroKernel.IHandlersFilter.SelectHandlers(System.Type,Castle.MicroKernel.IHandler[])">
            <summary>
              Select the appropriate handlers (if any) from the list of defined handlers,
              returning them in the order they should be executed.
              The returned handlers should members from the <paramref name = "handlers" /> array.
            </summary>
            <param name = "service">The service interface that we want to resolve</param>
            <param name = "handlers">The defined handlers</param>
            <returns>The selected handlers, or an empty array, or null</returns>
        </member>
        <member name="T:Castle.MicroKernel.KernelException">
            <summary>
              Exception threw by Kernel operations that failed
              for some reason.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.AbstractFacility">
            <summary>
              Base class for facilities.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IFacility">
            <summary>
              Unit of extension. A facility should use 
              the extension points offered by the kernel
              to augment its functionality.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IFacility.Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
            <summary>
            </summary>
            <param name = "kernel"></param>
            <param name = "facilityConfig"></param>
        </member>
        <member name="M:Castle.MicroKernel.IFacility.Terminate">
            <summary>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Init">
            <summary>
              The custom initialization for the Facility.
            </summary>
            <remarks>
              It must be overridden.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Dispose">
            <summary>
              Performs the tasks associated with freeing, releasing, or resetting 
              the facility resources.
            </summary>
            <remarks>
              It can be overriden.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Castle#MicroKernel#IFacility#Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Initializes the facility. First it performs the initialization common for all 
              facilities, setting the <see cref="P:Castle.MicroKernel.Facilities.AbstractFacility.Kernel"/> and the 
              <see cref="P:Castle.MicroKernel.Facilities.AbstractFacility.FacilityConfig"/>. After it, the <c>Init</c> method is invoked
              and the custom initilization is perfomed.
            </summary>
            <param name="kernel"></param>
            <param name="facilityConfig"></param>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Castle#MicroKernel#IFacility#Terminate">
            <summary>
              Terminates the Facility, invokes the <see cref="M:Castle.MicroKernel.Facilities.AbstractFacility.Dispose"/> method and sets 
              the Kernel to a null reference.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.FacilityConfig">
            <summary>
              Gets the facility configuration.
            </summary>
            <value>The <see cref="T:Castle.Core.Configuration.IConfiguration"/> representing 
              the facility configuration.</value>
        </member>
        <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.Kernel">
            <summary>
              Gets the <see cref="T:Castle.MicroKernel.IKernel"/> where the facility is registered.
            </summary>
            <value>The <see cref="T:Castle.MicroKernel.IKernel"/>.</value>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.FacilityException">
            <summary>
              Base exception to be used by facilities.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.DeferredStart">
            <summary>
              This method changes behavior of the facility. Deferred mode should be used when you
              have single call to <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> and register all your components there.
              Enabling this mode will optimize the behavior of the facility so that it will wait 'till the end of
              installation and only after all <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>s were ran it will instantiate and
              start all the startable components. An exception will be thrown if a startable component can't be 
              instantiated and started. This will help you fail fast and diagnose issues quickly. If you don't want
              the exception to be thrown and you prefer the component to fail silently, use <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredTryStart"/> method instead.
            </summary>
            <remarks>
              It is recommended to use this method over <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredTryStart"/> method.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.DeferredTryStart">
            <summary>
              This method changes behavior of the facility. Deferred mode should be used when you
              have single call to <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> and register all your components there.
              Enabling this mode will optimize the behavior of the facility so that it will wait 'till the end of
              installation and only after all <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>s were ran it will instantiate and
              start all the startable components. No exception will be thrown if a startable component can't be 
              instantiated and started. If you'd rather fail fast and diagnose issues quickly, use <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredStart"/> method instead.
            </summary>
            <remarks>
              It is recommended to use <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredStart"/> method over this method.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.CheckWaitingList">
            <summary>
              For each new component registered,
              some components in the WaitingDependency
              state may have became valid, so we check them
            </summary>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.TryStart(Castle.MicroKernel.IHandler)">
            <summary>
              Request the component instance
            </summary>
            <param name = "handler"></param>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StartUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.String)">
            <summary>
              Assigns the start method for the startable.
            </summary>
            <param name="registration"></param>
            <param name="startMethod">The start method.</param>
            <returns></returns>
            <remarks>
              Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility"/> 
              to the kernel, before registering this component.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StartUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Action}})">
            <summary>
              Assigns the start method for the startable.
            </summary>
            <param name="registration"></param>
            <param name="methodToUse">Method to use. something like: StartUsingMethod(s =&gt; s.Start)</param>
            <returns></returns>
            <remarks>
              Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility"/> 
              to the kernel, before registering this component.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StopUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.String)">
            <summary>
              Assigns the stop method for the startable.
            </summary>
            <param name="registration"></param>
            <param name="stopMethod">The stop method.</param>
            <returns></returns>
            <remarks>
              Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility"/> 
              to the kernel, before registering this component.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StopUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Action}})">
            <summary>
              Assigns the stop method for the startable.
            </summary>
            <param name="registration"></param>
            <param name="methodToUse">Method to use. something like: StartUsingMethod(s =&gt; s.Start)</param>
            <returns></returns>
            <remarks>
              Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility"/> 
              to the kernel, before registering this component.
            </remarks>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.FactoryEntry">
            <summary>
              Legacy class from old impl. of the facility. Do not use it.
            </summary>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.Internal.FactoryInterceptor">
            <summary>
              Legacy interceptor for old impl. of the facility.
            </summary>
        </member>
        <member name="T:Castle.Core.Interceptor.IOnBehalfAware">
            <summary>
              Interceptors might implement this to receive the
              ComponentModel on behalf of the component where the
              interceptor is acting.
            </summary>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.TypedFactoryComponentResolver">
            <summary>
              Represents a single component to be resolved via Typed Factory
            </summary>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.TypedFactoryComponentResolver.Resolve(Castle.MicroKernel.IKernelInternal,Castle.MicroKernel.IReleasePolicy)">
            <summary>
              Resolves the component(s) from given kernel.
            </summary>
            <param name = "kernel"></param>
            <param name = "scope"></param>
            <returns>Resolved component(s).</returns>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.TypedFactoryFacility">
            <summary>
              Provides automatically generated factories on top of interfaces or delegates that
              you can use to pull components out of the container without ever referencing it 
              explicitly.
            </summary>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0})">
            <summary>
              Marks the component as typed factory.
            </summary>
            <typeparam name="TFactoryInterface"></typeparam>
            <param name="registration"></param>
            <returns></returns>
            <remarks>
              Only interfaces and delegates are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector"/> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.String)">
            <summary>
              Marks the component as typed factory.
            </summary>
            <typeparam name="TFactoryInterface"></typeparam>
            <param name="registration"></param>
            <param name="selectorComponentName">Name of the <see cref="T:Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector"/> component to be used for this factory</param>
            <returns></returns>
            <remarks>
              Only interfaces and delegates are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector"/> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.Type)">
            <summary>
              Marks the component as typed factory.
            </summary>
            <typeparam name="TFactoryInterface"></typeparam>
            <param name="registration"></param>
            <param name="selectorComponentType">Type of the <see cref="T:Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector"/> component to be used for this factory</param>
            <returns></returns>
            <remarks>
              Only interfaces and delegates are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector"/> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector)">
            <summary>
              Marks the component as typed factory.
            </summary>
            <typeparam name="TFactoryInterface"></typeparam>
            <param name="registration"></param>
            <param name="selector">The <see cref="T:Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector"/> instance to be used for this factory</param>
            <returns></returns>
            <remarks>
              Only interfaces and delegates are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector"/> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.Action{Castle.Facilities.TypedFactory.TypedFactoryConfiguration})">
            <summary>
              Marks the component as typed factory.
            </summary>
            <typeparam name="TFactoryInterface"></typeparam>
            <param name="registration"></param>
            <param name="configuration"></param>
            <returns></returns>
            <remarks>
              Only interfaces and delegates are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector"/> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver">
            <summary>
              Redirects resolution to the main resolver, and if not found uses
              the parent handler.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver.#ctor(Castle.MicroKernel.IHandler,Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver"/> class.
            </summary>
            <param name="parentHandler">The parent handler.</param>
            <param name="childResolver">The child resolver.</param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultGenericHandler.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.Handlers.IGenericImplementationMatchingStrategy)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.DefaultGenericHandler"/> class.
            </summary>
            <param name="model"></param>
            <param name="implementationMatchingStrategy"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultGenericHandler.CloneParentProperties(Castle.Core.ComponentModel)">
            <summary>
              Clone some of the parent componentmodel properties to the generic subhandler.
            </summary>
            <remarks>
              The following properties are copied:
              <list type="bullet">
                <item>
                  <description>The <see cref="T:Castle.Core.LifestyleType"/></description>
                </item>
                <item>
                  <description>The <see cref="P:Castle.Core.ComponentModel.Interceptors"/></description>
                </item>
              </list>
            </remarks>
            <param name="newModel">the subhandler</param>
        </member>
        <member name="T:Castle.MicroKernel.IHandlerFactory">
            <summary>
              Extension point to allow the developer
              to use his implementation of <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentDataDelegate">
            <summary>
              Represents a delegate which holds basic information about a component.
            </summary>
            <param name = "key">Key which identifies the component</param>
            <param name = "handler">handler that holds this component and is capable of 
              creating an instance of it.
            </param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentInstanceDelegate">
            <summary>
              Represents a delegate which holds basic information about a component
              and its instance.
            </summary>
            <param name = "model">Component meta information</param>
            <param name = "instance">Component instance</param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentModelDelegate">
            <summary>
              Represents a delegate which holds the information about the 
              component
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ServiceDelegate">
            <summary>
              Represents a delegate which holds the information about a service.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.HandlerDelegate">
            <summary>
              Represents a delegate which holds a handler
            </summary>
            <param name = "handler">handler that holds a component and is capable of 
              creating an instance of it.
            </param>
            <param name = "stateChanged"></param>
        </member>
        <member name="T:Castle.MicroKernel.DependencyDelegate">
            <summary>
              Represents a delegate which holds dependency
              resolving information.
            </summary>
        </member>
        <member name="T:Castle.Core.Internal.IVertex">
            <summary>
              Abstract representation of a vertex.
            </summary>
        </member>
        <member name="P:Castle.Core.Internal.GraphNode.Dependents">
            <summary>
              The nodes that this node depends on
            </summary>
        </member>
        <member name="F:Castle.Core.Internal.VertexColor.White">
            <summary>
              The node has not been visited yet
            </summary>
        </member>
        <member name="F:Castle.Core.Internal.VertexColor.Gray">
            <summary>
              This node is in the process of being visited
            </summary>
        </member>
        <member name="F:Castle.Core.Internal.VertexColor.Black">
            <summary>
              This now was visited
            </summary>
        </member>
        <member name="T:Castle.Core.Internal.ColorsSet">
            <summary>
              Represents a collection of objects
              which are guaranteed to be unique 
              and holds a color for them
            </summary>
        </member>
        <member name="T:Castle.Core.Internal.TimestampSet">
            <summary>
              Holds a timestamp (integer) 
              for a given item
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.DisposalConcern">
            <summary>
            Summary description for DisposalConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.InitializationConcern">
            <summary>
            Summary description for InitializationConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.LateBoundCommissionConcerns">
            <summary>
              Lifetime concern that works for components that don't have their actual type determined upfront
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.LateBoundConcerns`1">
            <summary>
              Lifetime concern that works for components that don't have their actual type determined upfront
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.LateBoundDecommissionConcerns">
            <summary>
              Lifetime concern that works for components that don't have their actual type determined upfront
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.SupportInitializeConcern">
            <summary>
              Summary description for SupportInitializeConcern.
            </summary>
        </member>
        <member name="T:Castle.Core.IRecyclable">
            <summary>
              Only called for components that 
              belongs to a pool when the component
              comes back to the pool.
            </summary>
        </member>
        <member name="M:Castle.Core.IRecyclable.Recycle">
            <summary>
              Implementors should perform any 
              initialization/clean up.
            </summary>
        </member>
        <member name="T:Castle.Core.IStartable">
            <summary>
              Interface for components that wish to be started and stopped by the container
            </summary>
        </member>
        <member name="M:Castle.Core.IStartable.Start">
            <summary>
              Starts this instance.
            </summary>
        </member>
        <member name="M:Castle.Core.IStartable.Stop">
            <summary>
              Stops this instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.AbstractLifestyleManager">
            <summary>
              Base implementation of <see cref="T:Castle.MicroKernel.ILifestyleManager"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ILifestyleManager">
            <summary>
              The <c>ILifestyleManager</c> implements 
              a strategy for a given lifestyle, like singleton, per-thread
              and transient.
            </summary>
            <remarks>
              The responsibility of <c>ILifestyleManager</c>
              is only the management of lifestyle. It should rely on
              <see cref="T:Castle.MicroKernel.IComponentActivator"/> to obtain a new component instance
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Initializes the <c>ILifestyleManager</c> with the 
              <see cref="T:Castle.MicroKernel.IComponentActivator"/>
            </summary>
            <param name="componentActivator"></param>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Release(System.Object)">
            <summary>
              Implementors should release the component instance based
              on the lifestyle semantic, for example, singleton components
              should not be released on a call for release, instead they should
              release them when disposed is invoked.
            </summary>
            <param name = "instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Resolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.IReleasePolicy)">
            <summary>
              Implementors should return the component instance based on the lifestyle semantic.
              Also the instance should be set to <see cref="M:Castle.MicroKernel.Burden.SetRootInstance(System.Object)"/>, <see cref="P:Castle.MicroKernel.Burden.RequiresPolicyRelease"/> should be also set if needed
              and if a new instance was created it should be passed on to <see cref="M:Castle.MicroKernel.IReleasePolicy.Track(System.Object,Castle.MicroKernel.Burden)"/> of <paramref name="releasePolicy"/>.
            </summary>
            <param name="context"/>
            <param name="releasePolicy"/>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.AbstractLifestyleManager.Dispose">
            <summary>
              Invoked when the container gets disposed. The container will not call it multiple times in multithreaded environments.
              However it may be called at the same time when some out of band release mechanism is in progress. Resolving those potential
              issues is the task of implementors
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.Scoped.IScopeAccessor">
            <summary>
              Provides access to <see cref="T:Castle.MicroKernel.Lifestyle.Scoped.IScopeCache"/> held in whatever is appropriate for given scope.
            </summary>
            <remarks>
              Implementors should also ensure proper initialization of <see cref="T:Castle.MicroKernel.Lifestyle.Scoped.IScopeCache"/> when accessed for the first time and ensure a thread safe implementation is used when scope or cache access can cause threading issues if non thread safe cache is used.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Scoped.IScopeAccessor.GetScope(Castle.MicroKernel.Context.CreationContext)">
            <summary>
              Provides access to <see cref="T:Castle.MicroKernel.Lifestyle.Scoped.IScopeCache"/> for currently resolved component.
            </summary>
            <param name="context">Current creation context</param>
            <exception cref="T:System.InvalidOperationException"> Thrown when scope cache could not be accessed.</exception>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.PerWebRequestLifestyleModule.YieldScope">
            <summary>
              Returns current request's scope and detaches it from the request context.
              Does not throw if scope or context not present. To be used for disposing of the context.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PoolableLifestyleManager">
            <summary>
              Manages a pool of objects.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.Pool.IPool">
            <summary>
              Pool implementation contract.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Release(System.Object)">
            <summary>
              Implementors should release the instance or put it
              on the pool
            </summary>
            <param name = "instance"></param>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.Scoped.ILifetimeScope">
            <summary>
              Temporary interface to introduce new scoping mechanism. It will replace the currently existing one.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.Scoped.IScopeCache">
            <summary>
              Represents persistence mechanism for instances of components that are supposed to be reused within scope managing the cache.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Lifestyle.Scoped.IScopeCache.Item(System.Object)">
            <summary>
              Saves or retrieves a <see cref="T:Castle.MicroKernel.Burden"/> stored in the cache associated with the given <paramref name="id"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"> Thrown when <paramref name="id"/> is null.</exception>
            <exception cref="T:System.ArgumentException"> Thrown when there is already a <see cref="T:Castle.MicroKernel.Burden"/> associated with given <paramref name="id"/> value in the cache.</exception>
            <remarks>
              The interface gives no thread safety guarantees. When the scope can be accessed from multiple threads the implementor should ensure thread safety.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.Scoped.CallContextLifetimeScope">
            <summary>
              Provides explicit lifetime scoping within logical path of execution. Used for types with <see cref="F:Castle.Core.LifestyleType.Scoped"/>.
            </summary>
            <remarks>
              The scope is passed on to child threads, including ThreadPool threads. The capability is limited to single <see cref="T:System.AppDomain"/> and should be used cauciously as call to <see cref="M:Castle.MicroKernel.Lifestyle.Scoped.CallContextLifetimeScope.Dispose"/> may occur while the child thread is still executing, what in turn may lead to subtle threading bugs.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.Scoped.ScopedInstanceActivationCallback">
            <summary>
              Delegate used by <see cref="T:Castle.MicroKernel.Lifestyle.Scoped.ILifetimeScope"/> to request a new instance to be created (that would be the first instance in that scope, subsequently reused).
            </summary>
            <param name="afterCreated">Callback which should be invoken by provided delegate right after isntance gets created and before it burden gets tracked.
              The purpose if this callback is to include scope in decisions regarding tracking of the instance by <see cref="T:Castle.MicroKernel.IReleasePolicy"/>.
              Depending on the scope implementation it may or may not provide its own end of lifetime detection mechanism.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.IComponentModelDescriptor.BuildComponentModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Contribute to component model before standard <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/> run.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.IComponentModelDescriptor.ConfigureComponentModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Contribute to component model after standard <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/> run.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Classes">
            <summary>
              Entry point to fluent way to register, by convention, multiple concrete (non-abstract) classes (that include also delegate types). Use static methods on the class to fluently build registration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Classes.From(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
              Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Classes.From(System.Type[])">
            <summary>
              Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Classes.FromAssembly(System.Reflection.Assembly)">
            <summary>
              Prepares to register types from an assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Classes.FromAssemblyContaining(System.Type)">
            <summary>
              Prepares to register types from an assembly containing the type.
            </summary>
            <param name="type">The type belonging to the assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Classes.FromAssemblyContaining``1">
            <summary>
              Prepares to register types from an assembly containing the type.
            </summary>
            <typeparam name="T">The type belonging to the assembly.</typeparam>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Classes.FromAssemblyInDirectory(Castle.MicroKernel.Registration.AssemblyFilter)">
            <summary>
              Prepares to register types from assemblies found in a given directory that meet additional optional restrictions.
            </summary>
            <param name = "filter"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Classes.FromAssemblyNamed(System.String)">
            <summary>
              Prepares to register types from an assembly.
            </summary>
            <param name="assemblyName">The assembly name.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Classes.FromThisAssembly">
            <summary>
              Prepares to register types from the assembly containing the code invoking this method.
            </summary>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Types">
            <summary>
              Entry point to fluent way to register, by convention, multiple types. No upfront filtering is done so literally every type will be considered. That means that usually some filtering done by user will be required. For a most common case where non-abstract classes only are to be considered use <see cref="T:Castle.MicroKernel.Registration.Classes"/> class instead. Use static methods on the class to fluently build registration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Types.From(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
              Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Types.From(System.Type[])">
            <summary>
              Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Types.FromAssembly(System.Reflection.Assembly)">
            <summary>
              Prepares to register types from an assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Types.FromAssemblyContaining(System.Type)">
            <summary>
              Prepares to register types from an assembly containing the type.
            </summary>
            <param name="type">The type belonging to the assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Types.FromAssemblyContaining``1">
            <summary>
              Prepares to register types from an assembly containing the type.
            </summary>
            <typeparam name="T">The type belonging to the assembly.</typeparam>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Types.FromAssemblyInDirectory(Castle.MicroKernel.Registration.AssemblyFilter)">
            <summary>
              Prepares to register types from assemblies found in a given directory that meet additional optional restrictions.
            </summary>
            <param name = "filter"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Types.FromAssemblyNamed(System.String)">
            <summary>
              Prepares to register types from an assembly.
            </summary>
            <param name="assemblyName">The assembly name.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Types.FromThisAssembly">
            <summary>
              Prepares to register types from the assembly containing the code invoking this method.
            </summary>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.SingletonLifestyleManager">
            <summary>
              Only one instance is created first time an instance of the component is requested, and it is then reused for all subseque.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.TransientLifestyleManager">
            <summary>
              Transient components are never reused. Since their lifetime does not have any externally constrained end, they have to be manually released if resolved explicitly, to ensure proper decomission.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder">
            <summary>
              Summary description for DefaultComponentModelBuilder.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IComponentModelBuilder">
            <summary>
              Implementors must construct a populated
              instance of ComponentModel by inspecting the component
              and|or the configuration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
              "To give or supply in common with others; give to a 
              common fund or for a common purpose". The contributor
              should inspect the component, or even the configuration
              associated with the component, to add or change information
              in the model that can be used later.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.BuildModel(Castle.Core.ComponentName,System.Type[],System.Type,System.Collections.IDictionary)">
            <summary>
              Constructs a new ComponentModel by invoking
              the registered contributors.
            </summary>
            <param name = "name"></param>
            <param name = "services"></param>
            <param name = "classType"></param>
            <param name = "extendedProperties"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
              Removes the specified contributor
            </summary>
            <param name = "contributor"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.#ctor(Castle.MicroKernel.IKernel)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder"/> class.
            </summary>
            <param name="kernel">The kernel.</param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
              "To give or supply in common with others; give to a
              common fund or for a common purpose". The contributor
              should inspect the component, or even the configuration
              associated with the component, to add or change information
              in the model that can be used later.
            </summary>
            <param name = "contributor"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.BuildModel(Castle.Core.ComponentName,System.Type[],System.Type,System.Collections.IDictionary)">
            <summary>
              Constructs a new ComponentModel by invoking
              the registered contributors.
            </summary>
            <param name = "name"></param>
            <param name = "services"></param>
            <param name = "classType"></param>
            <param name = "extendedProperties"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
              Removes the specified contributor
            </summary>
            <param name = "contributor"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.InitializeContributors">
            <summary>
              Initializes the default contributors.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.Contributors">
            <summary>
              Gets the contributors.
            </summary>
            <value>The contributors.</value>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector">
            <summary>
              Inspects the component configuration and the type looking for a
              definition of component activator type. The configuration preceeds whatever
              is defined in the component.
            </summary>
            <remarks>
              This inspector is not guarantee to always set up an component activator type. 
              If nothing could be found it wont touch the model. In this case is up to
              the kernel to establish a default component activator for components.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Searches for the component activator in the configuration and, if unsuccessful
              look for the component activator attribute in the implementation type.
            </summary>
            <param name = "kernel">The kernel instance</param>
            <param name = "model">The model instance</param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ReadComponentActivatorFromConfiguration(Castle.Core.ComponentModel)">
            <summary>
              Reads the attribute "componentActivatorType" associated with the 
              component configuration and verifies it implements the <see cref="T:Castle.MicroKernel.IComponentActivator"/> 
              interface.
            </summary>
            <exception cref="T:System.Exception">
              If the type does not implement the proper interface
            </exception>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ReadComponentActivatorFromType(Castle.Core.ComponentModel)">
            <summary>
              Check if the type expose one of the component activator attributes
              defined in Castle.Core namespace.
            </summary>
            <param name = "model"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ValidateComponentActivator(System.Type)">
            <summary>
              Validates that the provide type implements IComponentActivator
            </summary>
            <param name = "customComponentActivator">The custom component activator.</param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector">
            <summary>
              Inspects the component configuration and type looking for information
              that can influence the generation of a proxy for that component.
              <para>
                We specifically look for <c>additionalInterfaces</c> and <c>marshalByRefProxy</c> 
                on the component configuration or the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute"/> 
                attribute.
              </para>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Searches for proxy behavior in the configuration and, if unsuccessful
              look for the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute"/> attribute in 
              the implementation type.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.ReadProxyBehaviorFromType(System.Type)">
            <summary>
              Returns a <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute"/> instance if the type
              uses the attribute. Otherwise returns null.
            </summary>
            <param name="implementation"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.ReadProxyBehavior(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Reads the proxy behavior associated with the 
              component configuration/type and applies it to the model.
            </summary>
            <exception cref="T:System.Exception">
              If the conversion fails
            </exception>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector">
            <summary>
              Uses the ConfigurationStore registered in the kernel to obtain
              an <see cref="T:Castle.Core.Configuration.IConfiguration"/> associated with the component.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Queries the kernel's ConfigurationStore for a configuration
              associated with the component name.
            </summary>
            <param name = "kernel"></param>
            <param name = "model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector">
            <summary>
              Check for a node 'parameters' within the component 
              configuration. For each child it, a ParameterModel is created
              and added to ComponentModel's Parameters collection
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Inspect the configuration associated with the component
              and populates the parameter model collection accordingly
            </summary>
            <param name = "kernel"></param>
            <param name = "model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConstructorDependenciesModelInspector">
            <summary>
              This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/>
              collects all available constructors and populates them in the model
              as candidates. The Kernel will pick up one of the candidates
              according to a heuristic.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ExtendedPropertiesConstants">
            <summary>
              Only to hold internal constants and get rid of 
              magic numbers and hardcode names.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.InterceptorInspector">
            <summary>
              Inspect the component for <c>InterceptorAttribute</c> and
              the configuration for the interceptors node
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector">
            <summary>
              Inspects the type looking for interfaces that constitutes
              lifecycle interfaces, defined in the Castle.Model namespace.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Checks if the type implements <see cref="T:Castle.Core.IInitializable"/> and or
              <see cref="T:System.IDisposable"/> interfaces.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector">
            <summary>
              Inspects the component configuration and the type looking for a
              definition of lifestyle type. The configuration preceeds whatever
              is defined in the component.
            </summary>
            <remarks>
              This inspector is not guarantee to always set up an lifestyle type. 
              If nothing could be found it wont touch the model. In this case is up to
              the kernel to establish a default lifestyle for components.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Searches for the lifestyle in the configuration and, if unsuccessful
              look for the lifestyle attribute in the implementation type.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromConfiguration(Castle.Core.ComponentModel)">
            <summary>
              Reads the attribute "lifestyle" associated with the 
              component configuration and tries to convert to <see cref="T:Castle.Core.LifestyleType"/>  
              enum type.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromType(Castle.Core.ComponentModel)">
            <summary>
              Check if the type expose one of the lifestyle attributes
              defined in Castle.Model namespace.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector">
            <summary>
              Base for inspectors that want configuration associated with methods.
              For each child a <see cref="T:Castle.Core.MethodMetaModel"/> is created
              and added to ComponentModel's methods collection
            </summary>
            <remarks>
              Implementors should override the <see cref="M:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector.ObtainNodeName"/> return
              the name of the node to be inspected. For example:
              <code>
                <![CDATA[
              <transactions>
                <method name="Save" transaction="requires" />
              </transactions>
            ]]>
              </code>
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector">
            <summary>
              This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/>
              collects all potential writable public properties exposed by the component 
              implementation and populates the model with them.
              The Kernel might be able to set some of these properties when the component 
              is requested.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Adds the properties as optional dependencies of this component.
            </summary>
            <param name = "kernel"></param>
            <param name = "model"></param>
        </member>
        <member name="T:Castle.Core.ComponentModel">
            <summary>
              Represents the collection of information and
              meta information collected about a component.
            </summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.dependencies">
            <summary>
              Dependencies the kernel must resolve
            </summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.interceptors">
            <summary>
              Interceptors associated
            </summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.parameters">
            <summary>
              External parameters
            </summary>
        </member>
        <member name="F:Castle.Core.ComponentModel.properties">
            <summary>
              All potential properties that can be setted by the kernel
            </summary>
        </member>
        <member name="M:Castle.Core.ComponentModel.#ctor(Castle.Core.ComponentName,System.Collections.Generic.ICollection{System.Type},System.Type,System.Collections.IDictionary)">
            <summary>
              Constructs a ComponentModel
            </summary>
        </member>
        <member name="M:Castle.Core.ComponentModel.AddConstructor(Castle.Core.ConstructorCandidate)">
            <summary>
              Adds constructor dependency to this <see cref="T:Castle.Core.ComponentModel"/>
            </summary>
            <param name="constructor"></param>
        </member>
        <member name="M:Castle.Core.ComponentModel.AddProperty(Castle.Core.PropertySet)">
            <summary>
              Adds property dependency to this <see cref="T:Castle.Core.ComponentModel"/>
            </summary>
            <param name="property"></param>
        </member>
        <member name="M:Castle.Core.ComponentModel.AddService(System.Type)">
            <summary>
              Add service to be exposed by this <see cref="T:Castle.Core.ComponentModel"/>
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Castle.Core.ComponentModel.Requires(System.Predicate{Castle.Core.PropertySet}[])">
            <summary>
              Requires the selected property dependencies.
            </summary>
            <param name = "selectors">The property selector.</param>
        </member>
        <member name="M:Castle.Core.ComponentModel.Requires``1">
            <summary>
              Requires the property dependencies of type <typeparamref name = "D" />.
            </summary>
            <typeparam name = "D">The dependency type.</typeparam>
        </member>
        <member name="P:Castle.Core.ComponentModel.Configuration">
            <summary>
              Gets or sets the configuration.
            </summary>
            <value>The configuration.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Constructors">
            <summary>
              Gets the constructors candidates.
            </summary>
            <value>The constructors.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.CustomComponentActivator">
            <summary>
              Gets or sets the custom component activator.
            </summary>
            <value>The custom component activator.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.CustomDependencies">
            <summary>
              Gets the custom dependencies.
            </summary>
            <value>The custom dependencies.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.CustomLifestyle">
            <summary>
              Gets or sets the custom lifestyle.
            </summary>
            <value>The custom lifestyle.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Dependencies">
            <summary>
              Dependencies are kept within constructors and
              properties. Others dependencies must be 
              registered here, so the kernel (as a matter 
              of fact the handler) can check them
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentModel.ExtendedProperties">
            <summary>
              Gets or sets the extended properties.
            </summary>
            <value>The extended properties.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Implementation">
            <summary>
              Gets or sets the component implementation.
            </summary>
            <value>The implementation.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.InspectionBehavior">
            <summary>
              Gets or sets the strategy for
              inspecting public properties 
              on the components
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentModel.Interceptors">
            <summary>
              Gets the interceptors.
            </summary>
            <value>The interceptors.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Lifecycle">
            <summary>
              Gets the lifecycle steps.
            </summary>
            <value>The lifecycle steps.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.LifestyleType">
            <summary>
              Gets or sets the lifestyle type.
            </summary>
            <value>The type of the lifestyle.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Name">
            <summary>
              Sets or returns the component key
            </summary>
        </member>
        <member name="P:Castle.Core.ComponentModel.Parameters">
            <summary>
              Gets the parameter collection.
            </summary>
            <value>The parameters.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.Properties">
            <summary>
              Gets the properties set.
            </summary>
            <value>The properties.</value>
        </member>
        <member name="P:Castle.Core.ComponentModel.RequiresGenericArguments">
            <summary>
              Gets or sets a value indicating whether the component requires generic arguments.
            </summary>
            <value>
              <c>true</c> if generic arguments are required; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Castle.Core.ConstructorCandidate">
            <summary>
              Represents a constructor of the component 
              that the container can use to initialize it properly.
            </summary>
        </member>
        <member name="M:Castle.Core.ConstructorCandidate.#ctor(System.Reflection.ConstructorInfo,Castle.Core.ConstructorDependencyModel[])">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ConstructorCandidate"/> class.
            </summary>
            <param name="constructorInfo">The constructor info.</param>
            <param name="dependencies">The dependencies.</param>
        </member>
        <member name="P:Castle.Core.ConstructorCandidate.Constructor">
            <summary>
              Gets the ConstructorInfo (from reflection).
            </summary>
            <value>The constructor.</value>
        </member>
        <member name="P:Castle.Core.ConstructorCandidate.Dependencies">
            <summary>
              Gets the dependencies this constructor candidate exposes.
            </summary>
            <value>The dependencies.</value>
        </member>
        <member name="T:Castle.Core.ConstructorCandidateCollection">
            <summary>
              Collection of <see cref="T:Castle.Core.ConstructorCandidate"/>
            </summary>
        </member>
        <member name="T:Castle.Core.DependencyModelCollection">
            <summary>
              Collection of <see cref="T:Castle.Core.DependencyModel"/>.
            </summary>
        </member>
        <member name="T:Castle.Core.InterceptorReference">
            <summary>
              Represents an reference to a Interceptor component.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IReference`1">
            <summary>
              Represents obtained just in time object.
            </summary>
            <typeparam name = "T"></typeparam>
        </member>
        <member name="M:Castle.MicroKernel.IReference`1.Attach(Castle.Core.ComponentModel)">
            <summary>
              If the reference introduces dependency on a component, should return <see cref="T:Castle.Core.DependencyModel"/> for that dependency, otherwise <c>null</c>.
            </summary>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IReference`1.Resolve(Castle.MicroKernel.IKernel,Castle.MicroKernel.Context.CreationContext)">
            <summary>
              Resolves object referenced by this reference, optionally using provided <paramref name = "kernel" />.
              If object is resolved from the kernel, the <paramref name = "context" /> should be used to guard
              against against cyclic dependencies.
            </summary>
            <param name = "kernel"></param>
            <param name = "context"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.InterceptorReference.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference"/> class.
            </summary>
            <param name="referencedComponentName">The component key.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReference.#ctor(System.Type)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference"/> class.
            </summary>
            <param name="componentType">Type of the interceptor to use. This will reference the default component (ie. one with no explicitly assigned name) implemented by given type.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReference.ForKey(System.String)">
            <summary>
              Gets an <see cref="T:Castle.Core.InterceptorReference"/> for the component key.
            </summary>
            <param name="key">The component key.</param>
            <returns>The <see cref="T:Castle.Core.InterceptorReference"/></returns>
        </member>
        <member name="M:Castle.Core.InterceptorReference.ForType(System.Type)">
            <summary>
              Gets an <see cref="T:Castle.Core.InterceptorReference"/> for the service.
            </summary>
            <param name="service">The service.</param>
            <returns>The <see cref="T:Castle.Core.InterceptorReference"/></returns>
        </member>
        <member name="M:Castle.Core.InterceptorReference.ForType``1">
            <summary>
              Gets an <see cref="T:Castle.Core.InterceptorReference"/> for the service.
            </summary>
            <typeparam name="T">The service type.</typeparam>
            <returns>The <see cref="T:Castle.Core.InterceptorReference"/></returns>
        </member>
        <member name="T:Castle.Core.InterceptorReferenceCollection">
            <summary>
              Collection of <see cref="T:Castle.Core.InterceptorReference"/>
            </summary>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.Add(Castle.Core.InterceptorReference)">
            <summary>
              Adds the specified item.
            </summary>
            <param name = "item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.AddFirst(Castle.Core.InterceptorReference)">
            <summary>
              Adds the specified interceptor as the first.
            </summary>
            <param name = "item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.AddIfNotInCollection(Castle.Core.InterceptorReference)">
            <summary>
              Adds the interceptor to the end of the interceptors list if it does not exist already.
            </summary>
            <param name = "interceptorReference">The interceptor reference.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.AddLast(Castle.Core.InterceptorReference)">
            <summary>
              Adds the specified interceptor as the last.
            </summary>
            <param name = "item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.Insert(System.Int32,Castle.Core.InterceptorReference)">
            <summary>
              Inserts the specified interceptor at the specified index.
            </summary>
            <param name = "index">The index.</param>
            <param name = "item">The interceptor.</param>
        </member>
        <member name="M:Castle.Core.InterceptorReferenceCollection.GetEnumerator">
            <summary>
              Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
              An <see cref = "T:System.Collections.IEnumerator" />
              that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Castle.Core.InterceptorReferenceCollection.HasInterceptors">
            <summary>
              Gets a value indicating whether this instance has interceptors.
            </summary>
            <value>
              <c>true</c> if this instance has interceptors; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Castle.Core.LifecycleConcernsCollection">
            <summary>
              Represents a collection of ordered lifecycle concerns.
            </summary>
        </member>
        <member name="P:Castle.Core.LifecycleConcernsCollection.CommissionConcerns">
            <summary>
              Returns all concerns for the commission phase
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Core.LifecycleConcernsCollection.DecommissionConcerns">
            <summary>
              Returns all concerns for the decommission phase
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Core.LifecycleConcernsCollection.HasCommissionConcerns">
            <summary>
              Gets a value indicating whether this instance has commission steps.
            </summary>
            <value>
              <c>true</c> if this instance has commission steps; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.Core.LifecycleConcernsCollection.HasDecommissionConcerns">
            <summary>
              Gets a value indicating whether this instance has decommission steps.
            </summary>
            <value>
              <c>true</c> if this instance has decommission steps; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Castle.Core.MethodMetaModel">
            <summary>
              Represents meta information associated with a method
              (not yet defined)
            </summary>
        </member>
        <member name="M:Castle.Core.MethodMetaModel.#ctor(Castle.Core.Configuration.IConfiguration)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.MethodMetaModel"/> class.
            </summary>
            <param name="configNode">The config node.</param>
        </member>
        <member name="P:Castle.Core.MethodMetaModel.ConfigNode">
            <summary>
              Gets the config node.
            </summary>
            <value>The config node.</value>
        </member>
        <member name="T:Castle.Core.MethodMetaModelCollection">
            <summary>
              Collection of <see cref="T:Castle.Core.MethodMetaModel"/>
            </summary>
        </member>
        <member name="P:Castle.Core.MethodMetaModelCollection.MethodInfo2Model">
            <summary>
              Gets the method info2 model.
            </summary>
            <value>The method info2 model.</value>
        </member>
        <member name="T:Castle.Core.ParameterModel">
            <summary>
              Represents a parameter. Usually the parameter
              comes from the external world, ie, an external configuration.
            </summary>
        </member>
        <member name="M:Castle.Core.ParameterModel.#ctor(System.String,System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Castle.Core.ParameterModel.#ctor(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:Castle.Core.ParameterModel.ConfigValue">
            <summary>
              Gets the config value.
            </summary>
            <value>The config value.</value>
        </member>
        <member name="P:Castle.Core.ParameterModel.Name">
            <summary>
              Gets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Castle.Core.ParameterModel.Value">
            <summary>
              Gets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="T:Castle.Core.ParameterModelCollection">
            <summary>
              Collection of <see cref="T:Castle.Core.ParameterModel"/>
            </summary>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,System.String)">
            <summary>
              Adds the specified name.
            </summary>
            <param name = "name">The name.</param>
            <param name = "value">The value.</param>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Adds the specified name.
            </summary>
            <param name = "name">The name.</param>
            <param name = "configNode">The config node.</param>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,Castle.Core.ParameterModel)">
            <summary>
              Adds the specified key.
            </summary>
            <remarks>
              Not implemented
            </remarks>
            <param name = "key">The key.</param>
            <param name = "value">The value.</param>
        </member>
        <member name="M:Castle.Core.ParameterModelCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
              Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
              An <see cref = "T:System.Collections.IEnumerator" />
              that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.Count">
            <summary>
              Gets the count.
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:Castle.Core.ParameterModelCollection.Item(System.String)">
            <summary>
              Gets the <see cref="T:Castle.Core.ParameterModel"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="T:Castle.Core.PropertySet">
            <summary>
              Represents a property and the respective dependency.
            </summary>
        </member>
        <member name="M:Castle.Core.PropertySet.#ctor(System.Reflection.PropertyInfo,Castle.Core.DependencyModel)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.PropertySet"/> class.
            </summary>
            <param name="propertyInfo">The property info.</param>
            <param name="dependency">The dependency.</param>
        </member>
        <member name="P:Castle.Core.PropertySet.Dependency">
            <summary>
              Gets the dependency.
            </summary>
            <value>The dependency.</value>
        </member>
        <member name="P:Castle.Core.PropertySet.Property">
            <summary>
              Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="T:Castle.Core.PropertySetCollection">
            <summary>
              Collection of <see cref="T:Castle.Core.PropertySet"/>
            </summary>
        </member>
        <member name="M:Castle.Core.PropertySetCollection.FindByPropertyInfo(System.Reflection.PropertyInfo)">
            <summary>
              Finds a PropertySet the by PropertyInfo.
            </summary>
            <param name = "info">The info.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.ComponentReference`1">
            <summary>
              Reference to component obtained from the container.
            </summary>
            <typeparam name = "T"></typeparam>
        </member>
        <member name="M:Castle.MicroKernel.ComponentReference`1.#ctor(System.Type)">
            <summary>
              Creates a new instance of <see cref="T:Castle.MicroKernel.ComponentReference`1"/> referencing default component implemented by <paramref name="componentType"/>
            </summary>
            <param name="componentType"></param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentReference`1.#ctor(System.String)">
            <summary>
              Creates a new instance of <see cref="T:Castle.MicroKernel.ComponentReference`1"/> referencing component <paramref name="referencedComponentName"/>
            </summary>
            <param name="referencedComponentName"></param>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.IModelInterceptorsSelector">
            <summary>
              Select the appropriate interceptors based on the application specific
              business logic
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.IModelInterceptorsSelector.HasInterceptors(Castle.Core.ComponentModel)">
            <summary>
              Determine whatever the specified has interceptors.
              The selector should only return true from this method if it has determined that is
              a model that it would likely add interceptors to.
            </summary>
            <param name = "model">The model</param>
            <returns>Whatever this selector is likely to add interceptors to the specified model</returns>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.IModelInterceptorsSelector.SelectInterceptors(Castle.Core.ComponentModel,Castle.Core.InterceptorReference[])">
            <summary>
              Select the appropriate interceptor references.
              The interceptor references aren't necessarily registered in the model.Intereceptors
            </summary>
            <param name="model">The model to select the interceptors for</param>
            <param name="interceptors">The interceptors selected by previous selectors in the pipeline or <see cref="P:Castle.Core.ComponentModel.Interceptors"/> if this is the first interceptor in the pipeline.</param>
            <returns>The interceptor for this model (in the current context) or a null reference</returns>
            <remarks>
              If the selector is not interested in modifying the interceptors for this model, it 
              should return <paramref name="interceptors"/> and the next selector in line would be executed.
              If the selector wants no interceptors to be used it can either return <c>null</c> or empty array.
              However next interceptor in line is free to override this choice.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.InstanceReference`1">
            <summary>
              Represents a reference to an existing object.
            </summary>
            <typeparam name = "T"></typeparam>
        </member>
        <member name="T:Castle.MicroKernel.IProxyFactory">
            <summary>
              Defines the contract used by the kernel 
              to obtain proxies for components. The implementor
              must return a proxied instance that dispatch 
              the invocation to the registered interceptors in the model
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.AddInterceptorSelector(Castle.MicroKernel.Proxy.IModelInterceptorsSelector)">
            <summary>
              Add the selector to the list of selectors that can affect interceptor's decisions
              in the container.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,System.Object[])">
            <summary>
              Implementors must create a proxy based on 
              the information exposed by ComponentModel
            </summary>
            <param name = "kernel">The kernel instance</param>
            <param name = "model">The component model</param>
            <param name = "instance">The component instance to be proxy (only required in some cases)</param>
            <param name = "constructorArguments">array of parameters to the constructor (if any)</param>
            <param name = "context">The creation context</param>
            <returns>proxy instance</returns>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.RequiresTargetInstance(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Implementor should check the component model
              and determine if the caller must pass on the component 
              instance to the proxy
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The component model</param>
            <returns><c>true</c> if an instance must be passed to <see cref="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,System.Object[])"/> </returns>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.ShouldCreateProxy(Castle.Core.ComponentModel)">
            <summary>
              Determines whatever we need to create a proxy for this model
            </summary>
            <param name = "model"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.NotSupportedProxyFactory">
            <summary>
              This is a placeholder implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>.
            </summary>
            <remarks>
              The decision to supply no implementation for <see cref="T:Castle.MicroKernel.IProxyFactory"/>
              is supported by the fact that the MicroKernel should be a thin
              assembly with the minimal set of features, although extensible.
              Providing the support for this interface would obligate 
              the user to import another assembly, even if the large majority of
              simple cases, no use use of interceptors will take place.
              If you want to use however, see the Windsor container.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.ProxyConstants">
            <summary>
              Holds the keys used by the proxy factories.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Proxy.ProxyConstants.ProxyOptionsKey">
            <summary>
              Key used to supply custom proxy options.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.ProxyOptions">
            <summary>
              Represents options to configure proxies.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.#ctor(Castle.Core.ComponentModel)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Proxy.ProxyOptions"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.AddAdditionalInterfaces(System.Type[])">
            <summary>
              Adds the additional interfaces to proxy.
            </summary>
            <param name = "interfaces">The interfaces.</param>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.AddMixIns(System.Object[])">
            <summary>
              Adds the additional mix ins to integrate.
            </summary>
            <param name = "mixIns">The mix ins.</param>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.AddMixinReference(Castle.MicroKernel.IReference{System.Object})">
            <summary>
              Adds the additional mix in to integrate.
            </summary>
            <param name = "mixIn">The mix in.</param>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.Equals(System.Object)">
            <summary>
              Equals the specified obj.
            </summary>
            <param name = "obj">The obj.</param>
            <returns>true if equal.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.GetHashCode">
            <summary>
              Gets the hash code.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.AdditionalInterfaces">
            <summary>
              Gets the additional interfaces to proxy.
            </summary>
            <value>The interfaces.</value>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.AllowChangeTarget">
            <summary>
              Determines if the proxied component can change targets.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.UseMarshalByRefAsBaseClass">
            <summary>
              Determines if the interface proxied component should inherit 
              from <see cref="T:System.MarshalByRefObject"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.Hook">
            <summary>
              Gets or sets the proxy hook.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.MixIns">
            <summary>
              Gets the mix ins to integrate.
            </summary>
            <value>The interfaces.</value>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.OmitTarget">
            <summary>
              Determines if the proxied component uses a target.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.Selector">
            <summary>
              Gets or sets the interceptor selector.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.ProxyOptionsUtil">
            <summary>
              Helper support for proxy configuration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptionsUtil.ObtainProxyOptions(Castle.Core.ComponentModel,System.Boolean)">
            <summary>
              Obtains the <see cref="T:Castle.MicroKernel.Proxy.ProxyOptions"/> associated with the <see cref="T:Castle.Core.ComponentModel"/>.
            </summary>
            <param name="model">The component model.</param>
            <param name="createOnDemand">true if the options should be created if not present.</param>
            <returns>The associated proxy options for the component model.</returns>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeDescriptor`1.#ctor(System.String,System.String)">
            <summary>
              Constructs the <see cref="T:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeDescriptor`1"/> descriptor with name and value.
            </summary>
            <param name="name">The attribute name.</param>
            <param name="value">The attribute value.</param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeKeyDescriptor`1.#ctor(Castle.MicroKernel.Registration.ComponentRegistration{`0},System.String)">
            <summary>
              Constructs the <see cref="T:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeKeyDescriptor`1"/> descriptor with name.
            </summary>
            <param name="component">The component.</param>
            <param name="name">The attribute name.</param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeKeyDescriptor`1.Eq(System.Object)">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeKeyDescriptor`1"/> with value.
            </summary>
            <param name="value">The attribute value.</param>
            <returns>The <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Component">
            <summary>
              Factory for creating <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration"/> objects. Use static methods on the class to fluently build registration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For(System.Type)">
            <summary>
              Creates a component registration for the <paramref name = "serviceType" />
            </summary>
            <param name = "serviceType">Type of the service.</param>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For(System.Type[])">
            <summary>
              Creates a component registration for the <paramref name = "serviceTypes" />
            </summary>
            <param name = "serviceTypes">Types of the service.</param>
            <returns>The component registration.</returns>
            B
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
              Creates a component registration for the <paramref name = "serviceTypes" />
            </summary>
            <param name = "serviceTypes">Types of the service.</param>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``1">
            <summary>
              Creates a component registration for the service type.
            </summary>
            <typeparam name = "TService">The service type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``2">
            <summary>
              Creates a component registration for the service types.
            </summary>
            <typeparam name = "TService1">The primary service type.</typeparam>
            <typeparam name = "TService2">The forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``3">
            <summary>
              Creates a component registration for the service types.
            </summary>
            <typeparam name = "TService1">The primary service type.</typeparam>
            <typeparam name = "TService2">The first forwarded type.</typeparam>
            <typeparam name = "TService3">The second forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``4">
            <summary>
              Creates a component registration for the service types.
            </summary>
            <typeparam name = "TService1">The primary service type.</typeparam>
            <typeparam name = "TService2">The first forwarded type.</typeparam>
            <typeparam name = "TService3">The second forwarded type.</typeparam>
            <typeparam name = "TService4">The third forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``5">
            <summary>
              Creates a component registration for the service types.
            </summary>
            <typeparam name = "TService1">The primary service type.</typeparam>
            <typeparam name = "TService2">The first forwarded type.</typeparam>
            <typeparam name = "TService3">The second forwarded type.</typeparam>
            <typeparam name = "TService4">The third forwarded type.</typeparam>
            <typeparam name = "TService5">The fourth forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.HasAttribute``1(System.Type)">
            <summary>
              Helper method for filtering components based on presence of an Attribute.
            </summary>
            <typeparam name = "TAttribute"></typeparam>
            <param name = "type"></param>
            <returns></returns>
            <example>
              container.Register(
              Classes.FromThisAssembly()
              .Where(Component.HasAttribute&lt;UserAttribute&gt;) );
            </example>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.HasAttribute``1(System.Predicate{``0})">
            <summary>
              Helper method for filtering components based on presence of an Attribute and value of predicate on that attribute.
            </summary>
            <typeparam name = "TAttribute"></typeparam>
            <param name = "filter"></param>
            <returns></returns>
            <example>
              container.Register(
              Classes.FromThisAssembly()
              .Where(Component.HasAttribute&lt;UserAttribute&gt;(u => u.SomeFlag)) );
            </example>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsCastleComponent(System.Type)">
            <summary>
              Determines if the component is a Castle component, that is - if it has a <see cref="T:Castle.Core.CastleComponentAttribute"/>.
            </summary>
            <returns>true if the service is a Castle Component.</returns>
            <remarks>
              This method is usually used as argument for <see cref="M:Castle.MicroKernel.Registration.BasedOnDescriptor.If(System.Predicate{System.Type})"/> method.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInNamespace(System.String)">
            <summary>
              Creates a predicate to check if a component is in a namespace.
            </summary>
            <param name = "namespace">The namespace.</param>
            <returns>true if the component type is in the namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInNamespace(System.String,System.Boolean)">
            <summary>
              Creates a predicate to check if a component is in a namespace.
            </summary>
            <param name = "namespace">The namespace.</param>
            <param name = "includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
            <returns>true if the component type is in the namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs(System.Type)">
            <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <param name = "type">The component type to test namespace against.</param>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <param name = "type">The component type to test namespace against.</param>
            <param name = "includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs``1">
            <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <typeparam name = "T">The component type to test namespace against.</typeparam>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs``1(System.Boolean)">
            <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <typeparam name = "T">The component type to test namespace against.</typeparam>
            <param name = "includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.Insert(System.Collections.IDictionary,System.String,System.Object)">
            <summary>
              Inserts a new named argument with given key. If an argument for this name already exists, it will be overwritten.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.Insert(System.Collections.IDictionary,System.Type,System.Object)">
            <summary>
              Inserts a new typed argument with given type. If an argument for this type already exists, it will be overwritten.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.InsertAnonymous(System.Collections.IDictionary,System.Object)">
            <summary>
              Inserts a set of typed arguments. Property names of the anonymous type will be used as key.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.InsertTyped``1(System.Collections.IDictionary,``0)">
            <summary>
              Inserts a new typed argument with given type. If an argument for this type already exists, it will be overwritten.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.InsertTypedCollection(System.Collections.IDictionary,System.Object[])">
            <summary>
              Inserts a set of typed arguments. Actual type of the arguments will be used as key.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ComponentRegistration`1">
            <summary>
              Registration for a single type as a component with the kernel.
              <para/>
              You can create a new registration with the <see cref="T:Castle.MicroKernel.Registration.Component"/> factory.
            </summary>
            <typeparam name="TService">The service type</typeparam>
        </member>
        <member name="T:Castle.MicroKernel.Registration.IRegistration">
            <summary>
              The contract for all registrations with the kernel.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.IRegistration.Register(Castle.MicroKernel.IKernelInternal)">
            <summary>
              Performs the registration in the <see cref="T:Castle.MicroKernel.IKernel"/>.
            </summary>
            <param name="kernel">The kernel.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.#ctor(System.Type[])">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ActAs(System.Object[])">
            <summary>
              Marks the components with one or more actors.
            </summary>
            <param name = "actors">The component actors.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Activator``1">
            <summary>
              Set a custom <see cref="T:Castle.MicroKernel.IComponentActivator"/> which creates and destroys the component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.AddAttributeDescriptor(System.String,System.String)">
            <summary>
              Adds the attribute descriptor.
            </summary>
            <param name = "key">The key.</param>
            <param name = "value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.AddDescriptor(Castle.MicroKernel.ModelBuilder.IComponentModelDescriptor)">
            <summary>
              Adds the descriptor.
            </summary>
            <param name = "descriptor">The descriptor.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Attribute(System.String)">
            <summary>
              Creates an attribute descriptor.
            </summary>
            <param name = "key">The attribute key.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Configuration(Castle.MicroKernel.Registration.Node[])">
            <summary>
              Apply more complex configuration to this component registration.
            </summary>
            <param name = "configNodes">The config nodes.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Configuration(Castle.Core.Configuration.IConfiguration)">
            <summary>
              Apply more complex configuration to this component registration.
            </summary>
            <param name="configuration">The configuration <see cref="T:Castle.Core.Configuration.MutableConfiguration"/>.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.Dependency[])">
            <summary>
              Specify custom dependencies using <see cref="M:Castle.MicroKernel.Registration.Property.ForKey(System.String)"/> or <see cref="M:Castle.MicroKernel.Registration.Property.ForKey(System.Type)"/>.
              <para/>
              You can pass <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/>s to specify the components
              this component should be resolved with.
            </summary>
            <param name="dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Collections.IDictionary)">
            <summary>
              Uses a dictionary of key/value pairs, to specify custom dependencies.
              <para />
            </summary>
            <param name = "dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Object)">
            <summary>
              Uses an (anonymous) object as a dictionary, to specify custom dependencies.
              <para />
            </summary>
            <param name = "anonymous">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.DynamicParametersDelegate)">
            <summary>
              Allows custom dependencies to by defined dyncamically. Calling this overload is synonymous to using <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersDelegate)"/>
            </summary>
            <param name="resolve">The delegate used for providing dynamic parameters.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.DynamicParametersResolveDelegate)">
            <summary>
              Allows custom dependencies to by defined dynamically with releasing capability. Calling this overload is synonymous to using <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersResolveDelegate)"/>
            </summary>
            <param name="resolve">The delegate used for providing dynamic parameters.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.DynamicParametersWithContextResolveDelegate)">
            <summary>
              Allows custom dependencies to by defined dynamically with releasing capability. Calling this overload is synonymous to using <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersWithContextResolveDelegate)"/>
            </summary>
            <param name="resolve">The delegate used for providing dynamic parameters.</param>
            <returns></returns>
            <remarks>
              Use <see cref="T:Castle.MicroKernel.Context.CreationContext"/> when resolving components from <see cref="T:Castle.MicroKernel.IKernel"/> in order to detect cycles.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersDelegate)">
            <summary>
              Allows custom dependencies to by defined dyncamically.
            </summary>
            <param name = "resolve">The delegate used for providing dynamic parameters.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersResolveDelegate)">
            <summary>
              Allows custom dependencies to by defined dynamically with releasing capability.
            </summary>
            <param name = "resolve">The delegate used for providing dynamic parameters.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersWithContextResolveDelegate)">
            <summary>
              Allows custom dependencies to by defined dynamically with releasing capability.
            </summary>
            <param name="resolve">The delegate used for providing dynamic parameters.</param>
            <returns></returns>
            <remarks>
              Use <see cref="T:Castle.MicroKernel.Context.CreationContext"/> when resolving components from <see cref="T:Castle.MicroKernel.IKernel"/> in order to detect cycles.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ExtendedProperties(Castle.MicroKernel.Registration.Property[])">
            <summary>
              Sets <see cref="P:Castle.Core.ComponentModel.ExtendedProperties"/> for this component.
            </summary>
            <param name="properties">The extended properties.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ExtendedProperties(System.Object)">
            <summary>
              Sets <see cref="P:Castle.Core.ComponentModel.ExtendedProperties"/> for this component.
            </summary>
            <param name="anonymous">The extendend properties as key/value pairs.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward(System.Type[])">
            <summary>
              Adds <paramref name = "types" /> as additional services to be exposed by this component.
            </summary>
            <param name = "types">The types to forward.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``1">
            <summary>
              Adds <typeparamref name = "TService2" /> as additional service to be exposed by this component.
            </summary>
            <typeparam name = "TService2">The forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``2">
            <summary>
              Adds <typeparamref name = "TService2" /> and <typeparamref name = "TService3" /> as additional services to be exposed by this component.
            </summary>
            <typeparam name = "TService2">The first forwarded type.</typeparam>
            <typeparam name = "TService3">The second forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``3">
            <summary>
              Adds <typeparamref name = "TService2" />, <typeparamref name = "TService3" /> and  <typeparamref name = "TService4" /> as additional services to be exposed by this component.
            </summary>
            <typeparam name = "TService2">The first forwarded type.</typeparam>
            <typeparam name = "TService3">The second forwarded type.</typeparam>
            <typeparam name = "TService4">The third forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``4">
            <summary>
              Adds <typeparamref name = "TService2" />, <typeparamref name = "TService3" />,<typeparamref name = "TService4" /> and  <typeparamref
                name = "TService5" /> as additional services to be exposed by this component.
            </summary>
            <typeparam name = "TService2">The first forwarded type.</typeparam>
            <typeparam name = "TService3">The second forwarded type.</typeparam>
            <typeparam name = "TService4">The third forwarded type.</typeparam>
            <typeparam name = "TService5">The fourth forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
              Adds <paramref name = "types" /> as additional services to be exposed by this component.
            </summary>
            <param name = "types">The types to forward.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy``1">
            <summary>
              Sets the concrete type that implements the service to <typeparamref name = "TImpl" />.
              <para />
              If not set, the class service type or first registered interface will be used as the implementation for this component.
            </summary>
            <typeparam name = "TImpl">The type that is the implementation for the service.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type)">
            <summary>
              Sets the concrete type that implements the service to <paramref name = "type" />.
              <para />
              If not set, the class service type or first registered interface will be used as the implementation for this component.
            </summary>
            <param name = "type">The type that is the implementation for the service.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type,Castle.MicroKernel.Handlers.IGenericImplementationMatchingStrategy)">
            <summary>
              Sets the concrete type that implements the service to <paramref name = "type" />.
              <para />
              If not set, the class service type or first registered interface will be used as the implementation for this component.
            </summary>
            <param name = "type">The type that is the implementation for the service.</param>
            <param name = "genericImplementationMatchingStrategy">Provides ability to close open generic service. Ignored when registering closed or non-generic component.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Instance(`0)">
            <summary>
              Assigns an existing instance as the component for this registration.
            </summary>
            <param name = "instance">The component instance.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(Castle.Core.InterceptorReference[])">
            <summary>
              Set the interceptors for this component.
            </summary>
            <param name = "interceptors">The interceptors.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(System.Type[])">
            <summary>
              Set the interceptors for this component.
            </summary>
            <param name = "interceptors">The interceptors.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors``1">
            <summary>
              Set the interceptor for this component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors``2">
            <summary>
              Set the interceptor for this component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(System.String[])">
            <summary>
              Set the interceptor for this component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleCustom(System.Type)">
            <summary>
              Sets component lifestyle to specified one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleCustom``1">
            <summary>
              Sets component lifestyle to specified one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestylePerThread">
            <summary>
              Sets component lifestyle to per thread.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleScoped(System.Type)">
            <summary>
              Sets component lifestyle to scoped per explicit scope. If <paramref name = "scopeAccessorType" /> is provided, it will be used to access scope for the component. Otherwise the default scope accessor will be used.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleScoped``1">
            <summary>
              Sets component lifestyle to scoped per explicit scope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleBoundTo``1">
            <summary>
              Sets component lifestyle to scoped per nearest component on the resolution stack where implementation type is assignable to <typeparamref
               name = "TBaseForRoot" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleBoundTo(System.Func{Castle.MicroKernel.IHandler[],Castle.MicroKernel.IHandler})">
            <summary>
              Sets component lifestyle to scoped per scope determined by <paramref name = "scopeRootBinder" />
            </summary>
            <param name = "scopeRootBinder">Custom algorithm for selection which component higher up the resolution stack should be the root of the lifetime scope for current component's instances.
              The delegate will be invoked when current component is about to be resolved and will be passed set of handlers to components higher up the resolution stack. It ought to return one which it designages
              as the root which shall scope the lifetime of current component's instance, or <c>null</c>
            </param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestylePerWebRequest">
            <summary>
              Sets component lifestyle to instance per web request.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestylePooled(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
              Sets component lifestyle to pooled. If <paramref name = "initialSize" /> or <paramref name = "maxSize" /> are not set default values will be used.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleSingleton">
            <summary>
              Sets component lifestyle to singleton.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleTransient">
            <summary>
              Sets component lifestyle to transient.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Named(System.String)">
            <summary>
              Set a name of this registration. This is required if you have multiple components for a given service and want to be able to resolve some specific ones. Then you'd provide the name so that Windsor knows which one of the bunch you know. Otherwise don't bother setting the name.
              <para/>
              If not set, the <see cref="P:System.Type.FullName"/> of the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation"/>
              will be used as the key to register the component.
            </summary>
            <param name="name">The name of this registration.</param>
            <returns></returns>
            <remarks>
              Names have to be globally unique in the scope of the container.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.NamedAutomatically(System.String)">
            <summary>
              This method as opposed to <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Named(System.String)"/> should be used by tools like facilities when the name is not provided by the user, but autogenerated and user has no interest in seing this name, for example in diagnostics reports.
              Set a name of this registration. This is required if you have multiple components for a given service and want to be able to resolve some specific ones. Then you'd provide the name so that Windsor knows which one of the bunch you know. Otherwise don't bother setting the name.
              <para/>
              If not set, the <see cref="P:System.Type.FullName"/> of the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation"/>
              will be used as the key to register the component.
            </summary>
            <param name="name">The name of this registration.</param>
            <returns></returns>
            <remarks>
              Names have to be globally unique in the scope of the container.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnCreate(System.Action{`0}[])">
            <summary>
              Stores a set of <see cref="T:Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate`1"/> which will be invoked when the component
              is created and before it's returned from the container.
            </summary>
            <param name="actions">A set of actions to be executed right after the component is created and before it's returned from the container.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnCreate(Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate{`0}[])">
            <summary>
              Stores a set of <see cref="T:Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate`1"/> which will be invoked when the component
              is created and before it's returned from the container.
            </summary>
            <param name="actions">A set of actions to be executed right after the component is created and before it's returned from the container.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnDestroy(System.Action{`0}[])">
            <summary>
              Stores a set of <see cref="T:Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate`1"/> which will be invoked when the component
              is created and before it's returned from the container.
            </summary>
            <param name="actions">A set of actions to be executed right after the component is created and before it's returned from the container.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnDestroy(Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate{`0}[])">
            <summary>
              Stores a set of <see cref="T:Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate`1"/> which will be invoked when the component
              is destroyed which means when it's released or it's lifetime scope ends. Notice that usage of this method will cause instsances of the component to be tracked, even if they wouldn't be otherwise.
            </summary>
            <param name="actions">A set of actions to be executed when the component is destroyed.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnlyNewServices">
            <summary>
              Services that are already present in the container will be skipped. If no new service is left the registration will not happen at all.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OverWrite">
            <summary>
              With the overwrite.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Parameters(Castle.MicroKernel.Registration.Parameter[])">
            <summary>
              Set configuration parameters with string or <see cref="T:Castle.Core.Configuration.IConfiguration"/> values.
            </summary>
            <param name="parameters">The parameters.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.SelectInterceptorsWith(Castle.DynamicProxy.IInterceptorSelector)">
            <summary>
              Sets the interceptor selector for this component.
            </summary>
            <param name = "selector"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.SelectInterceptorsWith(System.Action{Castle.MicroKernel.Registration.Proxy.ItemRegistration{Castle.DynamicProxy.IInterceptorSelector}})">
            <summary>
              Sets the interceptor selector for this component.
            </summary>
            <param name = "selector"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(Castle.MicroKernel.Registration.ServiceOverride[])">
            <summary>
              Override (some of) the services that this component needs.
              Use <see cref="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey(System.String)"/> to create an override.
              <para/>
              Each key represents the service dependency of this component, for example the name of a constructor argument or a property.
              The corresponding value is the key of an other component registered to the kernel, and is used to resolve the dependency.
              <para/>
              To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.Dependency[])"/>
            </summary>
            <param name="overrides">The service overrides.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Collections.IDictionary)">
            <summary>
              Override (some of) the services that this component needs, using a dictionary.
              <para/>
              Each key represents the service dependency of this component, for example the name of a constructor argument or a property.
              The corresponding value is the key of an other component registered to the kernel, and is used to resolve the dependency.
              <para/>
              To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Collections.IDictionary)"/>
            </summary>
            <param name="overrides">The service overrides.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Object)">
            <summary>
              Override (some of) the services that this component needs, using an (anonymous) object as a dictionary.
              <para/>
              Each key represents the service dependency of this component, for example the name of a constructor argument or a property.
              The corresponding value is the key of an other component registered to the kernel, and is used to resolve the dependency.
              <para/>
              To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Object)"/>
            </summary>
            <param name="anonymous">The service overrides.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactory``2(System.Converter{``0,``1})">
            <summary>
              Uses a factory to instantiate the component
            </summary>
            <typeparam name = "TFactory">Factory type. This factory has to be registered in the kernel.</typeparam>
            <typeparam name = "TServiceImpl">Implementation type.</typeparam>
            <param name = "factory">Factory invocation</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Func{``0},System.Boolean)">
            <summary>
              Uses a factory method to instantiate the component.
            </summary>
            <typeparam name = "TImpl">Implementation type</typeparam>
            <param name = "factoryMethod">Factory method</param>
            <param name = "managedExternally">When set to <c>true</c> container will not assume ownership of this component, will not track it not apply and lifecycle concerns to it.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Converter{Castle.MicroKernel.IKernel,``0},System.Boolean)">
            <summary>
              Uses a factory method to instantiate the component.
            </summary>
            <typeparam name = "TImpl">Implementation type</typeparam>
            <param name = "factoryMethod">Factory method</param>
            <param name = "managedExternally">When set to <c>true</c> container will not assume ownership of this component, will not track it not apply and lifecycle concerns to it.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Func{Castle.MicroKernel.IKernel,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,``0},System.Boolean)">
            <summary>
              Uses a factory method to instantiate the component.
            </summary>
            <typeparam name = "TImpl">Implementation type</typeparam>
            <param name = "factoryMethod">Factory method</param>
            <param name = "managedExternally">When set to <c>true</c> container will not assume ownership of this component, will not track it not apply and lifecycle concerns to it.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Func{Castle.MicroKernel.IKernel,Castle.MicroKernel.Context.CreationContext,``0})">
            <summary>
              Uses a factory method to instantiate the component.
            </summary>
            <typeparam name = "TImpl">Implementation type</typeparam>
            <param name = "factoryMethod">Factory method</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Castle#MicroKernel#Registration#IRegistration#Register(Castle.MicroKernel.IKernelInternal)">
            <summary>
              Registers this component with the <see cref="T:Castle.MicroKernel.IKernel"/>.
            </summary>
            <param name="kernel">The kernel.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.IsDefault(System.Predicate{System.Type})">
            <summary>
              Overrides default behavior by making the current component the default for every service it exposes. Optional <paramref name="serviceFilter"/> allows user to narrow down the number of services which should be make defaults.
            </summary>
            <param name="serviceFilter">Invoked for each service exposed by given component if returns <c>true</c> this component will be the default for that service. If not specified it is assumed current component should become the default for all of its services.</param>
            <returns></returns>
            <remarks>
              When specified for multiple components for any given service the one registered after will override the one selected before.
              This does not affect order of resolution via <see cref="M:Castle.MicroKernel.IKernel.ResolveAll``1"/> methods.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.IsDefault">
            <summary>
              Overrides default behavior by making the current component the default for every service it exposes.
            </summary>
            <returns></returns>
            <remarks>
              When specified for multiple components for any given service the one registered after will override the one selected before.
              This does not affect order of resolution via <see cref="M:Castle.MicroKernel.IKernel.ResolveAll``1"/> methods.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Properties(System.Predicate{System.Reflection.PropertyInfo})">
            <summary>
              Filters properties on the implementation that will be considered 'settable' by the container.
            </summary>
            <param name = "filter">Predicate deciding whether a property is settable or not. If returns <c>false</c> container will ignore the property, otherwise property will be ignored.</param>
            <returns></returns>
            <remarks>
              Matched properties will be considered optional, that is component will resolve successfully if they can not be satisfied.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Properties(System.Predicate{System.Reflection.PropertyInfo},System.Boolean)">
            <summary>
              Filters properties on the implementation that will be considered 'settable' by the container and specifies if matched properties are reqired.
            </summary>
            <param name = "filter">Predicate deciding whether a property is settable or not. If returns <c>false</c> container will ignore the property.</param>
            <param name = "isRequired"></param>
            <returns></returns>
            <remarks>
              Matched properties will be considered optional if <paramref name = "isRequired" /> is<c>false</c>, that is component will resolve successfully if they can not be satisfied.
              If the argument is <c>true</c> and the dependencies can not be resolved the component will fail to resolve.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Properties(System.Func{Castle.Core.ComponentModel,System.Reflection.PropertyInfo,System.Boolean},System.Boolean)">
            <summary>
              Filters properties on the implementation that will be considered 'settable' by the container and specifies if matched properties are reqired.
            </summary>
            <param name = "filter">Predicate deciding whether a property is settable or not. If returns <c>false</c> container will ignore the property.</param>
            <param name = "isRequired"></param>
            <returns></returns>
            <remarks>
              Matched properties will be considered optional if <paramref name = "isRequired" /> is<c>false</c>, that is component will resolve successfully if they can not be satisfied.
              If the argument is <c>true</c> and the dependencies can not be resolved the component will fail to resolve.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Properties(Castle.Core.PropertyFilter)">
            <summary>
              Filters properties on the implementation that will be considered 'settable' by the container and specifies if matched properties are reqired.
            </summary>
            <param name = "filter">Rules for deciding whether a property is settable or not and if container will ignore the property.</param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation">
            <summary>
              The concrete type that implements the service.
              <para/>
              To set the implementation, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type)"/>.
            </summary>
            <value>The implementation of the service.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.LifeStyle">
            <summary>
              Set the lifestyle of this component.
              For example singleton and transient (also known as 'factory').
            </summary>
            <value>The with lifestyle.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Name">
            <summary>
              The name of the component. Will become the key for the component in the kernel.
              <para/>
              To set the name, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Named(System.String)"/>.
              <para/>
              If not set, the <see cref="P:System.Type.FullName"/> of the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation"/>
              will be used as the key to register the component.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Proxy">
            <summary>
              Set proxy for this component.
            </summary>
            <value>The proxy.</value>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ComponentRegistration">
            <summary>
              A non-generic <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/>.
              <para/>
              You can create a new registration with the <see cref="T:Castle.MicroKernel.Registration.Component"/> factory.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Node">
            <summary>
              Represents a configuration child.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Node.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
              Applies the configuration node.
            </summary>
            <param name = "configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Attrib">
            <summary>
              Represents a configuration attribute.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Attrib.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
              Applies the configuration node.
            </summary>
            <param name = "configuration">The configuration.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Attrib.ForName(System.String)">
            <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.NamedAttribute"/> with name.
            </summary>
            <param name="name">The attribute name.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.NamedAttribute"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.NamedAttribute">
            <summary>
              Represents a named attribute.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedAttribute.Eq(System.String)">
            <summary>
              Builds the <see cref="T:System.Attribute"/> with name/value.
            </summary>
            <param name="value">The attribute value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedAttribute.Eq(System.Object)">
            <summary>
              Builds the <see cref="T:System.Attribute"/> with name/value.
            </summary>
            <param name="value">The attribute value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Child">
            <summary>
              Represents a configuration child.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Child.ForName(System.String)">
            <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.NamedChild"/> with name.
            </summary>
            <param name="name">The child name.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.NamedChild"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.NamedChild">
            <summary>
              Represents a named child.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
              Applies the configuration node.
            </summary>
            <param name = "configuration">The configuration.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(System.String)">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/> with name/value.
            </summary>
            <param name="value">The child value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(System.Object)">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/> with name/value.
            </summary>
            <param name="value">The child value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(Castle.Core.Configuration.IConfiguration)">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ComplexChild"/> with name/config.
            </summary>
            <param name="configNode">The child configuration.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ComplexChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(Castle.MicroKernel.Registration.Node[])">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.Child"/> with name/config.
            </summary>
            <param name="childNodes">The child nodes.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.CompoundChild"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.SimpleChild">
            <summary>
              Represents a simple child node.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.SimpleChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
              Applies the configuration node.
            </summary>
            <param name = "configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ComplexChild">
            <summary>
              Represents a complex child node.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComplexChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
              Applies the configuration node.
            </summary>
            <param name = "configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.CompoundChild">
            <summary>
              Represents a compound child node.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.CompoundChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
              Applies the configuration node.
            </summary>
            <param name = "configuration">The configuration.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnConfigValue(System.String,System.String)">
            <summary>
              Specifies that value <paramref name = "valueAsString" /> should be used to satisfy dependencies matched by <paramref
               name = "dependencyName" />. The value is provided as a string and will be converted to appropriate type when resolving.
            </summary>
            <param name = "dependencyName"></param>
            <param name = "valueAsString"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnConfigValue(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Specifies that value <paramref name = "value" /> should be used to satisfy dependencies matched by <paramref
               name = "dependencyName" />. The value is provided as a string and will be converted to appropriate type when resolving.
            </summary>
            <param name = "dependencyName"></param>
            <param name = "value"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnAppSettingsValue(System.String,System.String)">
            <summary>
              Specifies that value from application configuration file's appSettings section named <paramref name = "settingName" /> should be used to satisfy dependencies matched by <paramref
               name = "dependencyName" />. The value is provided as a string and will be converted to appropriate type when resolving.
            </summary>
            <param name = "dependencyName"></param>
            <param name = "settingName"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnAppSettingsValue(System.String)">
            <summary>
              Specifies that value from application configuration file's appSettings section named <paramref name = "name" /> should be used to satisfy dependencies matched by <paramref
               name = "name" />. The value is provided as a string and will be converted to appropriate type when resolving.
            </summary>
            <param name = "name"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponent(System.String,System.String)">
            <summary>
              Specifies that component registered with <paramref name = "componentName" /> should be used to satisfy dependencies matched by <paramref
               name = "dependencyName" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponent(System.Type,System.String)">
            <summary>
              Specifies that component registered with <paramref name = "componentName" /> should be used to satisfy dependencies matched by <paramref
               name = "dependencyType" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponent(System.String,System.Type)">
            <summary>
              Specifies that component registered with <paramref name = "componentType" /> should be used to satisfy dependencies matched by <paramref
               name = "dependencyName" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponent(System.Type,System.Type)">
            <summary>
              Specifies that component registered with <paramref name = "componentType" /> should be used to satisfy dependencies matched by <paramref
               name = "dependencyType" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponent``2">
            <summary>
              Specifies that component registered with <typeparamref name = "TComponentType" /> should be used to satisfy dependencies matched by <typeparamref
               name = "TDependencyType" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection(System.String,System.String[])">
            <summary>
              Specifies that components registered with <paramref name = "componentNames" /> should be used to satisfy collection dependencies matched by <paramref
               name = "collectionDependencyName" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection(System.Type,System.String[])">
            <summary>
              Specifies that components registered with <paramref name = "componentNames" /> should be used to satisfy collection dependencies matched by <paramref
               name = "collectionDependencyType" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection``1(System.String[])">
            <summary>
              Specifies that components registered with <paramref name = "componentNames" /> should be used to satisfy collection dependencies matched by <typeparamref
               name = "TCollectionDependencyType" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection(System.String,System.Type[])">
            <summary>
              Specifies that components registered with <paramref name = "componentTypes" /> should be used to satisfy collection dependencies matched by <paramref
               name = "collectionDependencyName" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection(System.Type,System.Type[])">
            <summary>
              Specifies that components registered with <paramref name = "componentTypes" /> should be used to satisfy collection dependencies matched by <paramref
               name = "collectionDependencyType" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection``1(System.Type[])">
            <summary>
              Specifies that components registered with <paramref name = "componentTypes" /> should be used to satisfy collection dependencies matched by <typeparamref
               name = "TCollectionDependencyType" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnValue(System.String,System.Object)">
            <summary>
              Specifies that value <paramref name = "value" /> should be used to satisfy dependencies matched by <paramref
               name = "dependencyName" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnValue(System.Type,System.Object)">
            <summary>
              Specifies that value <paramref name = "value" /> should be used to satisfy dependencies matched by <paramref
               name = "dependencyType" />
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Dependency.OnValue``1(System.Object)">
            <summary>
              Specifies that value <paramref name = "value" /> should be used to satisfy dependencies matched by <typeparamref
               name = "TDependencyType" />
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.IWindsorInstaller">
            <summary>
              The contract to install components in the container.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.IWindsorInstaller.Install(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
            <summary>
              Performs the installation in the <see cref="T:Castle.Windsor.IWindsorContainer"/>.
            </summary>
            <param name="container">The container.</param>
            <param name="store">The configuration store.</param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Descriptors.OnCreateComponentDescriptor`1">
            <summary>
              Adds the actions to ExtendedProperties.
            </summary>
            <typeparam name = "S"></typeparam>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Is(Castle.Core.LifestyleType)">
            <summary>
              Sets the lifestyle to the specified
              <paramref name="type" />
              .
            </summary>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Scoped``1">
            <summary>
              Assigns scoped lifestyle with scope accessed via
              <typeparamref name="TScopeAccessor" />
              instances.
            </summary>
            <typeparam name="TScopeAccessor"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Scoped(System.Type)">
            <summary>
              Assigns scoped lifestyle with scope accessed via
              <paramref name="scopeAccessorType" />
              instances if provided, or default accessor otherwise.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Scoped">
            <summary>
              Assigns scoped lifestyle with scope accessed via default accessor.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Custom(System.Type)">
            <summary>
              Assign a custom lifestyle type, that implements
              <see cref="T:Castle.MicroKernel.ILifestyleManager"/>
              .
            </summary>
            <param name="customLifestyleType">Type of the custom lifestyle.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Custom``1">
            <summary>
              Assign a custom lifestyle type, that implements
              <see cref="T:Castle.MicroKernel.ILifestyleManager"/>
              .
            </summary>
            <typeparam name="TLifestyleManager">The type of the custom lifestyle</typeparam>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Parameter">
            <summary>
              Represents a configuration parameter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Parameter.ForKey(System.String)">
            <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.ParameterKey"/> with key.
            </summary>
            <param name="key">The parameter key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ParameterKey"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Parameter.ConfigNode">
            <summary>
              Gets the parameter configuration.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Parameter.Key">
            <summary>
              Gets the parameter key.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Parameter.Value">
            <summary>
              Gets the parameter value.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ParameterKey">
            <summary>
              Represents a parameter key.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ParameterKey.Eq(System.String)">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.Parameter"/> with key/value.
            </summary>
            <param name="value">The parameter value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.Parameter"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ParameterKey.Eq(Castle.Core.Configuration.IConfiguration)">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.Parameter"/> with key/config.
            </summary>
            <param name="configNode">The parameter configuration.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.Parameter"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ParameterKey.Name">
            <summary>
              The parameter key name.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Property">
            <summary>
              Represents a key/value pair.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Property.ForKey(System.String)">
            <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/> with key.
            </summary>
            <param key="key">The property key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Property.ForKey(System.Type)">
            <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/> with key.
            </summary>
            <param key="key">The property key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Property.ForKey``1">
            <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/> with key.
            </summary>
            <param key="key">The property key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Property.Key">
            <summary>
              Gets the property key.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Property.Value">
            <summary>
              Gets the property value.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.PropertyKey">
            <summary>
              Represents a property key.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.PropertyKey.Eq(System.Object)">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.Property"/> with key/value.
            </summary>
            <param key="value">The property value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.Property"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.PropertyKey.Is(System.String)">
            <summary>
              Builds a service override using other component registered with given <paramref name="componentName"/> as value for dependency with given <see cref="P:Castle.MicroKernel.Registration.PropertyKey.Key"/>.
            </summary>
            <param name="componentName"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.PropertyKey.Is(System.Type)">
            <summary>
              Builds a service override using other component registered with given <paramref name="componentImplementation"/> and no explicit name, as value for dependency with given <see cref="P:Castle.MicroKernel.Registration.PropertyKey.Key"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.PropertyKey.Is``1">
            <summary>
              Builds a service override using other component registered with given <typeparam name="TComponentImplementation"/> and no explicit name, as value for dependency with given <see cref="P:Castle.MicroKernel.Registration.PropertyKey.Key"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.PropertyKey.Key">
            <summary>
              The property key key.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ServiceOverride">
            <summary>
              Represents a service override.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey(System.String)">
            <summary>
              Creates a <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/> with key.
            </summary>
            <param name="key">The service override key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey(System.Type)">
            <summary>
              Creates a <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/> with key.
            </summary>
            <param name="key">The service override key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey``1">
            <summary>
              Creates a <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/> with key.
            </summary>
            <typeparam name="TKey">The service override key.</typeparam>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverride.op_Implicit(Castle.MicroKernel.Registration.ServiceOverride)~Castle.MicroKernel.Registration.Dependency">
            <summary>
              Implicitly converts service override to dependency. This is a API trick to keep the API clean and focused.
            </summary>
            <param name = "item"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ServiceOverride.Type">
            <summary>
              Gets the optional value type specifier.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ServiceOverrideKey">
            <summary>
              Represents a service override key.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.String)">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/value.
            </summary>
            <param name="value">The service override value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.String[])">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service override values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq``1(System.String[])">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service override values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
            <typeparam name="V">The value type.</typeparam>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service override values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service override values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
            <typeparam name="V">The value type.</typeparam>
        </member>
        <member name="T:Castle.MicroKernel.Registration.AllTypes">
            <summary>
              Describes a set of components to register in the kernel. Use static methods on the class to fluently build registration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.From(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
              Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.From(System.Type[])">
            <summary>
              Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssembly(System.Reflection.Assembly)">
            <summary>
              Prepares to register types from an assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyContaining(System.Type)">
            <summary>
              Prepares to register types from an assembly containing the type.
            </summary>
            <param name="type">The type belonging to the assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyContaining``1">
            <summary>
              Prepares to register types from an assembly containing the type.
            </summary>
            <typeparam name="T">The type belonging to the assembly.</typeparam>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyInDirectory(Castle.MicroKernel.Registration.AssemblyFilter)">
            <summary>
              Prepares to register types from assemblies found in a given directory that meet additional optional restrictions.
            </summary>
            <param name = "filter"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyNamed(System.String)">
            <summary>
              Prepares to register types from an assembly.
            </summary>
            <param name="assemblyName">The assembly name.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromThisAssembly">
            <summary>
              Prepares to register types from the assembly containing the code invoking this method.
            </summary>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Of(System.Type)">
            <summary>
              Describes all the types based on <c>basedOn</c>.
            </summary>
            <param name = "basedOn">The base type.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Of``1">
            <summary>
              Describes all the types based on type T.
            </summary>
            <typeparam name = "T">The base type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Pick">
            <summary>
              Describes any types that are supplied.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Pick(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
              Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.AllTypesOf">
            <summary>
              Describes a related group of components to register in the kernel.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.From(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
              Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.From(System.Type[])">
            <summary>
              Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.FromAssembly(System.Reflection.Assembly)">
            <summary>
              Prepares to register types from an assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.FromAssemblyNamed(System.String)">
            <summary>
              Prepares to register types from an assembly.
            </summary>
            <param name="assemblyName">The assembly name.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.Pick(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
              Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.FromAssemblyDescriptor">
            <summary>
              Selects a set of types from an assembly.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.FromDescriptor">
            <summary>
              Describes the source of types to register.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.AllowMultipleMatches">
            <summary>
              Allows a type to be registered multiple times.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.BasedOn``1">
            <summary>
              Returns the descriptor for accepting a type.
            </summary>
            <typeparam name = "T">The base type.</typeparam>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.BasedOn(System.Type)">
            <summary>
              Returns the descriptor for accepting a type.
            </summary>
            <param name = "basedOn">The base type.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InNamespace(System.String)">
            <summary>
              Creates a predicate to check if a component is in a namespace.
            </summary>
            <param name = "namespace">The namespace.</param>
            <returns>true if the component type is in the namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InNamespace(System.String,System.Boolean)">
            <summary>
              Creates a predicate to check if a component is in a namespace.
            </summary>
            <param name = "namespace">The namespace.</param>
            <param name = "includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
            <returns>true if the component type is in the namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InSameNamespaceAs(System.Type)">
            <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <param name = "type">The component type to test namespace against.</param>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <param name = "type">The component type to test namespace against.</param>
            <param name = "includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InSameNamespaceAs``1">
            <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <typeparam name = "T">The component type to test namespace against.</typeparam>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InSameNamespaceAs``1(System.Boolean)">
            <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <typeparam name = "T">The component type to test namespace against.</typeparam>
            <param name = "includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.Pick">
            <summary>
              Returns the descriptor for accepting any type from given solutions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.Where(System.Predicate{System.Type})">
            <summary>
              Returns the descriptor for accepting a type based on a condition.
            </summary>
            <param name = "accepted">The accepting condition.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromAssemblyDescriptor.IncludeNonPublicTypes">
            <summary>
              When called also non-public types will be scanned.
            </summary>
            <remarks>
              Usually it is not recommended to register non-public types in the container so think twice before using this option.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Registration.FromTypesDescriptor">
            <summary>
              Selects an existing set of types to register.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ServiceDescriptor">
            <summary>
              Describes how to select a types service.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.AllInterfaces">
            <summary>
              Uses all interfaces implemented by the type (or its base types) as well as their base interfaces.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Base">
            <summary>
              Uses the base type matched on.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.DefaultInterfaces">
            <summary>
              Uses all interfaces that have names matched by implementation type name.
              Matches Foo to IFoo, SuperFooExtended to IFoo and IFooExtended etc
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FirstInterface">
            <summary>
              Uses the first interface of a type. This method has non-deterministic behavior when type implements more than one interface!
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FromInterface(System.Type)">
            <summary>
              Uses <paramref name = "implements" /> to lookup the sub interface.
              For example: if you have IService and 
              IProductService : ISomeInterface, IService, ISomeOtherInterface.
              When you call FromInterface(typeof(IService)) then IProductService
              will be used. Useful when you want to register _all_ your services
              and but not want to specify all of them.
            </summary>
            <param name = "implements"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FromInterface">
            <summary>
              Uses base type to lookup the sub interface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Select(Castle.MicroKernel.Registration.ServiceDescriptor.ServiceSelector)">
            <summary>
              Assigns a custom service selection strategy.
            </summary>
            <param name = "selector"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Select(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
              Assigns the supplied service types.
            </summary>
            <param name = "types"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Self">
            <summary>
              Uses the type itself.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.WorkaroundCLRBug(System.Type)">
            <summary>
              This is a workaround for a CLR bug in
              which GetInterfaces() returns interfaces
              with no implementations.
            </summary>
            <param name = "serviceType">Type of the service.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.BasedOnDescriptor">
            <summary>
              Describes how to register a group of related types.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.#ctor(System.Type,Castle.MicroKernel.Registration.FromDescriptor,System.Predicate{System.Type})">
            <summary>
              Initializes a new instance of the BasedOnDescriptor.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.AllowMultipleMatches">
            <summary>
              Allows a type to be registered multiple times.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.BasedOn``1">
            <summary>
              Returns the descriptor for accepting a new type.
            </summary>
            <typeparam name = "T">The base type.</typeparam>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.BasedOn(System.Type)">
            <summary>
              Returns the descriptor for accepting a new type.
            </summary>
            <param name = "basedOn">The base type.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Configure(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
              Allows customized configurations of each matching type.
            </summary>
            <param name = "configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.ConfigureFor``1(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
              Allows customized configurations of each matching component with implementation type that is 
              assignable to
              <typeparamref name = "TComponentImplementationType" />
              .
            </summary>
            <typeparam name = "TComponentImplementationType">The type assignable from.</typeparam>
            <param name = "configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.ConfigureIf(System.Predicate{Castle.MicroKernel.Registration.ComponentRegistration},System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
              Allows customized configurations of each matching component that satisfies supplied <paramref name = "condition" />.
            </summary>
            <param name = "condition">Condition to satisfy</param>
            <param name = "configurer">The configuration action, executed only for components for which <paramref
               name = "condition" /> evaluates to <c>true</c>.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.ConfigureIf(System.Predicate{Castle.MicroKernel.Registration.ComponentRegistration},System.Action{Castle.MicroKernel.Registration.ComponentRegistration},System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
              Allows customized configurations of each matching component that satisfies supplied <paramref name = "condition" /> and alternative configuration for the rest of components.
            </summary>
            <param name = "condition">Condition to satisfy</param>
            <param name = "configurerWhenTrue">The configuration action, executed only for components for which <paramref
               name = "condition" /> evaluates to <c>true</c>.</param>
            <param name = "configurerWhenFalse">The configuration action, executed only for components for which <paramref
               name = "condition" /> evaluates to <c>false</c>.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.If(System.Predicate{System.Type})">
            <summary>
              Assigns a conditional predication which must be satisfied.
            </summary>
            <param name = "ifFilter">The predicate to satisfy.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Unless(System.Predicate{System.Type})">
            <summary>
              Assigns a conditional predication which must not be satisfied.
            </summary>
            <param name = "unlessFilter">The predicate not to satisify.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Where(System.Predicate{System.Type})">
            <summary>
              Returns the descriptor for accepting a type based on a condition.
            </summary>
            <param name = "accepted">The accepting condition.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceAllInterfaces">
            <summary>
              Uses all interfaces implemented by the type (or its base types) as well as their base interfaces.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceBase">
            <summary>
              Uses the base type matched on.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceDefaultInterfaces">
            <summary>
              Uses all interfaces that have names matched by implementation type name.
              Matches Foo to IFoo, SuperFooExtended to IFoo and IFooExtended etc
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceFirstInterface">
            <summary>
              Uses the first interface of a type. This method has non-deterministic behavior when type implements more than one interface!
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceFromInterface(System.Type)">
            <summary>
              Uses <paramref name = "implements" /> to lookup the sub interface.
              For example: if you have IService and 
              IProductService : ISomeInterface, IService, ISomeOtherInterface.
              When you call FromInterface(typeof(IService)) then IProductService
              will be used. Useful when you want to register _all_ your services
              and but not want to specify all of them.
            </summary>
            <param name = "implements"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceFromInterface">
            <summary>
              Uses base type to lookup the sub interface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceSelect(Castle.MicroKernel.Registration.ServiceDescriptor.ServiceSelector)">
            <summary>
              Assigns a custom service selection strategy.
            </summary>
            <param name = "selector"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceSelf">
            <summary>
              Uses the type itself.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleCustom(System.Type)">
            <summary>
              Sets component lifestyle to specified one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleCustom``1">
            <summary>
              Sets component lifestyle to specified one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestylePerThread">
            <summary>
              Sets component lifestyle to per thread.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleScoped">
            <summary>
              Sets component lifestyle to scoped per explicit scope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleScoped(System.Type)">
            <summary>
              Sets component lifestyle to scoped per explicit scope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleScoped``1">
            <summary>
              Sets component lifestyle to scoped per explicit scope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleBoundTo``1">
            <summary>
              Sets component lifestyle to scoped per component <typeparamref name = "TBaseForRoot" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestylePerWebRequest">
            <summary>
              Sets component lifestyle to instance per web request.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestylePooled(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
              Sets component lifestyle to pooled. If <paramref name = "initialSize" /> or <paramref name = "maxSize" /> are not set default values will be used.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleSingleton">
            <summary>
              Sets component lifestyle to singleton.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleTransient">
            <summary>
              Sets component lifestyle to transient.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServices(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
              Assigns the supplied service types.
            </summary>
            <param name = "types"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServices(System.Type[])">
            <summary>
              Assigns the supplied service types.
            </summary>
            <param name = "types"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.BasedOnDescriptor.WithService">
            <summary>
              Gets the service descriptor.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy">
            <summary>
              Tracks all components requiring decomission (<see cref="P:Castle.MicroKernel.Burden.RequiresPolicyRelease"/>)
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IReleasePolicy">
            <summary>
              Policy managing lifetime of components, and in particular their release process.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IReleasePolicy.CreateSubPolicy">
            <summary>
              Creates nested policy for scoped object tracking.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IReleasePolicy.HasTrack(System.Object)">
            <summary>
              Returns <c>true</c> if <paramref name = "instance" /> is being tracked by this release policy, <c>false</c> otherwise.
            </summary>
            <param name = "instance"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IReleasePolicy.Release(System.Object)">
            <summary>
              Releases <paramref name="instance"/> if it's being tracked by this release policy, invoking its <see cref="T:Castle.Core.IDecommissionConcern"/>s and stops tracking it so that it can be claimed by the Garbage Collector.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IReleasePolicy.Track(System.Object,Castle.MicroKernel.Burden)">
            <summary>
              Asks the policy to track given object. The object will be released when a call to <see cref="M:Castle.MicroKernel.IReleasePolicy.Release(System.Object)"/> is made.
            </summary>
            <param name="instance"></param>
            <param name="burden"></param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="burden"/> does NOT have its <see cref="P:Castle.MicroKernel.Burden.RequiresPolicyRelease"/> flag set.</exception>
        </member>
        <member name="M:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy.#ctor(Castle.MicroKernel.IKernel)">
            <param name="kernel">Used to obtain <see cref="T:Castle.Windsor.Diagnostics.ITrackedComponentsDiagnostic"/> if present.</param>
        </member>
        <member name="M:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy.#ctor(Castle.Windsor.Diagnostics.ITrackedComponentsDiagnostic,Castle.Windsor.Diagnostics.ITrackedComponentsPerformanceCounter)">
            <summary>
              Creates new policy which publishes its tracking components count to <paramref
               name = "trackedComponentsPerformanceCounter" /> and exposes diagnostics into <paramref
               name = "trackedComponentsDiagnostic" />.
            </summary>
            <param name = "trackedComponentsDiagnostic"></param>
            <param name = "trackedComponentsPerformanceCounter"></param>
        </member>
        <member name="M:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy.GetTrackedComponentsDiagnostic(Castle.MicroKernel.IKernel)">
            <summary>
              Obtains <see cref="T:Castle.Windsor.Diagnostics.ITrackedComponentsDiagnostic"/> from given <see cref="T:Castle.MicroKernel.IKernel"/> if present.
            </summary>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy.GetTrackedComponentsPerformanceCounter(Castle.Windsor.Diagnostics.IPerformanceMetricsFactory)">
            <summary>
              Creates new <see cref="T:Castle.Windsor.Diagnostics.ITrackedComponentsPerformanceCounter"/> from given <see cref="T:Castle.Windsor.Diagnostics.IPerformanceMetricsFactory"/>.
            </summary>
            <param name="perfMetricsFactory"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.NoTrackingReleasePolicy">
            <summary>
              No tracking of component instances are made.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.DefaultDependencyResolver">
            <summary>
              Default implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver"/>.
              This implementation is quite simple, but still should be useful
              for 99% of situations.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IDependencyResolver">
            <summary>
              Implementors should use a strategy to obtain 
              valid references to properties and/or services 
              requested in the dependency model.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
              Registers a sub resolver instance
            </summary>
            <param name = "subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.Initialize(Castle.MicroKernel.IKernelInternal,Castle.MicroKernel.DependencyDelegate)">
            <summary>
              This method is called with a delegate for firing the
              IKernelEvents.DependencyResolving event.
            </summary>
            <param name = "kernel">kernel</param>
            <param name = "resolving">The delegate used to fire the event</param>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
              Unregisters a sub resolver instance previously registered
            </summary>
            <param name = "subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
              Registers a sub resolver instance
            </summary>
            <param name = "subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Initialize(Castle.MicroKernel.IKernelInternal,Castle.MicroKernel.DependencyDelegate)">
            <summary>
              Initializes this instance with the specified dependency delegate.
            </summary>
            <param name = "kernel">kernel</param>
            <param name = "dependencyDelegate">The dependency delegate.</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
              Unregisters a sub resolver instance previously registered
            </summary>
            <param name = "subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.CanResolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
              Returns true if the resolver is able to satisfy the specified dependency.
            </summary>
            <param name = "context">Creation context, which is a resolver itself</param>
            <param name = "contextHandlerResolver">Parent resolver</param>
            <param name = "model">Model of the component that is requesting the dependency</param>
            <param name = "dependency">The dependency model</param>
            <returns>
              <c>true</c>
              if the dependency can be satisfied</returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Resolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
              Try to resolve the dependency by checking the parameters in 
              the model or checking the Kernel for the requested service.
            </summary>
            <remarks>
              The dependency resolver has the following precedence order:
              <list type="bullet">
                <item>
                  <description>The dependency is checked within the
                    <see cref="T:Castle.MicroKernel.Context.CreationContext"/>
                  </description>
                </item>
                <item>
                  <description>The dependency is checked within the
                    <see cref="T:Castle.MicroKernel.IHandler"/>
                    instance for the component</description>
                </item>
                <item>
                  <description>The dependency is checked within the registered
                    <see cref="T:Castle.MicroKernel.ISubDependencyResolver"/>
                    s</description>
                </item>
                <item>
                  <description>Finally the resolver tries the normal flow 
                    which is using the configuration
                    or other component to satisfy the dependency</description>
                </item>
              </list>
            </remarks>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="contextHandlerResolver">Parent resolver</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns>The dependency resolved value or null</returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RebuildContextForParameter(Castle.MicroKernel.Context.CreationContext,System.Type)">
            <summary>
              This method rebuild the context for the parameter type.
              Naive implementation.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ArrayResolver">
            <summary>
              Handle dependencies of services in the format of typed arrays.
            </summary>
            <remarks>
              This is a complimentary <see cref="T:Castle.MicroKernel.ISubDependencyResolver"/> implementation 
              that is capable of satisfying dependencies of services as typed arrays.
              <para>
                Note that it will take precedence over service override for arrays defined 
                on the configuration.
              </para>
            </remarks>
            <example>
              In order to install the resolver:
              <code>
                var kernel = new DefaultKernel();
                kernel.Resolver.AddSubResolver(new ArrayResolver(kernel));
              </code>
            
              <para>
                To use it, assuming that IService is on the container:
              </para>
            
              <code>
                public class Component
                {
                public Component(IService[] services)
                {
                }
                }
              </code>
            </example>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.CollectionResolver">
            <summary>
              More generic alternative to <see cref="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ArrayResolver"/> and <see cref="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ListResolver"/>.
              It supports arrays as well as any generic interface type assignable from arrays.
            </summary>
            <remarks>
              The collection instance that is provided is read only, even for interfaces like <see cref="T:System.Collections.Generic.IList`1"/>
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ListResolver">
            <summary>
              Handle dependencies of services in the format of generic IList.
            </summary>
            <remarks>
              This is a complimentary <see cref="T:Castle.MicroKernel.ISubDependencyResolver"/> implementation 
              that is capable of satisfying dependencies of services generic IList.
              <para>
                Note that it will take precedence over service override for lists defined 
                on the configuration.
              </para>
            </remarks>
            <example>
              In order to install the resolver:
              <code>
                var kernel = new DefaultKernel();
                kernel.Resolver.AddSubResolver(new ListResolver(kernel));
              </code>
            
              <para>
                To use it, assuming that IService is on the container:
              </para>
            
              <code>
                public class Component
                {
                public Component(IList&lt;IService&gt; services)
                {
                }
                }
              </code>
            </example>
        </member>
        <member name="T:Castle.MicroKernel.ISubSystem">
            <summary>
              A subsystem is used by the MicroKernel to deal 
              with a specific concern.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ISubSystem.Init(Castle.MicroKernel.IKernelInternal)">
            <summary>
              Initializes the subsystem
            </summary>
            <param name = "kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.ISubSystem.Terminate">
            <summary>
              Should perform the termination
              of the subsystem instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore">
            <summary>
              This implementation of <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/>
              does not try to obtain an external configuration by any means.
              Its only purpose is to serve as a base class for subclasses
              that might obtain the configuration node from anywhere.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore">
            <summary>
              The contract used by the kernel to obtain
              external configuration for the components and
              facilities.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.AddChildContainerConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Adds the child container configuration.
            </summary>
            <param name = "name">The container's name.</param>
            <param name = "config">The config.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Associates a configuration node with a component key
            </summary>
            <param name = "key">item key</param>
            <param name = "config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Associates a configuration node with a facility key
            </summary>
            <param name = "key">item key</param>
            <param name = "config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetChildContainerConfiguration(System.String)">
            <summary>
              Returns the configuration node associated with 
              the specified child container key. Should return null
              if no association exists.
            </summary>
            <param name = "key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetComponentConfiguration(System.String)">
            <summary>
              Returns the configuration node associated with 
              the specified component key. Should return null
              if no association exists.
            </summary>
            <param name = "key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetComponents">
            <summary>
              Returns all configuration nodes for components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetConfigurationForChildContainers">
            <summary>
              Gets the child containers configuration nodes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetFacilities">
            <summary>
              Returns all configuration nodes for facilities
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetFacilityConfiguration(System.String)">
            <summary>
              Returns the configuration node associated with 
              the specified facility key. Should return null
              if no association exists.
            </summary>
            <param name = "key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetInstallers">
            <summary>
              Returns all configuration nodes for installers
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetResource(System.String,Castle.Core.Resource.IResource)">
            <summary>
            </summary>
            <param name = "resourceUri"></param>
            <param name = "resource"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddChildContainerConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Adds the child container configuration.
            </summary>
            <param name = "key">The key.</param>
            <param name = "config">The config.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Associates a configuration node with a component key
            </summary>
            <param name = "key">item key</param>
            <param name = "config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Associates a configuration node with a facility key
            </summary>
            <param name = "key">item key</param>
            <param name = "config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetChildContainerConfiguration(System.String)">
            <summary>
              Returns the configuration node associated with
              the specified child container key. Should return null
              if no association exists.
            </summary>
            <param name = "key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponentConfiguration(System.String)">
            <summary>
              Returns the configuration node associated with
              the specified component key. Should return null
              if no association exists.
            </summary>
            <param name = "key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponents">
            <summary>
              Returns all configuration nodes for components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetConfigurationForChildContainers">
            <summary>
              Returns all configuration nodes for child containers
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilities">
            <summary>
              Returns all configuration nodes for facilities
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilityConfiguration(System.String)">
            <summary>
              Returns the configuration node associated with
              the specified facility key. Should return null
              if no association exists.
            </summary>
            <param name = "key">item key</param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter">
            <summary>
              Base implementation of <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter">
            <summary>
              Implements a conversion logic to a type of a
              set of types.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type)">
            <summary>
              Returns true if this instance of <c>ITypeConverter</c>
              is able to handle the specified type.
            </summary>
            <param name = "type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Returns true if this instance of <c>ITypeConverter</c>
              is able to handle the specified type with the specified 
              configuration
            </summary>
            <param name = "type"></param>
            <param name = "configuration"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(System.String,System.Type)">
            <summary>
              Should perform the conversion from the
              string representation specified to the type
              specified.
            </summary>
            <param name = "value"></param>
            <param name = "targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(Castle.Core.Configuration.IConfiguration,System.Type)">
            <summary>
              Should perform the conversion from the
              configuration node specified to the type
              specified.
            </summary>
            <param name = "configuration"></param>
            <param name = "targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Returns true if this instance of <c>ITypeConverter</c>
              is able to handle the specified type with the specified
              configuration
            </summary>
            <param name = "type"></param>
            <param name = "configuration"></param>
            <returns></returns>
            <remarks>
              The default behavior is to just pass it to the normal CanHadnleType
              peeking into the configuration is used for some advanced functionality
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.AttributeAwareConverter">
            <summary>
              Looks for a <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute"/> on the type to be converted. 
              If found, the TypeConverter defined by the attribute is used to perform the conversion.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IKernelDependentConverter">
            <summary>
              Marker interface that signals that a converter
              depends on IKernel to be able to perform 
              the conversion.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ComponentModelConverter">
            <summary>
            Attempts to utilize an existing <see cref="T:System.ComponentModel.TypeConverter"/> for conversion
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.CreateInstance(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Creates the target type instance.
            </summary>
            <param name = "type">The type.</param>
            <param name = "configuration">The configuration.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ChooseConstructor(System.Type)">
            <summary>
              Chooses the first non default constructor. Throws an exception if more than 
              one non default constructor is found
            </summary>
            <param name = "type"></param>
            <returns>The chosen constructor, or <c>null</c> if none was found</returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConvertConstructorParameters(System.Reflection.ConstructorInfo,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Converts the constructor parameters.
            </summary>
            <param name = "constructor">The constructor.</param>
            <param name = "configuration">The configuration.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConvertPropertyValues(System.Object,System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
              Converts the property values.
            </summary>
            <param name = "instance">The instance.</param>
            <param name = "type">The type.</param>
            <param name = "configuration">The configuration.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.FindChildIgnoreCase(Castle.Core.Configuration.IConfiguration,System.String)">
            <summary>
              Finds the child (case insensitive).
            </summary>
            <param name = "config">The config.</param>
            <param name = "name">The name.</param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConversionManager">
            <summary>
              Gets the conversion manager.
            </summary>
            <value>The conversion manager.</value>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.EnumConverter">
            <summary>
              Converts a string representation to an enum value
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IGenericCollectionConverterHelper">
            <summary>
              This interface is needed because we want to isolate ourself from
              the generic parameters, so we can work type safe inside the implementations,
              and still call from non generic types outside.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.PrimitiveConverter">
            <summary>
              Implements all standard conversions.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.TypeNameConverter">
            <summary>
              Convert a type name to a Type instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute">
            <summary>
              Declares a type as being convertible by a <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter"/> and optionally defines the converter to be used
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute.#ctor">
            <summary>
              Defines the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter"/> to be used to convert the type
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute.#ctor(System.Type)">
            <summary>
              Defines the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter"/> to be used to convert the type
            </summary>
            <param name="converterType"></param>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.DefaultConversionManager">
            <summary>
              Composition of all available conversion managers
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IConversionManager">
            <summary>
              Establish a composition interface and a subsystem.
              Implementors should delegate the conversion to 
              a instance of a type converter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.IConversionManager.Add(Castle.MicroKernel.SubSystems.Conversion.ITypeConverter)">
            <summary>
              Register a type converter instance.
            </summary>
            <param name = "converter"></param>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem">
            <summary>
              Contract for SubSystem that wishes to keep and coordinate
              component registration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.AddHandlerSelector(Castle.MicroKernel.IHandlerSelector)">
            <summary>
              Register a new component resolver that can take part in the decision
              making about which handler to resolve
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.AddHandlersFilter(Castle.MicroKernel.IHandlersFilter)">
            <summary>
              Register a new component resolver that can take part in the decision
              making about which handler(s) to resolve and in which order
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.Contains(System.String)">
            <summary>
              Returns true if there is a component registered 
              for the specified name
            </summary>
            <param name = "name"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.Contains(System.Type)">
            <summary>
              Returns true if there is a component registered 
              for the specified service
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetAllHandlers">
            <summary>
              Returns all <see cref="T:Castle.MicroKernel.IHandler"/> registered.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetAssignableHandlers(System.Type)">
            <summary>
              Return <see cref="T:Castle.MicroKernel.IHandler"/>s where components are compatible
              with the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandler(System.String)">
            <summary>
              Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
              the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandler(System.Type)">
            <summary>
              Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
              the specified service.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandlers(System.Type)">
            <summary>
              Returns an array of <see cref="T:Castle.MicroKernel.IHandler"/> associated with
              the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.Register(Castle.MicroKernel.IHandler)">
            <summary>
              Implementors should register the <see cref="T:Castle.MicroKernel.IHandler"/> with all <see cref="P:Castle.Core.ComponentModel.Services"/> its <see cref="P:Castle.MicroKernel.IHandler.ComponentModel"/> exposes.
              The handler should also be accessible via unique <see cref="P:Castle.Core.ComponentModel.Name"/> of its <see cref="P:Castle.MicroKernel.IHandler.ComponentModel"/>.
            </summary>
            <param name="handler"></param>
            <exception cref="T:Castle.MicroKernel.ComponentRegistrationException">Thrown if the <see cref="P:Castle.Core.ComponentModel.Name"/> of <paramref name="handler"/>'s <see cref="P:Castle.MicroKernel.IHandler.ComponentModel"/> is not unique and a handler with the same name has already been registered.</exception>
        </member>
        <member name="P:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.ComponentCount">
            <summary>
              Returns the number of components registered.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.name2Handler">
            <summary>
              Map(String, IHandler) to map component names
              to <see cref="T:Castle.MicroKernel.IHandler"/>
              Items in this dictionary are sorted in insertion order.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.service2Handler">
            <summary>
              Map(Type, IHandler) to map a service
              to <see cref="T:Castle.MicroKernel.IHandler"/>.
              If there is more than a single service of the type, only the first
              registered services is stored in this dictionary.
              It serve as a fast lookup for the common case of having a single handler for 
              a type.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandlerSelector">
            <summary>
              Implementors of this interface allow to extend the way the container perform
              component resolution based on some application specific business logic.
            </summary>
            <remarks>
              This is the sibling interface to <seealso cref="T:Castle.MicroKernel.ISubDependencyResolver"/>.
              This is dealing strictly with root components, while the <seealso cref="T:Castle.MicroKernel.ISubDependencyResolver"/> is dealing with
              dependent components.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IHandlerSelector.HasOpinionAbout(System.String,System.Type)">
            <summary>
              Whatever the selector has an opinion about resolving a component with the 
              specified service and key.
            </summary>
            <param name = "key">The service key - can be null</param>
            <param name = "service">The service interface that we want to resolve</param>
        </member>
        <member name="M:Castle.MicroKernel.IHandlerSelector.SelectHandler(System.String,System.Type,Castle.MicroKernel.IHandler[])">
            <summary>
              Select the appropriate handler from the list of defined handlers.
              The returned handler should be a member from the <paramref name = "handlers" /> array.
            </summary>
            <param name = "key">The service key - can be null</param>
            <param name = "service">The service interface that we want to resolve</param>
            <param name = "handlers">The defined handlers</param>
            <returns>The selected handler, or null</returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Resource.DefaultResourceSubSystem">
            <summary>
              Pendent
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem">
            <summary>
              An implementation of <c>a</c> should 
              be able to return instances of <see cref="T:Castle.Core.Resource.IResource"/>
              for a given resource identifier.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystemConstants">
            <summary>
              Holds the keys used by Kernel to register/request 
              a subsystem.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ConfigurationStoreKey">
            <summary>
              Key used for the configuration store subsystem
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ConversionManagerKey">
            <summary>
              Key used for the conversion manager
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.DiagnosticsKey">
            <summary>
              Key used for the diagnostics subsystem
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.NamingKey">
            <summary>
              Key used for the naming subsystem
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ResourceKey">
            <summary>
              Key used for the resource subsystem
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.AppDomain.CastleSectionHandler">
            <summary>
              Implementation of <see cref="T:System.Configuration.IConfigurationSectionHandler"/>.
              Do not support configuration inheritance.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.IConfigurationInterpreter">
            <summary>
              Interpreter of a specific language to describe 
              configuration nodes in a hierarchical manner.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.IConfigurationInterpreter.ProcessResource(Castle.Core.Resource.IResource,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore,Castle.MicroKernel.IKernel)">
            <summary>
              Should obtain the contents from the resource,
              interpret it and populate the <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/>
              accordingly.
            </summary>
            <param name="resource"></param>
            <param name="store"></param>
            <param name="kernel"></param>
        </member>
        <member name="P:Castle.Windsor.Configuration.IConfigurationInterpreter.EnvironmentName">
            <summary>
              Gets or sets the name of the environment.
            </summary>
            <value>The name of the environment.</value>
        </member>
        <member name="P:Castle.Windsor.Configuration.IConfigurationInterpreter.Source">
            <summary>
              Exposes the reference to <see cref="T:Castle.Core.Resource.IResource"/>
              which the interpreter is likely to hold
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter">
            <summary>
              Provides common methods for those who wants 
              to implement <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter"/>
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.ProcessResource(Castle.Core.Resource.IResource,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore,Castle.MicroKernel.IKernel)">
            <summary>
              Should obtain the contents from the resource,
              interpret it and populate the <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/>
              accordingly.
            </summary>
            <param name="resource"></param>
            <param name="store"></param>
            <param name="kernel"></param>
        </member>
        <member name="P:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.Source">
            <summary>
              Exposes the reference to <see cref="T:Castle.Core.Resource.IResource"/>
              which the interpreter is likely to hold
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.EnvironmentName">
            <summary>
              Gets or sets the name of the environment.
            </summary>
            <value>The name of the environment.</value>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter">
            <summary>
              Reads the configuration from a XmlFile. Sample structure:
              <code>
                &lt;configuration&gt;
                &lt;facilities&gt;
                &lt;facility id="myfacility"&gt;
                
                &lt;/facility&gt;
                &lt;/facilities&gt;
              
                &lt;components&gt;
                &lt;component id="component1"&gt;
                
                &lt;/component&gt;
                &lt;/components&gt;
                &lt;/configuration&gt;
              </code>
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter"/> class.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter"/> class.
            </summary>
            <param name="filename">The filename.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor(Castle.Core.Resource.IResource)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter"/> class.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine"/> class.
            </summary>
            <param name="environmentName">Name of the environment.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.#ctor(System.String,Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine"/> class.
            </summary>
            <param name="environmentName">Name of the environment.</param>
            <param name="resourceSubSystem">The resource sub system.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.DispatchProcessAll(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList)">
            <summary>
              Processes the element.
            </summary>
            <param name = "nodeList">The element.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.DispatchProcessCurrent(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList)">
            <summary>
              Processes the element.
            </summary>
            <param name = "nodeList">The element.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorNodeList.CloneNodeList(System.Xml.XmlNodeList)">
            <summary>
              Make a shallow copy of the nodeList.
            </summary>
            <param name = "nodeList">The nodeList to be copied.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AbstractXmlNodeProcessor.Accept(System.Xml.XmlNode)">
            <summary>
              Accepts the specified node.
              Check if node has the same name as the processor and the node.NodeType
              is in the AcceptNodeTypes List
            </summary>
            <param name = "node">The node.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AbstractXmlNodeProcessor.GetNodeAsElement(System.Xml.XmlElement,System.Xml.XmlNode)">
            <summary>
              Convert and return child parameter into an XmlElement
              An exception will be throw in case the child node cannot be converted
            </summary>
            <param name = "element">Parent node</param>
            <param name = "child">Node to be converted</param>
            <returns>child node as XmlElement</returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AttributesElementProcessor.Process(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
            <summary>
            </summary>
            <param name = "nodeList"></param>
            <param name = "engine"></param>
            <example>
              <code>
                <properties>
                  <attributes>
                    <myAttribute>attributeValue</myAttribute>
                  </attributes>
                  <myProperty>propertyValue</myProperty>
                </properties>
              </code>
            </example>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultElementProcessor.Process(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
            <summary>
              Processes the specified node list.
            </summary>
            <param name = "nodeList">The node list.</param>
            <param name = "engine">The engine.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultElementProcessor.ProcessAttributes(System.Xml.XmlElement,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
            <summary>
              Processes element attributes.
              if the attribute is include will append to the element
              all contents from the file.
              if the attribute has a property reference the reference will be
              expanded
            </summary>
            <param name = "element">The element.</param>
            <param name = "engine"></param>
        </member>
        <member name="F:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultTextNodeProcessor.PropertyValidationRegExp">
            <summary>
              Properties names can contain a-zA-Z0-9_. 
              i.e. #!{ my_node_name } || #{ my.node.name }
              spaces are trimmed
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultTextNodeProcessor.ProcessString(System.Xml.XmlNode,System.String,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
            <summary>
              Processes the string.
            </summary>
            <param name = "node">The node.</param>
            <param name = "value">The value.</param>
            <param name = "engine">The context.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.IncludeElementProcessor.Accept(System.Xml.XmlNode)">
            <summary>
              Accepts the specified node.
              Check if node has the same name as the processor and the node.NodeType
              is in the AcceptNodeTypes List
              NOTE: since the BatchRegistrationFacility already uses an include
              element we will distinguish between both by looking for the presence of an uri attribute
              we should revisit this later by using xml-namespaces
            </summary>
            <param name = "node">The node.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.PropertiesElementProcessor.Process(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
            <summary>
            </summary>
            <param name = "nodeList"></param>
            <param name = "engine"></param>
            <example>
              <code>
                <properties>
                  <attributes>
                    <myAttribute>attributeValue</myAttribute>
                  </attributes>
                  <myProperty>propertyValue</myProperty>
                </properties>
              </code>
            </example>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor">
            <summary>
              Pendent
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor"/> class.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor(System.String,Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor"/> class.
            </summary>
            <param name="environmentName">Name of the environment.</param>
            <param name="resourceSubSystem">The resource sub system.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor"/> class.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Diagnostics.IAllComponentsDiagnostic">
            <summary>
              Collects all handlers for components in hosting container.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Diagnostics.IDiagnostic`1">
            <summary>
              Base inteface for exposing diagnostic information about container, its components and extensions
            </summary>
            <typeparam name = "T"></typeparam>
        </member>
        <member name="M:Castle.Windsor.Diagnostics.IDiagnostic`1.Inspect">
            <summary>
              Collects specified diagnostic information.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Castle.Windsor.Diagnostics.IAllServicesDiagnostic">
            <summary>
              Collects all handlers for components in hosting container grouped by services they expose.
              Within the service group, first one would be the default (the one obtained when callling <see cref="M:Castle.MicroKernel.IKernel.Resolve(System.Type)"/> for the service type)
            </summary>
        </member>
        <member name="T:Castle.Windsor.Diagnostics.IDiagnosticsHost">
            <summary>
              Hosts different diagnostics available in the container.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Diagnostics.IDiagnosticsHost.AddDiagnostic``1(``0)">
            <summary>
              Adds <paramref name="diagnostic"/> and makes it available as <typeparamref name="TDiagnostic"/>.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when a diagnostic for <typeparamref name="TDiagnostic"/>has already been added.</exception>
        </member>
        <member name="M:Castle.Windsor.Diagnostics.IDiagnosticsHost.GetDiagnostic``1">
            <summary>
              Returns diagnostic registered with <typeparamref name = "TDiagnostic" /> or <c>null</c> if not present.
            </summary>
            <typeparam name = "TDiagnostic"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Castle.Windsor.Diagnostics.IUsingContainerAsServiceLocatorDiagnostic">
            <summary>
              Detects components that are not extending Windsor's infrastructure yet depend on the container which usually means they use the container as service locator
              which is a bad practice and should be avoided. Consult the documentation for more details: http://j.mp/WindsorSL
            </summary>
        </member>
        <member name="T:Castle.Windsor.Diagnostics.IExposeDiagnostics`1">
            <summary>
              Exposes diagnostics about itself to the <see cref="T:Castle.Windsor.Diagnostics.IDiagnosticsInspector`2"/>.
            </summary>
            <typeparam name="TData">Usually simple type containing information provided to the <see cref="T:Castle.Windsor.Diagnostics.IDiagnosticsInspector`2"/>.</typeparam>
            <remarks>
              Can be implemented by any type constituting part of container infrastructure. Should have a matching <see cref="T:Castle.Windsor.Diagnostics.IDiagnosticsInspector`2"/> registred in the container that knows
              how to find it and that prepares information from it for consumption.
            </remarks>
        </member>
        <member name="M:Castle.Windsor.Diagnostics.IExposeDiagnostics`1.Visit``1(Castle.Windsor.Diagnostics.IDiagnosticsInspector{`0,``0},``0)">
            <summary>
              Collects <typeparamref name="TData"/> for the <paramref name="inspector"/> and calls <see cref="M:Castle.Windsor.Diagnostics.IDiagnosticsInspector`2.Inspect(`0,`1)"/> if any data available.
            </summary>
            <param name="inspector"></param>
            <param name="context">pass-through context. Used by the inspector.</param>
        </member>
        <member name="T:Castle.Windsor.IEnvironmentInfo">
            <summary>
              Gets the environment information (name). Implementors should 
              use to define their environments and how those affect the configuration.
            </summary>
        </member>
        <member name="M:Castle.Windsor.IEnvironmentInfo.GetEnvironmentName">
            <summary>
              Gets the name of the environment.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.Configuration.FromAppConfig">
            <summary>
              Installs all the components from the App.Config file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.Configuration.FromXml(Castle.Core.Resource.IResource)">
            <summary>
              Installs all the component from the xml configuration.
            </summary>
            <param name = "resource">The xml configuration resource.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.Configuration.FromXmlFile(System.String)">
            <summary>
              Installs all the component from the xml configuration file.
            </summary>
            <param name = "file">The xml configuration file.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.Windsor.Installer.EnvironmentDelegate">
            <summary>
              Delegate to provide environment name.
            </summary>
            <returns>The environment name.</returns>
        </member>
        <member name="M:Castle.Windsor.Installer.ConfigurationInstaller.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter)">
            <summary>
              Initializes a new instance of the ConfigurationInstaller class.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Installer.ConfigurationInstaller.Environment(System.String)">
            <summary>
              Sets the configuration environment name.
            </summary>
            <param name = "environmentName">The environment name.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.ConfigurationInstaller.Environment(Castle.Windsor.Installer.EnvironmentDelegate)">
            <summary>
              Set the configuration environment strategy.
            </summary>
            <param name = "environment">The environment strategy.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.Windsor.Installer.DefaultComponentInstaller">
            <summary>
              Default <see cref="T:Castle.Windsor.IComponentsInstaller"/> implementation.
            </summary>
        </member>
        <member name="T:Castle.Windsor.IComponentsInstaller">
            <summary>
              Installs the components and facilities based on the
              information on the configuration store.
            </summary>
        </member>
        <member name="M:Castle.Windsor.IComponentsInstaller.SetUp(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
            <summary>
              Perform installation.
            </summary>
            <param name = "container">Target container</param>
            <param name = "store">Configuration store</param>
        </member>
        <member name="M:Castle.Windsor.Installer.DefaultComponentInstaller.SetUp(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
            <summary>
              Perform installation.
            </summary>
            <param name = "container">Target container</param>
            <param name = "store">Configuration store</param>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Containing(System.Type)">
            <summary>
              Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Containing(System.Type,Castle.Windsor.Installer.InstallerFactory)">
            <summary>
              Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Containing``1">
            <summary>
              Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Containing``1(Castle.Windsor.Installer.InstallerFactory)">
            <summary>
              Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.InDirectory(Castle.MicroKernel.Registration.AssemblyFilter)">
            <summary>
              Scans assemblies in directory specified by <paramref name="filter"/> for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.InDirectory(Castle.MicroKernel.Registration.AssemblyFilter,Castle.Windsor.Installer.InstallerFactory)">
            <summary>
              Scans assemblies in directory specified by <paramref name="filter"/> for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <param name="filter"></param>
            <param name="installerFactory"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.InThisApplication">
            <summary>
              Scans current assembly and all refernced assemblies with the same first part of the name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
            <remarks>
              Assemblies are considered to belong to the same application based on the first part of the name.
              For example if the method is called from within <c>MyApp.exe</c> and <c>MyApp.exe</c> references <c>MyApp.SuperFeatures.dll</c>,
              <c>mscorlib.dll</c> and <c>ThirdPartyCompany.UberControls.dll</c> the <c>MyApp.exe</c> and <c>MyApp.SuperFeatures.dll</c> 
              will be scanned for installers, and other assemblies will be ignored.
            </remarks>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.InThisApplication(Castle.Windsor.Installer.InstallerFactory)">
            <summary>
              Scans current assembly and all refernced assemblies with the same first part of the name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <param name="installerFactory"></param>
            <returns></returns>
            <remarks>
              Assemblies are considered to belong to the same application based on the first part of the name.
              For example if the method is called from within <c>MyApp.exe</c> and <c>MyApp.exe</c> references <c>MyApp.SuperFeatures.dll</c>,
              <c>mscorlib.dll</c> and <c>ThirdPartyCompany.UberControls.dll</c> the <c>MyApp.exe</c> and <c>MyApp.SuperFeatures.dll</c> 
              will be scanned for installers, and other assemblies will be ignored.
            </remarks>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Instance(System.Reflection.Assembly)">
            <summary>
              Scans the specified assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Instance(System.Reflection.Assembly,Castle.Windsor.Installer.InstallerFactory)">
            <summary>
              Scans the specified assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Named(System.String)">
            <summary>
              Scans the assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.Named(System.String,Castle.Windsor.Installer.InstallerFactory)">
            <summary>
              Scans the assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.This">
            <summary>
              Scans assembly that contains code calling this method for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, 
              instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Installer.FromAssembly.This(Castle.Windsor.Installer.InstallerFactory)">
            <summary>
              Scans assembly that contains code calling this method for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/>, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory"/> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])"/> can install them.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Castle.Windsor.Installer.InstallerFactory">
            <summary>
              Helper class used by <see cref="T:Castle.Windsor.Installer.FromAssembly"/> to filter/order and instantiate <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/> implementations
            </summary>
        </member>
        <member name="M:Castle.Windsor.Installer.InstallerFactory.CreateInstance(System.Type)">
            <summary>
              Performs custom instantiation of given <param name = "installerType" />
            </summary>
            <remarks>
              Default implementation uses public parameterless constructor to create the instance.
            </remarks>
        </member>
        <member name="M:Castle.Windsor.Installer.InstallerFactory.Select(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
              Performs custom filtering/ordering of given set of types.
            </summary>
            <param name="installerTypes">Set of concrete class types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller"/> interface.</param>
            <returns>Transformed <paramref name="installerTypes"/>.</returns>
            <remarks>
              Default implementation simply returns types passed into it.
            </remarks>
        </member>
        <member name="T:Castle.Windsor.IWindsorContainer">
            <summary>
              The <c>IWindsorContainer</c> interface exposes all the 
              functionality the Windsor implements.
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddChildContainer(Castle.Windsor.IWindsorContainer)">
            <summary>
              Registers a subcontainer. The components exposed
              by this container will be accessible from subcontainers.
            </summary>
            <param name = "childContainer"></param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility(Castle.MicroKernel.IFacility)">
            <summary>
              Registers a facility within the container.
            </summary>
            <param name="facility">The <see cref="T:Castle.MicroKernel.IFacility"/> to add to the container.</param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="TFacility">The facility type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1(System.Action{``0})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="TFacility">The facility type.</typeparam>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.GetChildContainer(System.String)">
            <summary>
              Gets a child container instance by name.
            </summary>
            <param name = "name">The container's name.</param>
            <returns>The child container instance or null</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])">
            <summary>
              Runs the <paramref name="installers"/> so that they can register components in the container. For details see the documentation at http://j.mp/WindsorInstall
            </summary>
            <remarks>
              In addition to instantiating and passing every installer inline you can use helper methods on <see cref="T:Castle.Windsor.Installer.FromAssembly"/> class to automatically instantiate and run your installers.
              You can also use <see cref="N:Castle.Windsor.Configuration"/> class to install components and/or run aditional installers specofied in a configuration file.
            </remarks>
            <returns>The container.</returns>
            <example>
              <code>
                container.Install(new YourInstaller1(), new YourInstaller2(), new YourInstaller3());
              </code>
            </example>
            <example>
              <code>
                container.Install(FromAssembly.This(), Configuration.FromAppConfig(), new SomeOtherInstaller());
              </code>
            </example>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Register(Castle.MicroKernel.Registration.IRegistration[])">
            <summary>
              Registers the components with the <see cref="T:Castle.Windsor.IWindsorContainer"/>. The instances of <see cref="T:Castle.MicroKernel.Registration.IRegistration"/> are produced by fluent registration API.
              Most common entry points are <see cref="M:Castle.MicroKernel.Registration.Component.For``1"/> method to register a single type or (recommended in most cases) 
              <see cref="M:Castle.MicroKernel.Registration.AllTypes.FromThisAssembly"/>.
              Let the Intellisense drive you through the fluent API past those entry points. For details see the documentation at http://j.mp/WindsorApi
            </summary>
            <example>
              <code>
                container.Register(Component.For&lt;IService&gt;().ImplementedBy&lt;DefaultService&gt;().LifestyleTransient());
              </code>
            </example>
            <example>
              <code>
                container.Register(Classes.FromThisAssembly().BasedOn&lt;IService&gt;().WithServiceDefaultInterfaces().Configure(c =&gt; c.LifestyleTransient()));
              </code>
            </example>
            <param name="registrations">The component registrations created by <see cref="M:Castle.MicroKernel.Registration.Component.For``1"/>, <see cref="M:Castle.MicroKernel.Registration.AllTypes.FromThisAssembly"/> or different entry method to the fluent API.</param>
            <returns>The container.</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Release(System.Object)">
            <summary>
              Releases a component instance
            </summary>
            <param name = "instance"></param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.RemoveChildContainer(Castle.Windsor.IWindsorContainer)">
            <summary>
              Remove a child container
            </summary>
            <param name = "childContainer"></param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Type)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type,System.Object)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <returns>The component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <param name = "arguments"></param>
            <returns>The component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.Object)">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <param name = "argumentsAsAnonymousType"></param>
            <returns>The component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.String)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key">Component's key</param>
            <typeparam name = "T">Service type</typeparam>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.String,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <param name = "key">Component's key</param>
            <param name = "arguments"></param>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.String,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <typeparam name = "T">Service type</typeparam>
            <param name = "key">Component's key</param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Type,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll``1">
            <summary>
              Resolve all valid components that match this type.
            </summary>
            <typeparam name = "T">The service type</typeparam>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll(System.Type)">
            <summary>
              Resolve all valid components that match this service
              <param name = "service">the service to match</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll(System.Type,System.Collections.IDictionary)">
            <summary>
              Resolve all valid components that match this service
              <param name = "service">the service to match</param>
              <param name = "arguments">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll(System.Type,System.Object)">
            <summary>
              Resolve all valid components that match this service
              <param name = "service">the service to match</param>
              <param name = "argumentsAsAnonymousType">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll``1(System.Collections.IDictionary)">
            <summary>
              Resolve all valid components that match this type.
              <typeparam name = "T">The service type</typeparam>
              <param name = "arguments">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll``1(System.Object)">
            <summary>
              Resolve all valid components that match this type.
              <typeparam name = "T">The service type</typeparam>
              <param name = "argumentsAsAnonymousType">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility(System.String,Castle.MicroKernel.IFacility)">
            <summary>
              Registers a facility within the container.
            </summary>
            <param name="idInConfiguration">The key by which the <see cref="T:Castle.MicroKernel.IFacility"/> gets indexed.</param>
            <param name="facility">The <see cref="T:Castle.MicroKernel.IFacility"/> to add to the container.</param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1(System.String)">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="TFacility">The facility type.</typeparam>
            <param name="idInConfiguration"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1(System.String,System.Action{``0})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="TFacility">The facility type.</typeparam>
            <param name="idInConfiguration"></param>
            <param name="configureFacility">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.Windsor.IWindsorContainer.Kernel">
            <summary>
              Returns the inner instance of the MicroKernel
            </summary>
        </member>
        <member name="P:Castle.Windsor.IWindsorContainer.Name">
            <summary>
              Gets the container's name
            </summary>
            <remarks>
              Only useful when child containers are being used
            </remarks>
            <value>The container's name.</value>
        </member>
        <member name="P:Castle.Windsor.IWindsorContainer.Parent">
            <summary>
              Gets or sets the parent container if this instance
              is a sub container.
            </summary>
        </member>
        <member name="T:Castle.Windsor.IContainerAccessor">
            <summary>
              This interface should be implemented by classes
              that are available in a bigger context, exposing
              the container to different areas in the same application.
              <para>
                For example, in Web application, the (global) HttpApplication
                subclasses should implement this interface to expose 
                the configured container
              </para>
            </summary>
        </member>
        <member name="M:Castle.Windsor.Proxy.AbstractProxyFactory.ObtainInterceptors(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext)">
            <summary>
              Obtains the interceptors associated with the component.
            </summary>
            <param name = "kernel">The kernel instance</param>
            <param name = "model">The component model</param>
            <param name = "context">The creation context</param>
            <returns>interceptors array</returns>
        </member>
        <member name="T:Castle.Windsor.Proxy.DefaultProxyFactory">
            <summary>
              This implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/> relies 
              on DynamicProxy to expose proxy capabilities.
            </summary>
            <remarks>
              Note that only virtual methods can be intercepted in a 
              concrete class. However, if the component 
              was registered with a service interface, we proxy
              the interface and the methods don't need to be virtual,
            </remarks>
        </member>
        <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.#ctor">
            <summary>
              Constructs a DefaultProxyFactory
            </summary>
        </member>
        <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,System.Object[])">
            <summary>
              Creates the proxy for the supplied component.
            </summary>
            <param name = "kernel">The kernel.</param>
            <param name = "target">The target.</param>
            <param name = "model">The model.</param>
            <param name = "constructorArguments">The constructor arguments.</param>
            <param name = "context">The creation context</param>
            <returns>The component proxy.</returns>
        </member>
        <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.RequiresTargetInstance(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
              Determines if the component requires a target instance for proxying.
            </summary>
            <param name = "kernel">The kernel.</param>
            <param name = "model">The model.</param>
            <returns>true if an instance is required.</returns>
        </member>
        <member name="T:Castle.Windsor.WindsorContainer">
            <summary>
              Implementation of <see cref="T:Castle.Windsor.IWindsorContainer"/>
              which delegates to <see cref="T:Castle.MicroKernel.IKernel"/> implementation.
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor">
            <summary>
              Constructs a container without any external 
              configuration reference
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
            <summary>
              Constructs a container using the specified 
              <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/> implementation.
            </summary>
            <param name="store">The instance of an <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore"/> implementation.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter)">
            <summary>
              Constructs a container using the specified 
              <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter"/> implementation.
            </summary>
            <param name="interpreter">The instance of an <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter"/> implementation.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter,Castle.Windsor.IEnvironmentInfo)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer"/> class.
            </summary>
            <param name="interpreter">The interpreter.</param>
            <param name="environmentInfo">The environment info.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer"/> class using a
              resource pointed to by the parameter. That may be a file, an assembly embedded resource, a UNC path or a config file section.
              <para>
                Equivalent to the use of <c>new WindsorContainer(new XmlInterpreter(configurationUri))</c>
              </para>
            </summary>
            <param name="configurationUri">The XML file.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.IKernel,Castle.Windsor.IComponentsInstaller)">
            <summary>
              Constructs a container using the specified <see cref="T:Castle.MicroKernel.IKernel"/>
              implementation. Rarely used.
            </summary>
            <remarks>
              This constructs sets the Kernel.ProxyFactory property to
              <c>Proxy.DefaultProxyFactory</c>
            </remarks>
            <param name="kernel">Kernel instance</param>
            <param name="installer">Installer instance</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String,Castle.MicroKernel.IKernel,Castle.Windsor.IComponentsInstaller)">
            <summary>
              Constructs a container using the specified <see cref="T:Castle.MicroKernel.IKernel"/>
              implementation. Rarely used.
            </summary>
            <remarks>
              This constructs sets the Kernel.ProxyFactory property to
              <c>Proxy.DefaultProxyFactory</c>
            </remarks>
            <param name="name">Container's name</param>
            <param name="kernel">Kernel instance</param>
            <param name="installer">Installer instance</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.IProxyFactory)">
            <summary>
              Constructs with a given <see cref="T:Castle.MicroKernel.IProxyFactory"/>.
            </summary>
            <param name="proxyFactory">A instance of an <see cref="T:Castle.MicroKernel.IProxyFactory"/>.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.IWindsorContainer,Castle.Windsor.Configuration.IConfigurationInterpreter)">
            <summary>
              Constructs a container assigning a parent container 
              before starting the dependency resolution.
            </summary>
            <param name="parent">The instance of an <see cref="T:Castle.Windsor.IWindsorContainer"/></param>
            <param name="interpreter">The instance of an <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter"/> implementation</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String,Castle.Windsor.IWindsorContainer,Castle.Windsor.Configuration.IConfigurationInterpreter)">
            <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer"/> class.
            </summary>
            <param name="name">The container's name.</param>
            <param name="parent">The parent.</param>
            <param name="interpreter">The interpreter.</param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Dispose">
            <summary>
              Executes Dispose on underlying <see cref="T:Castle.MicroKernel.IKernel"/>
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddChildContainer(Castle.Windsor.IWindsorContainer)">
            <summary>
              Registers a subcontainer. The components exposed
              by this container will be accessible from subcontainers.
            </summary>
            <param name = "childContainer"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility(Castle.MicroKernel.IFacility)">
            <summary>
              Registers a facility within the container.
            </summary>
            <param name = "facility"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1(System.Action{``0})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.GetChildContainer(System.String)">
            <summary>
              Gets a child container instance by name.
            </summary>
            <param name = "name">The container's name.</param>
            <returns>The child container instance or null</returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])">
            <summary>
              Runs the <paramref name="installers"/> so that they can register components in the container. For details see the documentation at http://j.mp/WindsorInstall
            </summary>
            <remarks>
              In addition to instantiating and passing every installer inline you can use helper methods on <see cref="T:Castle.Windsor.Installer.FromAssembly"/> class to automatically instantiate and run your installers.
              You can also use <see cref="N:Castle.Windsor.Configuration"/> class to install components and/or run aditional installers specofied in a configuration file.
            </remarks>
            <returns>The container.</returns>
            <example>
              <code>
                container.Install(new YourInstaller1(), new YourInstaller2(), new YourInstaller3());
              </code>
            </example>
            <example>
              <code>
                container.Install(FromAssembly.This(), Configuration.FromAppConfig(), new SomeOtherInstaller());
              </code>
            </example>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Register(Castle.MicroKernel.Registration.IRegistration[])">
            <summary>
              Registers the components with the <see cref="T:Castle.Windsor.IWindsorContainer"/>. The instances of <see cref="T:Castle.MicroKernel.Registration.IRegistration"/> are produced by fluent registration API.
              Most common entry points are <see cref="M:Castle.MicroKernel.Registration.Component.For``1"/> method to register a single type or (recommended in most cases) 
              <see cref="M:Castle.MicroKernel.Registration.AllTypes.FromThisAssembly"/>.
              Let the Intellisense drive you through the fluent API past those entry points. For details see the documentation at http://j.mp/WindsorApi
            </summary>
            <example>
              <code>
                container.Register(Component.For&lt;IService&gt;().ImplementedBy&lt;DefaultService&gt;().LifestyleTransient());
              </code>
            </example>
            <example>
              <code>
                container.Register(Classes.FromThisAssembly().BasedOn&lt;IService&gt;().WithServiceDefaultInterfaces().Configure(c =&gt; c.LifestyleTransient()));
              </code>
            </example>
            <param name="registrations">The component registrations created by <see cref="M:Castle.MicroKernel.Registration.Component.For``1"/>, <see cref="M:Castle.MicroKernel.Registration.AllTypes.FromThisAssembly"/> or different entry method to the fluent API.</param>
            <returns>The container.</returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Release(System.Object)">
            <summary>
              Releases a component instance
            </summary>
            <param name = "instance"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.RemoveChildContainer(Castle.Windsor.IWindsorContainer)">
            <summary>
              Removes (unregisters) a subcontainer.  The components exposed by this container
              will no longer be accessible to the child container.
            </summary>
            <param name = "childContainer"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type,System.Object)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type)">
            <summary>
              Returns a component instance by the service
            </summary>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Type)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Type,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "service"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T"></typeparam>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.Object)">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T"></typeparam>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.String,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.String,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1">
            <summary>
              Returns a component instance by the service
            </summary>
            <typeparam name = "T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.String)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.ResolveAll``1">
            <summary>
              Resolve all valid components that match this type.
            </summary>
            <typeparam name = "T">The service type</typeparam>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.ResolveAll``1(System.Collections.IDictionary)">
            <summary>
              Resolve all valid components that match this type.
              <typeparam name = "T">The service type</typeparam>
              <param name = "arguments">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.ResolveAll``1(System.Object)">
            <summary>
              Resolve all valid components that match this type.
              <typeparam name = "T">The service type</typeparam>
              <param name = "argumentsAsAnonymousType">Arguments to resolve the service</param>
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility(System.String,Castle.MicroKernel.IFacility)">
            <summary>
              Registers a facility within the container.
            </summary>
            <param name = "idInConfiguration"></param>
            <param name = "facility"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1(System.String)">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="idInConfiguration"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1(System.String,System.Action{``0})">
            <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the container.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="idInConfiguration"></param>
            <param name="configureFacility">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Object)">
            <summary>
              Returns a component instance by the key
            </summary>
            <param name = "key"></param>
            <param name = "argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.Windsor.WindsorContainer.Kernel">
            <summary>
              Returns the inner instance of the MicroKernel
            </summary>
        </member>
        <member name="P:Castle.Windsor.WindsorContainer.Name">
            <summary>
              Gets the container's name
            </summary>
            <remarks>
              Only useful when child containers are being used
            </remarks>
            <value>The container's name.</value>
        </member>
        <member name="P:Castle.Windsor.WindsorContainer.Parent">
            <summary>
              Gets or sets the parent container if this instance
              is a sub container.
            </summary>
        </member>
        <member name="T:Castle.Windsor.WindsorServiceProvider">
            <summary>
              Implementation of <see cref="T:System.IServiceProvider"/> and <see cref="T:Castle.Core.IServiceProviderEx"/> that uses a <see cref="T:Castle.Windsor.IWindsorContainer"/> or <see cref="T:Castle.MicroKernel.IKernel"/> as its component's source.
            </summary>
        </member>
    </members>
</doc>
