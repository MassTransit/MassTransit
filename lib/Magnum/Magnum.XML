<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Magnum</name>
  </assembly>
  <members>
    <member name="T:Magnum.Actors.Actor">
      <summary>
            Defines a role of actor for a class
            </summary>
    </member>
    <member name="T:Magnum.Actors.ActorFactory`1">
      <summary>
            A builder abstraction for creating actor instances when needed
            </summary>
      <typeparam name="TActor">The actor type</typeparam>
    </member>
    <member name="M:Magnum.Actors.ActorFactory`1.GetActor">
      <summary>
            Returns an instance of an actor
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Channels.Channel">
      <summary>
            A channel represents a one-way communication, well, channel
            </summary>
    </member>
    <member name="T:Magnum.Channels.UntypedChannel">
      <summary>
            A channel to which any message type can be sent
            </summary>
    </member>
    <member name="M:Magnum.Channels.UntypedChannel.Send``1(``0)">
      <summary>
              Send a message to an untyped channel
            </summary>
      <typeparam name="T">The message type</typeparam>
      <param name="message">The message</param>
    </member>
    <member name="T:Magnum.Actors.ActorInstance">
      <summary>
            A reference to an actor instance
            This is mostly an abstraction to avoid passing around the infrastructure
            interface of an Inbox
            </summary>
    </member>
    <member name="T:Magnum.Actors.ActorRegistry">
      <summary>
            An actor registry provide running storage for actors that are active in the system
            </summary>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.Register``1(``0)">
      <summary>
            Adds an actor to the registry
            </summary>
      <typeparam name="T">The type of the actor</typeparam>
      <param name="actor">The actor to add</param>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.Unregister``1(``0)">
      <summary>
            Removes an actor from the registry
            </summary>
      <typeparam name="T">The type of the actor</typeparam>
      <param name="actor">The actor to remove</param>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.Unregister(System.Guid)">
      <summary>
            Removes an actor from the registry
            </summary>
      <param name="id">The id of the actor to remove</param>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.Shutdown">
      <summary>
            Stops all actors and removes them from the registry
            </summary>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.Get(System.Guid)">
      <summary>
            Gets an actor from the registry
            </summary>
      <param name="id">The id of the actor</param>
      <returns>The actor with the specified id</returns>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.GetAll">
      <summary>
            Gets all actors from the registry
            </summary>
      <returns>All actors in the registry</returns>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.GetAll``1">
      <summary>
            Get all actors from the registry that are the specified type
            </summary>
      <typeparam name="T">The type of actor to retrieve</typeparam>
      <returns>A list of actors matching the specified type</returns>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.GetAll(System.Type)">
      <summary>
            Get all actors from the registry that are the specified type
            </summary>
      <param name="actorType">The type of actor to retrieve</param>
      <returns>A list of actors matching the specified type</returns>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.Each(System.Action{Magnum.Actors.Actor})">
      <summary>
            Calls the callback for each actor in the registry
            </summary>
      <param name="callback">A method to call with each actor</param>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.Each``1(System.Action{``0})">
      <summary>
            Calls the callback for each actor in the registry of the specified type
            </summary>
      <typeparam name="T">The type of actor to select</typeparam>
      <param name="callback">The method to call with each actor</param>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.Each(System.Type,System.Action{Magnum.Actors.Actor})">
      <summary>
            Calls the callback for each actor in the registry of the specified type
            </summary>
      <param name="actorType">The type of actor to select</param>
      <param name="callback">The method to call with each actor</param>
    </member>
    <member name="M:Magnum.Actors.ActorRegistry.Subscribe(System.Action{Magnum.Channels.Configuration.ConnectionConfigurator})">
      <summary>
            Allow subscription to events that are produced by the actor registry as actors
            are registered and unregistered.
            </summary>
      <param name="subscriberActions">The subscription actions</param>
      <returns>A channel subscription</returns>
    </member>
    <member name="M:Magnum.Actors.ExtensionsToActorInstance.Exit(Magnum.Actors.ActorInstance)">
      <summary>
            Sends an Exit message to an actor instance
            </summary>
      <param name="instance">The actor instance</param>
    </member>
    <member name="M:Magnum.Actors.ExtensionsToActorInstance.Kill(Magnum.Actors.ActorInstance)">
      <summary>
            Sends a Kill message to an actor instance
            </summary>
      <param name="instance">The actor instance</param>
    </member>
    <member name="M:Magnum.Actors.ExtensionsToInbox.Request``1(Magnum.Channels.UntypedChannel,``0,Magnum.Actors.Inbox)">
      <summary>
            Wraps the message in a request and sends it to the channel
            </summary>
      <typeparam name="TRequest">The type of the request message</typeparam>
      <param name="channel">The channel where the message should be sent</param>
      <param name="request">The request message</param>
      <param name="responseChannel">The channel where responses should be sent</param>
    </member>
    <member name="T:Magnum.Channels.ChannelProvider`1">
      <summary>
            Used by dispatching channels to retrieve the appropriate channel for
            a message.
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="M:Magnum.Channels.ChannelProvider`1.GetChannel(`0)">
      <summary>
            Get a channel for the message
            </summary>
      <param name="message">The message to use to select the channel</param>
      <returns>The channel that should process the message, or null</returns>
    </member>
    <member name="T:Magnum.Actors.Internal.ActorChannelProvider`2">
      <summary>
              Provides a channel from an actor, based on the property information which is used
              to create a dynamic method that returns the actual channel
            </summary>
      <typeparam name="TActor">The actor type</typeparam>
      <typeparam name="TChannel">The channel type</typeparam>
    </member>
    <member name="T:Magnum.Actors.Internal.ThreadStaticActorFactory`1">
      <summary>
              Maintains only one instance of an actor per thread
            </summary>
      <typeparam name="TActor">The actor type</typeparam>
    </member>
    <member name="T:Magnum.Binding.BinderContext">
      <summary>
            Used by the type binders to obtain information
            </summary>
    </member>
    <member name="M:Magnum.Binding.BinderContext.Bind(Magnum.Binding.ObjectPropertyBinder)">
      <summary>
            Binds a property of an object, pushing the property context on the stack
            </summary>
      <param name="property">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Binding.BinderContext.GetChannel``1">
      <summary>
            Returns a channel for the specified message type
            </summary>
      <typeparam name="T">The channel message type</typeparam>
      <returns>A channel </returns>
    </member>
    <member name="P:Magnum.Binding.BinderContext.Property">
      <summary>
            The current property being bound
            </summary>
    </member>
    <member name="P:Magnum.Binding.BinderContext.PropertyValue">
      <summary>
            Resolves the value of the property based on the naming convention.
            This can be an expensive call, so it should only be called once and
            the return value should be cached to avoid performance concerns
            </summary>
    </member>
    <member name="T:Magnum.Binding.ModelBinder">
      <summary>
            A model binder is used to map an unstructured data source to an object
            using a series of conventions and value providers
            </summary>
    </member>
    <member name="M:Magnum.Binding.ModelBinder.Bind(System.Type,Magnum.Binding.ModelBinderContext)">
      <summary>
            Create an object of the requested type, initializing the properties
            of that object to the value retrieved from the context
            </summary>
      <param name="type">The type of object to create</param>
      <param name="context">The context to use while binding the object</param>
      <returns>Returns an instance of the object, or an exception if the binding was unsuccessful</returns>
    </member>
    <member name="M:Magnum.Binding.ModelBinder.Bind``1(Magnum.Binding.ModelBinderContext)">
      <summary>
            Create an object of the requested type, initializing the properties
            of that object to the value retrieved from the context
            </summary>
      <typeparam name="T">The type of object to create</typeparam>
      <param name="context">The context to use while binding the object</param>
      <returns>Returns an instance of the object, or an exception if the binding was unsuccessful</returns>
    </member>
    <member name="T:Magnum.Binding.FastModelBinder">
      <summary>
            A fast model binder for quickly applying values to properties
            </summary>
    </member>
    <member name="T:Magnum.Binding.ModelBinderContext">
      <summary>
            Context for binding to a model
            </summary>
    </member>
    <member name="M:Magnum.Channels.Configuration.Internal.ChannelConfiguratorConnection.AddDisposable(System.IDisposable)">
      <summary>
            Add a disposable item to the connection
            </summary>
      <param name="disposable">
      </param>
    </member>
    <member name="P:Magnum.Channels.Configuration.Internal.ChannelConfiguratorConnection.Channel">
      <summary>
            The channel to which connections are being added
            </summary>
    </member>
    <member name="M:Magnum.Channels.Configuration.Internal.ChannelConfiguratorConnection`1.AddDisposable(System.IDisposable)">
      <summary>
            Add a disposable item to the connection
            </summary>
      <param name="disposable">
      </param>
    </member>
    <member name="T:Magnum.Channels.Configuration.ChannelConnectionConfigurator`1">
      <summary>
            A fluent syntax for configuration the options of a channel subscription
            </summary>
      <typeparam name="TChannel">The channel type</typeparam>
    </member>
    <member name="M:Magnum.Channels.Configuration.Configurator.ValidateConfiguration">
      <summary>
            Validate the configuration, throwing an exception if the configuration settings
            are insufficient or invalid based on the type of configuration being performed.
            </summary>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.ChannelConfigurator">
      <summary>
            Configures a channel on an untyped channel
            </summary>
    </member>
    <member name="T:Magnum.Fibers.Configuration.FiberProviderConfigurator`2">
      <summary>
            Configures the type of fiber to be used for handling messages
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="M:Magnum.Fibers.Configuration.FiberProviderConfigurator`2.HandleOnCallingThread">
      <summary>
            Handles the message on the calling thread (synchronously)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Fibers.Configuration.FiberProviderConfigurator`2.HandleOnSingleFiber">
      <summary>
            Handles messages to all instances using a single shared fiber
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Fibers.Configuration.FiberProviderConfigurator`2.HandleOnInstanceFiber">
      <summary>
            Each instance handles messages on its own fiber
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Fibers.Configuration.FiberProviderConfigurator`2.HandleOnSingleThread">
      <summary>
            Handles messages to all instances using a single shared thread
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Fibers.Configuration.FiberProviderConfigurator`2.HandleOnFiber(Magnum.Fibers.Fiber)">
      <summary>
            Handle all requests on a single fiber, specified
            </summary>
      <param name="fiber">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Fibers.Configuration.FiberProviderConfigurator`2.UseFiberProvider(Magnum.Fibers.FiberProvider{`1})">
      <summary>
            Specifies a specific fiber provider, which provides the fiber for each instance
            </summary>
      <param name="fiberProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.InstanceChannelConfigurator`2">
      <summary>
            A fluent syntax for configuration options of a channel consumer
            </summary>
      <typeparam name="TInstance">The consumer type</typeparam>
      <typeparam name="TChannel">The channel type</typeparam>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.DistributedInstanceChannelConfigurator`3">
      <summary>
            An instance configuration that is distributed by a specified key
            </summary>
      <typeparam name="TInstance">
      </typeparam>
      <typeparam name="TChannel">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.DistributedInstanceChannelConfiguratorImpl`3">
      <summary>
            Implements the factory that creates the instance channel backed by a 
            KeyedChannelProvider, which maintains an instance of the channel for each
            unique key value
            </summary>
      <typeparam name="TChannel">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TInstance">
      </typeparam>
    </member>
    <member name="T:Magnum.Fibers.Configuration.FiberConfigurator`1">
      <summary>
            Configures the type of fiber to be used for handling messages
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Fibers.Configuration.FiberConfigurator`1.HandleOnCallingThread">
      <summary>
            Handle on the calling thread (synchronously)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Fibers.Configuration.FiberConfigurator`1.HandleOnFiber">
      <summary>
            Handle on a dedicated fiber (uses the thread pool, lightweight)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Fibers.Configuration.FiberConfigurator`1.HandleOnFiber(Magnum.Fibers.Fiber)">
      <summary>
            Handle on the specified fiber
            </summary>
      <param name="fiber">The fiber to use</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Fibers.Configuration.FiberConfigurator`1.HandleOnThread">
      <summary>
            Handle on a dedicated thread (operating system thread)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Fibers.Configuration.FiberConfigurator`1.UseFiberFactory(Magnum.Fibers.FiberFactory)">
      <summary>
            Use the specified fiber factory
            </summary>
      <param name="fiberFactory">The fiber factory to use</param>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Actors.Inbox">
      <summary>
              Mailbox is a higher level construct than a channel, providing channel aggregation,
              directed receives, and dispatching to channels within a context, such as an actor
            </summary>
    </member>
    <member name="M:Magnum.Actors.Inbox.Receive``1(Magnum.Channels.SelectiveConsumer{``0})">
      <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
      <typeparam name="T">The requested message type</typeparam>
      <param name="consumer">The consumer</param>
    </member>
    <member name="M:Magnum.Actors.Inbox.Receive``1(Magnum.Channels.SelectiveConsumer{``0},System.TimeSpan,System.Action)">
      <summary>
              Specifies a method to call when a message is recieved. If a message is not received within
              the specified timeout, a timeout callback is called instead and the receiver is removed from 
              the waiting list of receivers.
            </summary>
      <param name="consumer">The consumer to call with the message</param>
      <param name="timeout">The time period to wait for a message</param>
      <param name="timeoutCallback">The method to call if a message is not received within the timeout period</param>
    </member>
    <member name="M:Magnum.Actors.Inbox.Receive``1(Magnum.Channels.SelectiveConsumer{``0},System.Int32,System.Action)">
      <summary>
              Specifies a method to call when a message is recieved. If a message is not received within
              the specified timeout, a timeout callback is called instead and the receiver is removed from 
              the waiting list of receivers.
            </summary>
      <param name="consumer">The consumer to call with the message</param>
      <param name="timeout">The time period to wait for a message</param>
      <param name="timeoutCallback">The method to call if a message is not received within the timeout period</param>
    </member>
    <member name="T:Magnum.Actors.Internal.SentRequestImpl`1">
      <summary>
            A decorator for sent requests that enables method chaining
            </summary>
      <typeparam name="TRequest">
      </typeparam>
    </member>
    <member name="M:Magnum.Channels.ExtensionsForContext.Request``1(Magnum.Channels.UntypedChannel,``0,Magnum.Channels.UntypedChannel)">
      <summary>
            Wraps the message in a request and sends it to the channel
            </summary>
      <typeparam name="TRequest">The type of the request message</typeparam>
      <param name="channel">The channel where the message should be sent</param>
      <param name="request">The request message</param>
      <param name="responseChannel">The channel where responses should be sent</param>
    </member>
    <member name="M:Magnum.Channels.ExtensionsForContext.Respond``2(Magnum.Channels.Request{``0},``1)">
      <summary>
            Wraps a message in a response and sends it to the response channel of the request
            </summary>
      <typeparam name="TRequest">The type of the request message</typeparam>
      <typeparam name="TResponse">The type of the response message</typeparam>
      <param name="request">The request context</param>
      <param name="response">The response message</param>
    </member>
    <member name="T:Magnum.Channels.TypedChannelAdapter`1">
      <summary>
            Converts an untyped channel to a typed channel, passing only messages
            which can be assigned to the channel type and discarding all others
            </summary>
      <typeparam name="TOutput">The output channel type</typeparam>
    </member>
    <member name="T:Magnum.Actors.Internal.ActorInbox`1">
      <summary>
            An inbox for an actor. Channel properties on the actor are automatically bound.
            Messages are automatically delivered to the inbox for each message type unless
            a property channel has the same message type. Calling Receive on the inbox will 
            </summary>
      <typeparam name="TActor">The actor type for this inbox</typeparam>
    </member>
    <member name="M:Magnum.Cryptography.Sha512HMacHashingService.#ctor(System.String)">
      <summary>
      </summary>
      <param name="key">The key to use in the hashing algorhythem. Can be of any length</param>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.ChannelConfigurator`1">
      <summary>
            Configures a channel on a typed channel
            </summary>
      <typeparam name="TChannel">
      </typeparam>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.WcfChannelConnectionConfiguratorImpl">
      <summary>
            Exposes the configuration options for a WcfProxy
            </summary>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.CreateChannelConnection">
      <summary>
            Allows channels and disposable items to be added to the connection
            </summary>
    </member>
    <member name="M:Magnum.Channels.Configuration.Internal.CreateChannelConnection.AddChannel(Magnum.Channels.Channel)">
      <summary>
            Adds a channel to the connection
            </summary>
      <param name="channel">
      </param>
    </member>
    <member name="M:Magnum.Channels.Configuration.Internal.CreateChannelConnection.AddDisposable(System.IDisposable)">
      <summary>
            Adds a disposable reference to the connection
            </summary>
      <param name="disposable">
      </param>
    </member>
    <member name="T:Magnum.Channels.Channel`1">
      <summary>
            A one-way communication containing messages of the specified type
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Channels.Channel`1.Send(`0)">
      <summary>
            Send a message to the channel
            </summary>
      <param name="message">The message to send</param>
    </member>
    <member name="T:Magnum.Channels.DelegateChannel`1">
      <summary>
            A direct delegate invocation on send, no fiber used
            </summary>
      <typeparam name="TChannel">
      </typeparam>
    </member>
    <member name="T:Magnum.Channels.InstanceProvider`2">
      <summary>
            Used to obtain and instance of a class based on the information contained
            in the specified message
            </summary>
      <typeparam name="TInstance">The type of the class</typeparam>
      <typeparam name="TChannel">The type of the message</typeparam>
    </member>
    <member name="T:Magnum.Channels.Internal.AsyncResult">
      <summary>
            A callback-only version of the AsyncResult callback
            </summary>
    </member>
    <member name="T:Magnum.Channels.ChannelConnection">
      <summary>
            Contains the changes made by a connection to a channel so that they can be 
            removed when the connections are no longer required.
            </summary>
    </member>
    <member name="M:Magnum.Channels.ChannelConnection.Disconnect">
      <summary>
            Disconnects any channels and/or consumers that were added by a Connect
            to a channel.
            </summary>
    </member>
    <member name="T:Magnum.Channels.ChannelFactory`1">
      <summary>
            Implemented by classes that can create channels. The factory method is used
            to create channels outside of any message delivery context. If the content
            of the message is important in the creation of the channel, the ChannelProvider is a 
            better choice to use since it passes the message as part of the channel acquisition
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Channels.ChannelFactory`1.GetChannel">
      <summary>
            Returns the channel
            </summary>
      <returns>A channel instance</returns>
    </member>
    <member name="T:Magnum.Channels.ChannelConfigurationException">
      <summary>
            Thrown when an invalid configuration is supplied when configuring a channel
            </summary>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.DistinctChannelConfigurator`2">
      <summary>
            Used to configure the options on a channel that delivers messages at regular
            intervals
            </summary>
      <typeparam name="TChannel">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="M:Magnum.Channels.ExtensionsForConsumerChannel.AddConsumer``1(Magnum.Channels.Configuration.ConnectionConfigurator{``0},Magnum.Channels.Consumer{``0})">
      <summary>
            Add a consumer to the channel using the message type defined for the channel
            </summary>
      <typeparam name="TChannel">The channel type, specifies the type of message sent by the channel</typeparam>
      <param name="connectionConfigurator">The connection configurator</param>
      <param name="consumer">The consumer to add to the channel</param>
      <returns>A consumer configurator to customize the consumer settings</returns>
    </member>
    <member name="M:Magnum.Channels.ExtensionsForConsumerChannel.UsingConsumer``1(Magnum.Channels.Configuration.ChannelConnectionConfigurator{``0},Magnum.Channels.Consumer{``0})">
      <summary>
            Consumes the message on a ConsumerChannel, given the specified delegate
            </summary>
      <param name="configurator">
      </param>
      <param name="consumer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Channels.ExtensionsForIntervalChannels.BufferFor``1(Magnum.Channels.Configuration.ChannelConnectionConfigurator{``0},System.TimeSpan)">
      <summary>
            Specifies an interval at which the consumer should be called with a collection
            of messages received during that period.
            </summary>
      <param name="configurator">
      </param>
      <param name="interval">The time period of each interval</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Channels.ExtensionsForSelectiveConsumerChannel.AddSelectiveConsumer``1(Magnum.Channels.Configuration.ConnectionConfigurator{``0},Magnum.Channels.SelectiveConsumer{``0})">
      <summary>
            Add a consumer to the channel using the message type defined for the channel
            </summary>
      <typeparam name="TChannel">The channel type, specifies the type of message sent by the channel</typeparam>
      <param name="connectionConfigurator">The connection configurator</param>
      <param name="consumer">The consumer to add to the channel</param>
      <returns>A consumer configurator to customize the consumer settings</returns>
    </member>
    <member name="M:Magnum.Channels.ExtensionsForSelectiveConsumerChannel.UsingSelectiveConsumer``1(Magnum.Channels.Configuration.ChannelConnectionConfigurator{``0},Magnum.Channels.SelectiveConsumer{``0})">
      <summary>
            Consumes the message on a SelectiveConsumerChannel given the specified delegate
            </summary>
      <param name="configurator">
      </param>
      <param name="selectiveConsumer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Channels.ExtensionsForAddConsumer.AddConsumerOf``1(Magnum.Channels.Configuration.ConnectionConfigurator)">
      <summary>
            Add a consumer of the specified message type
            </summary>
      <typeparam name="TChannel">The channel type</typeparam>
      <returns>A chainable method to configure additional options</returns>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.FilterChannelConfigurator`1">
      <summary>
            Used to configure the options on a channel that delivers messages at regular
            intervals
            </summary>
      <typeparam name="TChannel">
      </typeparam>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.IntervalChannelConfigurator`1">
      <summary>
            Used to configure the options on a channel that delivers messages at regular
            intervals
            </summary>
      <typeparam name="TChannel">
      </typeparam>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.LastChannelConfigurator`1">
      <summary>
            Used to configure the last channel 
            </summary>
      <typeparam name="TChannel">
      </typeparam>
    </member>
    <member name="T:Magnum.Future`1">
      <summary>
            A future object that supports both callbacks and asynchronous waits once a future value becomes available.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Magnum.Channels.InstanceChannelProvider`2">
      <summary>
            Gets an instance of a class from the InstanceProvider and returns the channel
            from that class
            </summary>
      <typeparam name="TInstance">The instance type</typeparam>
      <typeparam name="TChannel">The channel type</typeparam>
    </member>
    <member name="T:Magnum.Channels.SelectiveConsumerChannel`1">
      <summary>
            A channel that accepts a message and enqueues the consumer method via the
            specified Fiber
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
    </member>
    <member name="M:Magnum.Channels.SelectiveConsumerChannel`1.#ctor(Magnum.Fibers.Fiber,Magnum.Channels.SelectiveConsumer{`0})">
      <summary>
            Constructs a channel
            </summary>
      <param name="fiber">The queue where consumer actions should be enqueued</param>
      <param name="selectiveConsumer">The method to call when a message is sent to the channel</param>
    </member>
    <member name="T:Magnum.Graphing.GraphData">
      <summary>
            A provider of graph data can return vertices and edges
            </summary>
    </member>
    <member name="T:Magnum.Channels.WcfChannelHost">
      <summary>
            Receives messages from a named pipe via WCF and forwards them to the specific channel. Messages
            are first serialized to a wire type that is already WCF compliant, making it unnecessary to decorate
            your message objects with WCF data contract serializer attributes.
            </summary>
    </member>
    <member name="T:Magnum.Channels.WcfChannelHost`1">
      <summary>
            Receives messages from a named pipe via WCF and forwards it to the output
            channel. Message serialization is handled entirely by WCF and therefore
            requires that classes are appropriately decorated.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Magnum.Channels.Configuration.ConnectionConfigurator">
      <summary>
            Used to configure the connections to be added to an UntypedChannel
            </summary>
    </member>
    <member name="M:Magnum.Channels.Configuration.ConnectionConfigurator.AddChannel``1(Magnum.Channels.Channel{``0})">
      <summary>
            Adds a channel directly without any modification
            </summary>
      <typeparam name="TChannel">The channel type</typeparam>
      <param name="channel">The channel instance</param>
    </member>
    <member name="M:Magnum.Channels.Configuration.ConnectionConfigurator.AddUntypedChannel(Magnum.Channels.UntypedChannel)">
      <summary>
            Adds a channel directly without any modification
            </summary>
      <param name="channel">The channel instance</param>
    </member>
    <member name="T:Magnum.Channels.Configuration.ConnectionConfigurator`1">
      <summary>
            Used to configure the connections to be added to a typed Channel
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="T:Magnum.Channels.ChannelAdapter">
      <summary>
            A channel adapter is a mutable segment in a channel network. The output channel can
            be replaced, allowing a new channel network (built via a ChannelVisitor) to be installed
            in response to changes (attachments, detachments, etc.) to the network.
            
            This particular version handles untyped channels
            </summary>
    </member>
    <member name="T:Magnum.Channels.ChannelAdapter`1">
      <summary>
            A channel adapter is a mutable segment in a channel network. The output channel can
            be replaced, allowing a new channel network (built via a ChannelVisitor) to be installed
            in response to changes (attachments, detachments, etc.) to the network.
            
            This particular version handles typed channels
            </summary>
    </member>
    <member name="T:Magnum.Channels.Configuration.Internal.ChannelConnectionImpl">
      <summary>
            The channel connection implementation
            </summary>
    </member>
    <member name="T:Magnum.Channels.DeserializeMessageEnvelopeChannel`1">
      <summary>
            Accepts a MessageEnvelope as input and deserializes the message body on the supplied fiber,
            after which the message object is sent to the untyped output channel.
            </summary>
      <typeparam name="T">The input message type, which must implement MessageEnvelope</typeparam>
    </member>
    <member name="M:Magnum.Channels.DeserializeMessageEnvelopeChannel`1.#ctor(Magnum.Fibers.Fiber,Magnum.Serialization.Serializer,Magnum.Channels.UntypedChannel)">
      <summary>
            Constructs an instance
            </summary>
      <param name="fiber">The fiber used to perform message deserialization</param>
      <param name="serializer">The serializer to use on the message body</param>
      <param name="output">The output channel for the deserialized message</param>
    </member>
    <member name="T:Magnum.Channels.Internal.WcfChannel`1">
      <summary>
              A single generic channel type used for local channels via WCF/named pipes
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Magnum.Channels.Internal.WcfChannelService`1">
      <summary>
              Handles the server end of a WCF channel connection
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="T:Magnum.Channels.SelectiveConsumer`1">
      <summary>
              A conditional consumer is given a message to evaluate, after which it
              can determine if it is interested in the message and return an action
              to process the message or null
            </summary>
      <typeparam name="T">The message type</typeparam>
      <param name="message">The message</param>
      <returns>An action to consume the message, or null</returns>
    </member>
    <member name="T:Magnum.Actors.Inbox`1">
      <summary>
              Mailbox is a higher level construct than a channel, providing channel aggregation,
              directed receives, and dispatching to channels within a context, such as an actor
            </summary>
    </member>
    <member name="M:Magnum.Actors.Inbox`1.Receive(Magnum.Channels.SelectiveConsumer{`0})">
      <summary>
              Calls the specified method when a message of the requested type is received. The
              consumer is asked if the message should be parsed, and returns a non-null action
              if the message should be passed to the consumer. At that point, the message is removed
              from the mailbox and delivered to the consumer
            </summary>
      <typeparam name="T">The requested message type</typeparam>
      <param name="consumer">The consumer</param>
    </member>
    <member name="M:Magnum.Actors.Inbox`1.Receive(Magnum.Channels.SelectiveConsumer{`0},System.TimeSpan,System.Action)">
      <summary>
              Specifies a method to call when a message is recieved. If a message is not received within
              the specified timeout, a timeout callback is called instead and the receiver is removed from 
              the waiting list of receivers.
            </summary>
      <param name="consumer">The consumer to call with the message</param>
      <param name="timeout">The time period to wait for a message</param>
      <param name="timeoutCallback">The method to call if a message is not received within the timeout period</param>
    </member>
    <member name="M:Magnum.Actors.Inbox`1.Receive(Magnum.Channels.SelectiveConsumer{`0},System.Int32,System.Action)">
      <summary>
              Specifies a method to call when a message is recieved. If a message is not received within
              the specified timeout, a timeout callback is called instead and the receiver is removed from 
              the waiting list of receivers.
            </summary>
      <param name="consumer">The consumer to call with the message</param>
      <param name="timeout">The time period to wait for a message</param>
      <param name="timeoutCallback">The method to call if a message is not received within the timeout period</param>
    </member>
    <member name="T:Magnum.Channels.ShuntChannel">
      <summary>
            Implements a channel shunt, discarding any message that is send without action
            </summary>
    </member>
    <member name="T:Magnum.Channels.ShuntChannel`1">
      <summary>
            Implements a channel shunt, discarding any message that is send without action
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Magnum.Concurrency.Atomic">
      <summary>
            The factory to create atomic instances/references
            </summary>
    </member>
    <member name="T:Magnum.Concurrency.Atomic`1">
      <summary>
            An atomic value that can be modified using a mutator function.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Concurrency.Atomic`1.Set(System.Func{`0,`0})">
      <summary>
            Sets the value to the result of the mutator. Each attempt to set the value
            will call the mutator, which could result in multiple calls with different
            values on each call.
            </summary>
      <param name="mutator">A function that takes in the current value and returns the new value</param>
      <returns>The value that was replaced</returns>
    </member>
    <member name="T:Magnum.Concurrency.Internal.AtomicObject">
      <summary>
            Maintains a reference to an immutable object, allowing a mutator function to 
            change the reference pointed to in an atomic fashion
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Concurrency.Internal.AtomicObject.Set(System.Func{System.Object,System.Object})">
      <summary>
            Applies a change method to the value, passing the current value to the mutator
            and attempting to set the value to the returned value. if the value has not been
            changed by another thread, the operation completes, otherwise it is attempted 
            again by calling the mutator function with the new value.
            </summary>
      <param name="mutator">A function that, given the current value, returns the changed value</param>
      <returns>The previous value</returns>
    </member>
    <member name="T:Magnum.Concurrency.Internal.AtomicReference`1">
      <summary>
            Maintains a reference to an immutable object, allowing a mutator function to 
            change the reference pointed to in an atomic fashion
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Concurrency.Internal.AtomicReference`1.Set(System.Func{`0,`0})">
      <summary>
            Applies a change method to the value, passing the current value to the mutator
            and attempting to set the value to the returned value. if the value has not been
            changed by another thread, the operation completes, otherwise it is attempted 
            again by calling the mutator function with the new value.
            </summary>
      <param name="mutator">A function that, given the current value, returns the changed value</param>
      <returns>The previous value</returns>
    </member>
    <member name="T:Magnum.Configuration.ConfigurationBinder">
      <summary>
            Creates configuration/settings objects, applying configuration values
            to the properties as they match the configuration keys in the store
            </summary>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.Bind``1">
      <summary>
            Creates an instance of the specified type and sets the properties
            to the configuration settings that match
            </summary>
      <typeparam name="T">The configuration object type</typeparam>
      <returns>An initialize configuration object</returns>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.Bind(System.Type)">
      <summary>
            Creates an instance of the specified type and sets the properties
            to the configuration settings that match
            </summary>
      <typeparam name="T">The configuration object type</typeparam>
      <returns>An initialize configuration object</returns>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.GetValue(System.String)">
      <summary>
            Returns a single configuration value
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.GetValue``1(System.String)">
      <summary>
            Returns a single configuration value of type T
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.GetValueAsString(System.String)">
      <summary>
            Returns a single configuration as a string
            </summary>
      <param name="key">
      </param>
      <returns>The string representation of the value, or null</returns>
    </member>
    <member name="M:Magnum.Configuration.ConfigurationBinder.GetAll">
      <summary>
            Return a dictionary of all key/value pairs that exist
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToUri.AppendPath(System.Uri,System.String)">
      <summary>
              Appends a path to an existing Uri
            </summary>
      <param name="uri">
      </param>
      <param name="path">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Fibers.Configuration.FiberConfigurationException">
      <summary>
            Thrown when an invalid configuration is supplied when configuring a channel
            </summary>
    </member>
    <member name="T:Magnum.Fibers.DisposeCallback">
      <summary>
            Wraps a callback as an IDisposable to allow it to be called when the object is disposed.
            </summary>
    </member>
    <member name="M:Magnum.Fibers.ExtensionsToFiber.GetShutdownDisposable(Magnum.Fibers.Fiber,System.TimeSpan)">
      <summary>
            Creates a disposable object that calls Shutdown on the fiber when it is
            disposed
            </summary>
      <param name="fiber">The fiber to shutdown</param>
      <param name="timeout">The timeout to wait for the shutdown to complete</param>
      <returns>An IDisposable object</returns>
    </member>
    <member name="M:Magnum.Fibers.ExtensionsToFiber.GetStopDisposable(Magnum.Fibers.Fiber)">
      <summary>
            Creates a disposable object that calls Stop on the fiber when it is
            disposed
            </summary>
      <param name="fiber">The fiber to stop</param>
      <returns>An IDisposable object</returns>
    </member>
    <member name="T:Magnum.Fibers.FiberProvider`1">
      <summary>
            Returns a fiber appropriate for the specified key
            
            Designed for use with cases where there are multiple channels needed
            for a particular object and the fiber needs to be acquired
            </summary>
      <typeparam name="TKey">The key type</typeparam>
    </member>
    <member name="T:Magnum.Fibers.FiberCache`1">
      <summary>
            Keeps track of a keyed fiber collection
            </summary>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="M:Magnum.Fibers.Fiber.Add(System.Action)">
      <summary>
            Enqueue a single action to the queue
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="M:Magnum.Fibers.Fiber.AddMany(System.Action[])">
      <summary>
            Enqueue a series of actions to the queue
            </summary>
      <param name="actions">
      </param>
    </member>
    <member name="M:Magnum.Fibers.Fiber.Shutdown(System.TimeSpan)">
      <summary>
            Runs all remaining actions, waiting until all actions have been executed or until the
            timeout expires. If the timeout expires, an exception is thrown.
            </summary>
      <param name="timeout">The time to wait for all pending actions to be executed before throwing an exception</param>
    </member>
    <member name="M:Magnum.Fibers.Fiber.Stop">
      <summary>
            Stops the fiber, discards any remaining actions, and prevents new actions from being added
            </summary>
    </member>
    <member name="M:Magnum.Fibers.ScheduledAction.Cancel">
      <summary>
            Stops the ScheduledAction from firing again. 
            </summary>
    </member>
    <member name="T:Magnum.Fibers.SynchronousFiber">
      <summary>
            A synchronous fiber will execute an action immediately on the calling thread
            without any protection from an exception
            </summary>
    </member>
    <member name="T:Magnum.Fibers.ThreadPoolFiber">
      <summary>
            An Fiber that uses the .NET ThreadPool and QueueUserWorkItem to execute
            actions.
            </summary>
    </member>
    <member name="T:Magnum.Channels.AsyncResultChannel">
      <summary>
            Wraps a channel in an IAsyncResult compatible wrapper to support asynchronous usage with
            frameworks that support asynchronous callbacks
            </summary>
      <typeparam name="T">The channel type supported</typeparam>
    </member>
    <member name="T:Magnum.Channels.AsyncResultChannel`1">
      <summary>
            Wraps a channel in an IAsyncResult compatible wrapper to support asynchronous usage with
            frameworks that support asynchronous callbacks
            </summary>
      <typeparam name="T">The channel type supported</typeparam>
    </member>
    <member name="T:Magnum.Channels.ChannelAccessor`2">
      <summary>
            Provides a channel from an instance
            </summary>
      <typeparam name="TInstance">The type of instance being accessed</typeparam>
      <typeparam name="T">The type of channel to return</typeparam>
      <param name="instance">The instance to retrieve the channel from</param>
      <returns>The channel of the requested type from the instance</returns>
    </member>
    <member name="T:Magnum.Channels.ConsumerChannel`1">
      <summary>
            A channel that accepts a message and enqueues the consumer method via the
            specified Fiber
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
    </member>
    <member name="M:Magnum.Channels.ConsumerChannel`1.#ctor(Magnum.Fibers.Fiber,Magnum.Channels.Consumer{`0})">
      <summary>
            Constructs a channel
            </summary>
      <param name="fiber">The queue where consumer actions should be enqueued</param>
      <param name="consumer">The method to call when a message is sent to the channel</param>
    </member>
    <member name="T:Magnum.Channels.Consumer`1">
      <summary>
            A consumer delegate, which can be assigned to any method that takes a message as an argument,
            including Actions, void methods, etc.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="message">
      </param>
    </member>
    <member name="T:Magnum.Channels.ChannelProvider">
      <summary>
            Used by an untyped channel dispatcher to get a channel where a message
            can be sent
            </summary>
    </member>
    <member name="T:Magnum.Channels.DelegateChannelProvider`1">
      <summary>
            Wraps an anonymous method in a ChannelProvider
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="M:Magnum.Channels.Interceptor`1.OnSend(`0)">
      <summary>
            Called before a message is delivered to the output channel
            </summary>
      <param name="message">The message being delivered</param>
      <returns>The message passed, a modified message, or null to discard the message</returns>
    </member>
    <member name="M:Magnum.Channels.Interceptor`1.OnException(System.Exception)">
      <summary>
            Called when an exception is returned during delivery to the output channel
            </summary>
      <param name="exception">The exception that occurred</param>
    </member>
    <member name="M:Magnum.Channels.Interceptor`1.OnComplete">
      <summary>
            Called when a message has been successfully delivered to the output channel
            </summary>
    </member>
    <member name="T:Magnum.Channels.InterceptorChannel`1">
      <summary>
            An interceptor channel can be placed in front of any other channel and provides
            the ability to intercept sends to the wrapper channel and modify the message that
            is sent. An additional method is also called once the message has been processed by
            the wrapped channel
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="T:Magnum.Channels.InterceptorFactory`1">
      <summary>
            Provides an instance of an interceptor for an InterceptorChannel to
            handle the interception of messages on channels
            </summary>
      <typeparam name="T">The message type</typeparam>
    </member>
    <member name="M:Magnum.Channels.InterceptorFactory`1.GetInterceptor(`0)">
      <summary>
            Returns an instance of an interceptor
            </summary>
      <param name="message">The message being delivered</param>
      <returns>An interceptor</returns>
    </member>
    <member name="T:Magnum.Channels.DistinctChannel`2">
      <summary>
            A channel that converts a collection of messages into a dictionary of distinct
            messages by the specified key
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
      <typeparam name="TKey">The type of the key for the message</typeparam>
    </member>
    <member name="M:Magnum.Channels.DistinctChannel`2.#ctor(Magnum.Fibers.Fiber,Magnum.Channels.KeyAccessor{`0,`1},Magnum.Channels.Channel{System.Collections.Generic.IDictionary{`1,`0}})">
      <summary>
            Constructs a channel
            </summary>
      <param name="fiber">The queue where consumer actions should be enqueued</param>
      <param name="keyAccessor">Returns the key for the message</param>
      <param name="output">The method to call when a message is sent to the channel</param>
    </member>
    <member name="T:Magnum.Channels.InstanceChannel`1">
      <summary>
            An instance channel requests an instance of a channel which can be created/loaded
            based on the information in the message being sent on the channel
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Magnum.Channels.Internal.MessageList`1">
      <summary>
            Encapsulates a collection of messages
            </summary>
      <typeparam name="T">The message type</typeparam>
    </member>
    <member name="M:Magnum.Channels.Internal.MessageList`1.Add(`0)">
      <summary>
            Adds a message to the list
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="M:Magnum.Channels.Internal.MessageList`1.RemoveAll">
      <summary>
            Removes all messages from the list
            </summary>
      <returns>A list of messages that were removed from the list</returns>
    </member>
    <member name="T:Magnum.Channels.IntervalChannel`1">
      <summary>
            A channel that accepts messages and sends them to the channel at regular intervals
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
    </member>
    <member name="M:Magnum.Channels.IntervalChannel`1.#ctor(Magnum.Fibers.Fiber,Magnum.Fibers.Scheduler,System.TimeSpan,Magnum.Channels.Channel{System.Collections.Generic.ICollection{`0}})">
      <summary>
            Constructs a channel
            </summary>
      <param name="fiber">The queue where consumer actions should be enqueued</param>
      <param name="scheduler">The scheduler to use for scheduling calls to the consumer</param>
      <param name="interval">The interval between calls to the consumer</param>
      <param name="output">The method to call when a message is sent to the channel</param>
    </member>
    <member name="T:Magnum.Channels.KeyAccessor`2">
      <summary>
            Returns the key for the given source
            </summary>
      <typeparam name="T">The type of the source from which the key is to be retrieved</typeparam>
      <typeparam name="TKey">The type of the key to return</typeparam>
      <param name="source">The source from which to retrieve the key</param>
      <returns>The value of the key for the source</returns>
    </member>
    <member name="T:Magnum.Channels.LastChannel`1">
      <summary>
            Forwards the last message in the set of messages to the next channel
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
    </member>
    <member name="T:Magnum.Channels.FilterChannel`1">
      <summary>
              A channel that selectively accepts a message and enqueues the consumer method via the
              specified Fiber.
              Note that the filter function is called as part of the queued action, so threading
              is not an issue.
            </summary>
      <typeparam name="T">The type of message delivered on the channel</typeparam>
    </member>
    <member name="M:Magnum.Channels.FilterChannel`1.#ctor(Magnum.Fibers.Fiber,Magnum.Channels.Channel{`0},Magnum.Channels.Filter{`0})">
      <summary>
              Constructs a channel
            </summary>
      <param name="fiber">The queue where consumer actions should be enqueued</param>
      <param name="output">The method to call when a message is sent to the channel</param>
      <param name="filter">The filter to determine if the message can be consumed</param>
    </member>
    <member name="T:Magnum.Channels.BroadcastChannel">
      <summary>
            A BroadcastChannel sends a message to zero or more listeners
            </summary>
    </member>
    <member name="T:Magnum.Channels.BroadcastChannel`1">
      <summary>
            A BroadcastChannel sends a message to zero or more listeners
            </summary>
      <typeparam name="T">Channel type</typeparam>
    </member>
    <member name="T:Magnum.Channels.SynchronizedChannel">
      <summary>
            Using the specified SynchronizationContext, messages sent through this channel
            will be delivered on the specified user interface thread, to avoid issues when
            writing to the UI
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="T:Magnum.Channels.SynchronizedChannel`1">
      <summary>
            Using the specified SynchronizationContext, messages sent through this channel
            will be delivered on the specified user interface thread, to avoid issues when
            writing to the UI
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="T:Magnum.Channels.ThreadPoolChannel`1">
      <summary>
            Keeps a fixed number of channels available, which presumably are doing some form of synchronous processing
            of messages, to avoid too many consumers running at the same time
            </summary>
      <typeparam name="T">The channel type</typeparam>
    </member>
    <member name="T:Magnum.Channels.ThreadStaticChannelProvider`1">
      <summary>
            Provides an instance of a channel per thread for situations where the
            processing of a channel should be done per-thread to avoid bottlenecks
            
            This should not be used in cases where the channel maintains state
            between calls since threads may change and ordering cannot be guaranteed
            </summary>
      <typeparam name="T">The message type of the channel</typeparam>
    </member>
    <member name="T:Magnum.Channels.ConvertChannel`2">
      <summary>
              Tranforms a message from one type to another
            </summary>
      <typeparam name="TInput">Input message type</typeparam>
      <typeparam name="TOutput">Output message type</typeparam>
    </member>
    <member name="T:Magnum.Collections.BinaryPredicate`1">
      <summary>
            The BinaryPredicate delegate type  encapsulates a method that takes two
            items of the same type, and returns a boolean value representating 
            some relationship between them. For example, checking whether two
            items are equal or equivalent is one kind of binary predicate.
            </summary>
      <param name="item1">The first item.</param>
      <param name="item2">The second item.</param>
      <returns>Whether item1 and item2 satisfy the relationship that the BinaryPredicate defines.</returns>
    </member>
    <member name="T:Magnum.Collections.Algorithms">
      <summary>
            Algorithms contains a number of static methods that implement
            algorithms that work on collections. Most of the methods deal with
            the standard generic collection interfaces such as IEnumerable&lt;T&gt;,
            ICollection&lt;T&gt; and IList&lt;T&gt;.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ListRange`1">
      <summary>
            The class that is used to implement IList&lt;T&gt; to view a sub-range
            of a list. The object stores a wrapped list, and a start/count indicating
            a sub-range of the list. Insertion/deletions through the sub-range view
            cause the count to change also; insertions and deletions directly on
            the wrapped list do not.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ListRange`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
      <summary>
            Create a sub-range view object on the indicate part 
            of the list.
            </summary>
      <param name="wrappedList">List to wrap.</param>
      <param name="start">The start index of the view in the wrapped list.</param>
      <param name="count">The number of items in the view.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ArrayRange`1">
      <summary>
            The class that is used to implement IList&lt;T&gt; to view a sub-range
            of an array. The object stores a wrapped array, and a start/count indicating
            a sub-range of the array. Insertion/deletions through the sub-range view
            cause the count to change up to the size of the underlying array. Elements
            fall off the end of the underlying array.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ArrayRange`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary>
            Create a sub-range view object on the indicate part 
            of the array.
            </summary>
      <param name="wrappedArray">Array to wrap.</param>
      <param name="start">The start index of the view in the wrapped list.</param>
      <param name="count">The number of items in the view.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ReadOnlyCollection`1">
      <summary>
            The read-only ICollection&lt;T&gt; implementation that is used by the ReadOnly method.
            Methods that modify the collection throw a NotSupportedException, methods that don't
            modify are fowarded through to the wrapped collection.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
      <summary>
            Create a ReadOnlyCollection wrapped around the given collection.
            </summary>
      <param name="wrappedCollection">Collection to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyCollection`1.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ReadOnlyList`1">
      <summary>
            The read-only IList&lt;T&gt; implementation that is used by the ReadOnly method.
            Methods that modify the list throw a NotSupportedException, methods that don't
            modify are fowarded through to the wrapped list.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
            Create a ReadOnlyList wrapped around the given list.
            </summary>
      <param name="wrappedList">List to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyList`1.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ReadOnlyDictionary`2">
      <summary>
            The private class that implements a read-only wrapped for 
            IDictionary &lt;TKey,TValue&gt;.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
            Create a read-only dictionary wrapped around the given dictionary.
            </summary>
      <param name="wrappedDictionary">The IDictionary&lt;TKey,TValue&gt; to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnlyDictionary`2.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.TypedEnumerator`1">
      <summary>
             The class that provides a typed IEnumerator&lt;T&gt;
            view onto an untyped IEnumerator interface.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedEnumerator`1.#ctor(System.Collections.IEnumerator)">
      <summary>
            Create a typed IEnumerator&lt;T&gt;
            view onto an untyped IEnumerator interface 
            </summary>
      <param name="wrappedEnumerator">IEnumerator to wrap.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.TypedEnumerable`1">
      <summary>
            The class that provides a typed IEnumerable&lt;T&gt; view
            onto an untyped IEnumerable interface.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedEnumerable`1.#ctor(System.Collections.IEnumerable)">
      <summary>
            Create a typed IEnumerable&lt;T&gt; view
            onto an untyped IEnumerable interface.
            </summary>
      <param name="wrappedEnumerable">IEnumerable interface to wrap.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.TypedCollection`1">
      <summary>
            The class that provides a typed ICollection&lt;T&gt; view
            onto an untyped ICollection interface. The ICollection&lt;T&gt;
            is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedCollection`1.#ctor(System.Collections.ICollection)">
      <summary>
            Create a typed ICollection&lt;T&gt; view
            onto an untyped ICollection interface.
            </summary>
      <param name="wrappedCollection">ICollection interface to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedCollection`1.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.TypedList`1">
      <summary>
            The class used to create a typed IList&lt;T&gt; view onto
            an untype IList interface.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedList`1.#ctor(System.Collections.IList)">
      <summary>
            Create a typed IList&lt;T&gt; view onto
            an untype IList interface.
            </summary>
      <param name="wrappedList">The IList to wrap.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.UntypedCollection`1">
      <summary>
            The class that is used to provide an untyped ICollection
            view onto a typed ICollection&lt;T&gt; interface.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.UntypedCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
      <summary>
            Create an untyped ICollection
            view onto a typed ICollection&lt;T&gt; interface.
            </summary>
      <param name="wrappedCollection">The ICollection&lt;T&gt; to wrap.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.UntypedList`1">
      <summary>
            The class that implements a non-generic IList wrapper
            around a generic IList&lt;T&gt; interface.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.UntypedList`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
            Create a non-generic IList wrapper
            around a generic IList&lt;T&gt; interface.
            </summary>
      <param name="wrappedList">The IList&lt;T&gt; interface to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.UntypedList`1.ConvertToItemType(System.String,System.Object)">
      <summary>
            Convert the given parameter to T. Throw an ArgumentException
            if it isn't.
            </summary>
      <param name="name">parameter name</param>
      <param name="value">parameter value</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ArrayWrapper`1">
      <summary>
            The class that is used to implement IList&lt;T&gt; to view an array
            in a read-write way. Insertions cause the last item in the array
            to fall off, deletions replace the last item with the default value.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ArrayWrapper`1.#ctor(`0[])">
      <summary>
            Create a list wrapper object on an array.
            </summary>
      <param name="wrappedArray">Array to wrap.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.LexicographicalComparerClass`1">
      <summary>
            A private class used by the LexicographicalComparer method to compare sequences
            (IEnumerable) of T by there Lexicographical ordering.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LexicographicalComparerClass`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new instance that comparer sequences of T by their lexicographical
            ordered.
            </summary>
      <param name="itemComparer">The IComparer used to compare individual items of type T.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.ReverseComparerClass`1">
      <summary>
            An IComparer instance that can be used to reverse the sense of 
            a wrapped IComparer instance.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReverseComparerClass`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
      </summary>
      <param name="comparer">The comparer to reverse.</param>
    </member>
    <member name="T:Magnum.Collections.Algorithms.IdentityComparer`1">
      <summary>
            A class, implementing IEqualityComparer&lt;T&gt;, that compares objects
            for object identity only. Only Equals and GetHashCode can be used;
            this implementation is not appropriate for ordering.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.CollectionEqualityComparer`1">
      <summary>
            A private class used to implement GetCollectionEqualityComparer(). This
            class implements IEqualityComparer&lt;IEnumerable&lt;T&gt;gt; to compare
            two enumerables for equality, where order is significant.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Algorithms.SetEqualityComparer`1">
      <summary>
            A private class used to implement GetSetEqualityComparer(). This
            class implements IEqualityComparer&lt;IEnumerable&lt;T&gt;gt; to compare
            two enumerables for equality, where order is not significant.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Range``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of a list. Items from <paramref name="list" /> are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to <paramref name="list" />
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
      <remarks>This method can be used to apply an algorithm to a portion of a list. For example:
            <code>Algorithms.ReverseInPlace(Algorithms.Range(list, 3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
      <typeparam name="T">The type of the items in the list.</typeparam>
      <param name="list">The list to view.</param>
      <param name="start">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-list. </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> + <paramref name="count" /> is greater than the
            size of <paramref name="list" />.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Range``1(``0[],System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of an array. Items from <paramref name="array" /> are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to <paramref name="array" />
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view. After an insertion, the last item in <paramref name="array" /> "falls off the end". After a deletion, the
            last item in array becomes the default value (0 or null).
            </summary>
      <remarks>This method can be used to apply an algorithm to a portion of a array. For example:
            <code>Algorithms.ReverseInPlace(Algorithms.Range(array, 3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
      <param name="array">The array to view.</param>
      <param name="start">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-array. </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> + <paramref name="count" /> is greater than the
            size of <paramref name="array" />.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnly``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Returns a read-only view onto a collection. The returned ICollection&lt;T&gt; interface
            only allows operations that do not change the collection: GetEnumerator, Contains, CopyTo,
            Count. The ReadOnly property returns false, indicating that the collection is read-only. All other
            methods on the interface throw a NotSupportedException.
            </summary>
      <remarks>The data in the underlying collection is not copied. If the underlying
            collection is changed, then the read-only view also changes accordingly.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to wrap.</param>
      <returns>A read-only view onto <paramref name="collection" />. If <paramref name="collection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnly``1(System.Collections.Generic.IList{``0})">
      <summary>
            Returns a read-only view onto a list. The returned IList&lt;T&gt; interface
            only allows operations that do not change the list: GetEnumerator, Contains, CopyTo,
            Count, IndexOf, and the get accessor of the indexer. 
            The IsReadOnly property returns true, indicating that the list is read-only. All other
            methods on the interface throw a NotSupportedException.
            </summary>
      <remarks>The data in the underlying list is not copied. If the underlying
            list is changed, then the read-only view also changes accordingly.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to wrap.</param>
      <returns>A read-only view onto <paramref name="list" />. Returns null if <paramref name="list" /> is null. 
            If <paramref name="list" /> is already read-only, returns <paramref name="list" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadOnly``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            Returns a read-only view onto a dictionary. The returned IDictionary&lt;TKey,TValue&gt; interface
            only allows operations that do not change the dictionary. 
            The IsReadOnly property returns true, indicating that the dictionary is read-only. All other
            methods on the interface throw a NotSupportedException.
            </summary>
      <remarks>The data in the underlying dictionary is not copied. If the underlying
            dictionary is changed, then the read-only view also changes accordingly.</remarks>
      <param name="dictionary">The dictionary to wrap.</param>
      <returns>A read-only view onto <paramref name="dictionary" />. Returns null if <paramref name="dictionary" /> is null. 
            If <paramref name="dictionary" /> is already read-only, returns <paramref name="dictionary" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedAs``1(System.Collections.IEnumerable)">
      <summary>
            Given a non-generic IEnumerable interface, wrap a generic IEnumerable&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic collection, but can be used in places that require a generic interface.
            The underlying non-generic collection must contain only items that
            are of type <typeparamref name="T" /> or a type derived from it. This method is useful
            when interfacing older, non-generic collections to newer code that uses generic interfaces.
            </summary>
      <remarks>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedCollection" /> to IEnumerable&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the wrapper collection.</typeparam>
      <param name="untypedCollection">An untyped collection. This collection should only contain
            items of type <typeparamref name="T" /> or a type derived from it. </param>
      <returns>A generic IEnumerable&lt;T&gt; wrapper around <paramref name="untypedCollection" />. 
            If <paramref name="untypedCollection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedAs``1(System.Collections.ICollection)">
      <summary>
            Given a non-generic ICollection interface, wrap a generic ICollection&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic collection, but can be used in places that require a generic interface.
            The underlying non-generic collection must contain only items that
            are of type <typeparamref name="T" /> or a type derived from it. This method is useful
            when interfacing older, non-generic collections to newer code that uses generic interfaces.
            </summary>
      <remarks>
        <para>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedCollection" /> to ICollection&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</para>
        <para>Unlike the generic interface, the non-generic ICollection interfaces does
            not contain methods for adding or removing items from the collection. For this reason,
            the returned ICollection&lt;T&gt; will be read-only.</para>
      </remarks>
      <typeparam name="T">The item type of the wrapper collection.</typeparam>
      <param name="untypedCollection">An untyped collection. This collection should only contain
            items of type <typeparamref name="T" /> or a type derived from it. </param>
      <returns>A generic ICollection&lt;T&gt; wrapper around <paramref name="untypedCollection" />.
            If <paramref name="untypedCollection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TypedAs``1(System.Collections.IList)">
      <summary>
            Given a non-generic IList interface, wrap a generic IList&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic list, but can be used in places that require a generic interface.
            The underlying non-generic list must contain only items that
            are of type <typeparamref name="T" /> or a type derived from it. This method is useful
            when interfacing older, non-generic lists to newer code that uses generic interfaces.
            </summary>
      <remarks>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedList" /> to IList&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the wrapper list.</typeparam>
      <param name="untypedList">An untyped list. This list should only contain
            items of type <typeparamref name="T" /> or a type derived from it. </param>
      <returns>A generic IList&lt;T&gt; wrapper around <paramref name="untypedList" />.
            If <paramref name="untypedList" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Untyped``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Given a generic ICollection&lt;T&gt; interface, wrap a non-generic (untyped)
            ICollection interface around it. The non-generic interface will contain the same objects as the 
            underlying generic collection, but can be used in places that require a non-generic interface.
            This method is useful when interfacing generic interfaces with older code that uses non-generic interfaces.
            </summary>
      <remarks>Many generic collections already implement the non-generic interfaces directly. This
            method will first attempt to simply cast <paramref name="typedCollection" /> to ICollection. If that
            succeeds, it is returned; if it fails, then a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the underlying collection.</typeparam>
      <param name="typedCollection">A typed collection to wrap.</param>
      <returns>A non-generic ICollection wrapper around <paramref name="typedCollection" />.
            If <paramref name="typedCollection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Untyped``1(System.Collections.Generic.IList{``0})">
      <summary>
            Given a generic IList&lt;T&gt; interface, wrap a non-generic (untyped)
            IList interface around it. The non-generic interface will contain the same objects as the 
            underlying generic list, but can be used in places that require a non-generic interface.
            This method is useful when interfacing generic interfaces with older code that uses non-generic interfaces.
            </summary>
      <remarks>Many generic collections already implement the non-generic interfaces directly. This
            method will first attempt to simply cast <paramref name="typedList" /> to IList. If that
            succeeds, it is returned; if it fails, then a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the underlying list.</typeparam>
      <param name="typedList">A typed list to wrap.</param>
      <returns>A non-generic IList wrapper around <paramref name="typedList" />.
            If <paramref name="typedList" /> is null, then null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReadWriteList``1(``0[])">
      <summary>
        <para>Creates a read-write IList&lt;T&gt; wrapper around an array. When an array is
            implicitely converted to an IList&lt;T&gt;, changes to the items in the array cannot
            be made through the interface. This method creates a read-write IList&lt;T&gt; wrapper
            on an array that can be used to make changes to the array. </para>
        <para>Use this method when you need to pass an array to an algorithms that takes an 
            IList&lt;T&gt; and that tries to modify items in the list. Algorithms in this class generally do not
            need this method, since they have been design to operate on arrays even when they
            are passed as an IList&lt;T&gt;.</para>
      </summary>
      <remarks>Since arrays cannot be resized, inserting an item causes the last item in the array to be automatically
            removed. Removing an item causes the last item in the array to be replaced with a default value (0 or null). Clearing
            the list causes all the items to be replaced with a default value.</remarks>
      <param name="array">The array to wrap.</param>
      <returns>An IList&lt;T&gt; wrapper onto <paramref name="array" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},``0,``0)">
      <summary>
            Replace all items in a collection equal to a particular value with another values, yielding another collection.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="collection">The collection to process.</param>
      <param name="itemFind">The value to find and replace within <paramref name="collection" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with the appropriate replacements made.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Replace all items in a collection equal to a particular value with another values, yielding another collection. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="itemFind">The value to find and replace within <paramref name="collection" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with the appropriate replacements made.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0)">
      <summary>
            Replace all items in a collection that a predicate evalues at true with a value, yielding another collection. .
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="predicate">The predicate used to evaluate items with the collection. If the predicate returns true for a particular
            item, the item is replaces with <paramref name="replaceWith" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with the appropriate replacements made.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},``0,``0)">
      <summary>
            Replace all items in a list or array equal to a particular value with another value. The replacement is done in-place, changing
            the list.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to process.</param>
      <param name="itemFind">The value to find and replace within <paramtype name="T" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Replace all items in a list or array equal to a particular value with another values.
            The replacement is done in-place, changing
            the list. A passed IEqualityComparer is used to determine equality.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to process.</param>
      <param name="itemFind">The value to find and replace within <paramtype name="T" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},System.Predicate{``0},``0)">
      <summary>
            Replace all items in a list or array that a predicate evaluates at true with a value. The replacement is done in-place, changing
            the list.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to process.</param>
      <param name="predicate">The predicate used to evaluate items with the collection. If the predicate returns true for a particular
            item, the item is replaces with <paramref name="replaceWith" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Remove consecutive equal items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. 
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="collection">The collection to process.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with consecutive duplicates removed.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Remove consecutive equal items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with consecutive duplicates removed.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="equalityComparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Remove consecutive "equal" items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. </remarks>
      <param name="collection">The collection to process.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". An item <c>current</c> is removed if <c>predicate(first, current)==true</c>, where
            <c>first</c> is the first item in the group of "duplicate" items.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with consecutive "duplicates" removed.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Remove consecutive equal items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed. The removal is done in-place, changing
            the list. 
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to process.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Remove subsequent consecutive equal items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed.
            The replacement is done in-place, changing
            the list. A passed IEqualityComparer is used to determine equality.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to process.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Remove consecutive "equal" items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed. The replacement is done in-place, changing
            the list. The passed BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>
        <para>Since an arbitrary BinaryPredicate is passed to this function, what is being tested for need not be true equality. </para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to process.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive equal items in the
            list.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
      <returns>The index of the first item in the first run of <paramref name="count" /> consecutive equal items, or -1 if no such run exists..</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive equal items in the
            list. A passed IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The index of the first item in the first run of <paramref name="count" /> consecutive equal items, or -1 if no such run exists.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32,Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive "equal" items in the
            list. The passed BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested for need not be true equality. </remarks>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The index of the first item in the first run of <paramref name="count" /> consecutive equal items, or -1 if no such run exists.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstConsecutiveWhere``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0})">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive items in the
            list for which a given predicate returns true.
            </summary>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive items to look for. The count must be at least 1.</param>
      <param name="predicate">The predicate used to test each item.</param>
      <returns>The index of the first item in the first run of <paramref name="count" /> items where <paramref name="predicate" />
            returns true for all items in the run, or -1 if no such run exists.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Finds the first item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>If the default value for T could be present in the collection, and 
            would be matched by the predicate, then this method is inappropriate, because
            you cannot disguish whether the default value for T was actually present in the collection,
            or no items matched the predicate. In this case, use TryFindFirstWhere.</remarks>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The first item in the collection that matches the condition, or the default value for T (0 or null) if no
            item that matches the condition is found.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.TryFindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.TryFindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)">
      <summary>
            Finds the first item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="foundItem">Outputs the first item in the collection that matches the condition, if the method returns true.</param>
      <returns>True if an item satisfying the condition was found. False if no such item exists in the collection.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.FindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Finds the last item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>
        <para>If the collection implements IList&lt;T&gt;, then the list is scanned in reverse until a 
            matching item is found. Otherwise, the entire collection is iterated in the forward direction.</para>
        <para>If the default value for T could be present in the collection, and 
            would be matched by the predicate, then this method is inappropriate, because
            you cannot disguish whether the default value for T was actually present in the collection,
            or no items matched the predicate. In this case, use TryFindFirstWhere.</para>
      </remarks>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The last item in the collection that matches the condition, or the default value for T (0 or null) if no
            item that matches the condition is found.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.TryFindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.TryFindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)">
      <summary>
            Finds the last item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>If the collection implements IList&lt;T&gt;, then the list is scanned in reverse until a 
            matching item is found. Otherwise, the entire collection is iterated in the forward direction.</remarks>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="foundItem">Outputs the last item in the collection that matches the condition, if the method returns true.</param>
      <returns>True if an item satisfying the condition was found. False if no such item exists in the collection.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.FindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Enumerates all the items in <paramref name="collection" /> that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindFirstIndexWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
      <summary>
            Finds the index of the first item in a list that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="list">The list to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the first item satisfying the condition. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindLastIndexWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
      <summary>
            Finds the index of the last item in a list that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="list">The list to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the last item satisfying the condition. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FindIndicesWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
      <summary>
            Enumerates the indices of all the items in <paramref name="list" /> that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="list">The list to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items that satisfy the condition.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstIndexOf``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Finds the index of the first item in a list equal to a given item.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <returns>The index of the first item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstIndexOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the first item in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The index of the first item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LastIndexOf``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Finds the index of the last item in a list equal to a given item.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <returns>The index of the last item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LastIndexOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the last item in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The index of the last item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndicesOf``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Enumerates the indices of all the items in a list equal to a given item.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to <paramref name="item" />. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndicesOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Enumerates the indices of all the items in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to <paramref name="item" />. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the index of the first item in a list equal to one of several given items.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <returns>The index of the first item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the first item in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode methods will be called.</param>
      <returns>The index of the first item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Finds the index of the first item in a list "equal" to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            first item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor" /></remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The index of the first item "equal" to any of the items in the collection <paramref name="itemsToLookFor" />, using 
            <paramtype name="BinaryPredicate{T}" /> as the test for equality. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the index of the last item in a list equal to one of several given items.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <returns>The index of the last item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the last item in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality.</param>
      <returns>The index of the last item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Finds the index of the last item in a list "equal" to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            last item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor" /></remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The index of the last item "equal" to any of the items in the collection <paramref name="itemsToLookFor" />, using 
            <paramtype name="BinaryPredicate" /> as the test for equality. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. 
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">A collection of items to search for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to
            any of the items in the collection <paramref name="itemsToLookFor" />. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">A collection of items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. </param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to
            any of the items in the collection <paramref name="itemsToLookFor" />. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            last item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor" /></remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">A collection of items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items "equal" to any of the items 
            in the collection <paramref name="itemsToLookFor" />, using 
            <paramtest name="BinaryPredicate" /> as the test for equality. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list" /> matches pattern at index i if list[i] is equal to the first item
            in <paramref name="pattern" />, list[i+1] is equal to the second item in <paramref name="pattern" />,
            and so forth for all the items in <paramref name="pattern" />.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="pattern">The sequence of items to search for.</param>
      <returns>The first index with <paramref name="list" /> that matches the items in <paramref name="pattern" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list" /> matches pattern at index i if list[i] is "equal" to the first item
            in <paramref name="pattern" />, list[i+1] is "equal" to the second item in <paramref name="pattern" />,
            and so forth for all the items in <paramref name="pattern" />. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested
            for in the pattern need not be equality. </remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="pattern">The sequence of items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The first index with <paramref name="list" /> that matches the items in <paramref name="pattern" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list" /> matches pattern at index i if list[i] is equal to the first item
            in <paramref name="pattern" />, list[i+1] is equal to the second item in <paramref name="pattern" />,
            and so forth for all the items in <paramref name="pattern" />. The passed 
            instance of IEqualityComparer&lt;T&gt; is used for determining if two items are equal.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="pattern">The sequence of items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The first index with <paramref name="list" /> that matches the items in <paramref name="pattern" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if one collection is a subset of another, considered as sets. The first set is a subset
            of the second set if every item in the first set also occurs in the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> is a subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if one collection is a subset of another, considered as sets. The first set is a subset
            of the second set if every item in the first set also occurs in the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality.</param>
      <returns>True if <paramref name="collection1" /> is a subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IsProperSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if one collection is a proper subset of another, considered as sets. The first set is a proper subset
            of the second set if every item in the first set also occurs in the second set, and the first set is strictly smaller than
            the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> is a subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IsProperSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if one collection is a proper subset of another, considered as sets. The first set is a proper subset
            of the second set if every item in the first set also occurs in the second set, and the first set is strictly smaller than
            the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>True if <paramref name="collection1" /> is a proper subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.DisjointSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if two collections are disjoint, considered as sets. Two sets are disjoint if they
            have no common items.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsDisjoint method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are disjoint, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.DisjointSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if two collections are disjoint, considered as sets. Two sets are disjoint if they
            have no common items.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsDisjoint method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparerComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are disjoint, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if two collections are equal, considered as sets. Two sets are equal if they
            have have the same items, with order not being significant.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the EqualTo method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are equal, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if two collections are equal, considered as sets. Two sets are equal if they
            have have the same items, with order not being significant.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the EqualTo method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are equal, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetIntersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic intersection of two collections. The intersection of two sets
            is all items that appear in both of the sets. If an item appears X times in one set,
            and Y times in the other set, the intersection contains the item Minimum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the intersection of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Intersection or IntersectionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to intersect.</param>
      <param name="collection2">The second collection to intersect.</param>
      <returns>The intersection of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetIntersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic intersection of two collections. The intersection of two sets
            is all items that appear in both of the sets. If an item appears X times in one set,
            and Y times in the other set, the intersection contains the item Minimum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the intersection of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Intersection or IntersectionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to intersect.</param>
      <param name="collection2">The second collection to intersect.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The intersection of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetUnion``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic union of two collections. The union of two sets
            is all items that appear in either of the sets. If an item appears X times in one set,
            and Y times in the other set, the union contains the item Maximum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the union of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Union or UnionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to union.</param>
      <param name="collection2">The second collection to union.</param>
      <returns>The union of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetUnion``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic union of two collections. The union of two sets
            is all items that appear in either of the sets. If an item appears X times in one set,
            and Y times in the other set, the union contains the item Maximum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the union of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the union or unionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to union.</param>
      <param name="collection2">The second collection to union.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The union of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic difference of two collections. The difference of two sets
            is all items that appear in the first set, but not in the second. If an item appears X times in the first set,
            and Y times in the second set, the difference contains the item X - Y times (0 times if X &lt; Y). 
            The source collections are not changed.
            A new collection is created with the difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Difference or DifferenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to difference.</param>
      <param name="collection2">The second collection to difference.</param>
      <returns>The difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic difference of two collections. The difference of two sets
            is all items that appear in the first set, but not in the second. If an item appears X times in the first set,
            and Y times in the second set, the difference contains the item X - Y times (0 times if X &lt; Y). 
            The source collections are not changed.
            A new collection is created with the difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the difference or differenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to difference.</param>
      <param name="collection2">The second collection to difference.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetSymmetricDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic symmetric difference of two collections. The symmetric difference of two sets
            is all items that appear in the one of the sets, but not in the other. If an item appears X times in the one set,
            and Y times in the other set, the symmetric difference contains the item AbsoluteValue(X - Y) times. 
            The source collections are not changed.
            A new collection is created with the symmetric difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the SymmetricDifference or SymmetricDifferenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to symmetric difference.</param>
      <param name="collection2">The second collection to symmetric difference.</param>
      <returns>The symmetric difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SetSymmetricDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic symmetric difference of two collections. The symmetric difference of two sets
            is all items that appear in the one of the sets, but not in the other. If an item appears X times in the one set,
            and Y times in the other set, the symmetric difference contains the item AbsoluteValue(X - Y) times. 
            The source collections are not changed.
            A new collection is created with the symmetric difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the symmetric difference or symmetric differenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to symmetric difference.</param>
      <param name="collection2">The second collection to symmetric difference.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The symmetric difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.CartesianProduct``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Computes the cartestian product of two collections: all possible pairs of items, with the first item taken from the first collection and 
            the second item taken from the second collection. If the first collection has N items, and the second collection has M items, the cartesian
            product will have N * M pairs.
            </summary>
      <typeparam name="TFirst">The type of items in the first collection.</typeparam>
      <typeparam name="TSecond">The type of items in the second collection.</typeparam>
      <param name="first">The first collection.</param>
      <param name="second">The second collection.</param>
      <returns>An IEnumerable&lt;Pair&lt;TFirst, TSecond&gt;&gt; that enumerates the cartesian product of the two collections.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ToString``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Gets a string representation of the elements in the collection.
            The string representation starts with "{", has a list of items separated
            by commas (","), and ends with "}". Each item in the collection is 
            converted to a string by calling its ToString method (null is represented by "null").
            Contained collections (except strings) are recursively converted to strings by this method.
            </summary>
      <param name="collection">A collection to get the string representation of.</param>
      <returns>The string representation of the collection. If <paramref name="collection" /> is null, then the string "null" is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ToString``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.String,System.String,System.String)">
      <summary>
            Gets a string representation of the elements in the collection.
            The string to used at the beginning and end, and to separate items,
            and supplied by parameters. Each item in the collection is 
            converted to a string by calling its ToString method (null is represented by "null").
            </summary>
      <param name="collection">A collection to get the string representation of.</param>
      <param name="recursive">If true, contained collections (except strings) are converted to strings by a recursive call to this method, instead
            of by calling ToString.</param>
      <param name="start">The string to appear at the beginning of the output string.</param>
      <param name="separator">The string to appear between each item in the string.</param>
      <param name="end">The string to appear at the end of the output string.</param>
      <returns>The string representation of the collection. If <paramref name="collection" /> is null, then the string "null" is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" />, <paramref name="separator" />, or <paramref name="end" />
             is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ToString``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            Gets a string representation of the mappings in a dictionary.
            The string representation starts with "{", has a list of mappings separated
            by commas (", "), and ends with "}". Each mapping is represented
            by "key-&gt;value". Each key and value in the dictionary is 
            converted to a string by calling its ToString method (null is represented by "null").
            Contained collections (except strings) are recursively converted to strings by this method.
            </summary>
      <param name="dictionary">A dictionary to get the string representation of.</param>
      <returns>The string representation of the collection, or "null" 
            if <paramref name="dictionary" /> is null.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomShuffle``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Randomly shuffles the items in a collection, yielding a new collection.
            </summary>
      <typeparam name="T">The type of the items in the collection.</typeparam>
      <param name="collection">The collection to shuffle.</param>
      <returns>An array with the same size and items as <paramref name="collection" />, but the items in a randomly chosen order.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomShuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
      <summary>
            Randomly shuffles the items in a collection, yielding a new collection.
            </summary>
      <typeparam name="T">The type of the items in the collection.</typeparam>
      <param name="collection">The collection to shuffle.</param>
      <param name="randomGenerator">The random number generator to use to select the random order.</param>
      <returns>An array with the same size and items as <paramref name="collection" />, but the items in a randomly chosen order.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomShuffleInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Randomly shuffles the items in a list or array, in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to shuffle.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomShuffleInPlace``1(System.Collections.Generic.IList{``0},System.Random)">
      <summary>
            Randomly shuffles the items in a list or array, in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to shuffle.</param>
      <param name="randomGenerator">The random number generator to use to select the random order.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomSubset``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
            Picks a random subset of <paramref name="count" /> items from <paramref name="collection" />, and places
            those items into a random order. No item is selected more than once.
            </summary>
      <remarks>If the collection implements IList&lt;T&gt;, then this method takes time O(<paramref name="count" />).
            Otherwise, this method takes time O(N), where N is the number of items in the collection.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection of items to select from. This collection is not changed.</param>
      <param name="count">The number of items in the subset to choose.</param>
      <returns>An array of <paramref name="count" /> items, selected at random from <paramref name="collection" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or greater than <paramref name="collection" />.Count.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RandomSubset``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Random)">
      <summary>
            Picks a random subset of <paramref name="count" /> items from <paramref name="collection" />, and places
            those items into a random order. No item is selected more than once.
            </summary>
      <remarks>If the collection implements IList&lt;T&gt;, then this method takes time O(<paramref name="count" />).
            Otherwise, this method takes time O(N), where N is the number of items in the collection.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection of items to select from. This collection is not changed.</param>
      <param name="count">The number of items in the subset to choose.</param>
      <param name="randomGenerator">The random number generates used to make the selection.</param>
      <returns>An array of <paramref name="count" /> items, selected at random from <paramref name="collection" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or greater than <paramref name="collection" />.Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="randomGenerator" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GeneratePermutations``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />. If <paramref name="collection" />
            has N items, then N factorial permutations will be generated. This method does not compare the items to determine if
            any of them are equal. If some items are equal, the same permutation may be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate the six permutations, AAB, AAB,
            ABA, ABA, BAA, BAA (not necessarily in that order). To take equal items into account, use the GenerateSortedPermutations
            method.
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />, in lexicographical order. 
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />, in lexicographical order. A
            supplied IComparer&lt;T&gt; instance is used to compare the items.
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <param name="comparer">The IComparer&lt;T&gt; used to compare the items.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />, in lexicographical order. A
            supplied Comparison&lt;T&gt; delegate is used to compare the items.
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <param name="comparison">The Comparison&lt;T&gt; delegate used to compare the items.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetRandomGenerator">
      <summary>
            Return a private random number generator to use if the user
            doesn't supply one.
            </summary>
      <returns>The private random number generator. Only one is ever created
            and is always returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the maximum value in a collection.
            </summary>
      <remarks>Values in the collection are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <returns>The largest item in the collection. </returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the maximum value in a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The largest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Finds the maximum value in a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparison">The comparison used to compare items in the collection.</param>
      <returns>The largest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the minimum value in a collection.
            </summary>
      <remarks>Values in the collection are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <returns>The smallest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the minimum value in a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The smallest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Finds the minimum value in a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparison">The comparison used to compare items in the collection.</param>
      <returns>The smallest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0})">
      <summary>
            Finds the index of the maximum value in a list.
            </summary>
      <remarks>Values in the list are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the index of the maximum value in a list. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Finds the index of the maximum value in a list. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparison">The comparison used to compare items in the collection.</param>
      <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0})">
      <summary>
            Finds the index of the minimum value in a list.
            </summary>
      <remarks>Values in the list are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the index of the minimum value in a list. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Finds the index of the minimum value in a list. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
      <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates a sorted version of a collection.
            </summary>
      <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <param name="collection">The collection to sort.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates a sorted version of a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <param name="collection">The collection to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Creates a sorted version of a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <param name="collection">The collection to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Sorts a list or array in place.
            </summary>
      <remarks>
        <para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Sorts a list or array in place. A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
      <remarks>
        <para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Sorts a list or array in place. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
      <remarks>
        <para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection.
            </summary>
      <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <param name="collection">The collection to sort.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <param name="collection">The collection to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <param name="collection">The collection to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            </summary>
      <remarks>
        <para>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Int32@)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the natural ordering of the type (it's implementation of IComparable&lt;T&gt;).
            </summary>
      <param name="list">The sorted list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item" /> was not present in the list, then this
            returns the index at which <paramref name="item" /> could be inserted to maintain the sorted
            order of the list.</param>
      <returns>The number of items equal to <paramref name="item" /> that appear in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0},System.Int32@)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering in the passed instance of IComparer&lt;T&gt;.
            </summary>
      <param name="list">The sorted list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="comparer">The comparer instance used to sort the list. Only
            the Compare method is used.</param>
      <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item" /> was not present in the list, then this
            returns the index at which <paramref name="item" /> could be inserted to maintain the sorted
            order of the list.</param>
      <returns>
            The number of items equal to <paramref name="item" /> that appear in the list.
            </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Comparison{``0},System.Int32@)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering in the passed Comparison&lt;T&gt; delegate.
            </summary>
      <param name="list">The sorted list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="comparison">The comparison delegate used to sort the list.</param>
      <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item" /> was not present in the list, then this
            returns the index at which <paramref name="item" /> could be inserted to maintain the sorted
            order of the list.</param>
      <returns>The number of items equal to <paramref name="item" /> that appear in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.MergeSorted``1(System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Merge several sorted collections into a single sorted collection. Each input collection must be sorted
            by the natural ordering of the type (it's implementation of IComparable&lt;T&gt;). The merging
            is stable; equal items maintain their ordering, and equal items in different collections are placed
            in the order of the collections.
            </summary>
      <param name="collections">The set of collections to merge. In many languages, this parameter
            can be specified as several individual parameters.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates all the items in all the collections
            in sorted order. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.MergeSorted``1(System.Collections.Generic.IComparer{``0},System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Merge several sorted collections into a single sorted collection. Each input collection must be sorted
            by the ordering in the passed instance of IComparer&lt;T&gt;. The merging
            is stable; equal items maintain their ordering, and equal items in different collections are placed
            in the order of the collections.
            </summary>
      <param name="collections">The set of collections to merge. In many languages, this parameter
            can be specified as several individual parameters.</param>
      <param name="comparer">The comparer instance used to sort the list. Only
            the Compare method is used.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates all the items in all the collections
            in sorted order. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.MergeSorted``1(System.Comparison{``0},System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Merge several sorted collections into a single sorted collection. Each input collection must be sorted
            by the ordering in the passed Comparison&lt;T&gt; delegate. The merging
            is stable; equal items maintain their ordering, and equal items in different collections are placed
            in the order of the collections.
            </summary>
      <param name="collections">The set of collections to merge. In many languages, this parameter
            can be specified as several individual parameters.</param>
      <param name="comparison">The comparison delegate used to sort the collections.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates all the items in all the collections
            in sorted order. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Performs a lexicographical comparison of two sequences of values. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
      <remarks>T must implement either IComparable&lt;T&gt; and this implementation is used
            to compare the items. </remarks>
      <typeparam name="T">Types of items to compare. This type must implement IComparable&lt;T&gt; to allow 
            items to be compared.</typeparam>
      <param name="sequence1">The first sequence to compare.</param>
      <param name="sequence2">The second sequence to compare.</param>
      <returns>Less than zero if <paramref name="sequence1" /> is lexicographically less than <paramref name="sequence2" />.
            Greater than zero if <paramref name="sequence1" /> is lexicographically greater than <paramref name="sequence2" />.
            Zero if <paramref name="sequence1" /> is equal to <paramref name="sequence2" />.</returns>
      <exception cref="T:System.NotSupportedException">T does not implement IComparable&lt;T&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Performs a lexicographical comparison of two sequences of values, using a supplied comparison delegate. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
      <typeparam name="T">Types of items to compare.</typeparam>
      <param name="sequence1">The first sequence to compare.</param>
      <param name="sequence2">The second sequence to compare.</param>
      <param name="comparison">The IComparison&lt;T&gt; delegate to compare items. 
            Only the Compare member function of this interface is called.</param>
      <returns>Less than zero if <paramref name="sequence1" /> is lexicographically less than <paramref name="sequence2" />.
            Greater than zero if <paramref name="sequence1" /> is lexicographically greater than <paramref name="sequence2" />.
            Zero if <paramref name="sequence1" /> is equal to <paramref name="sequence2" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Performs a lexicographical comparison of two sequences of values, using a supplied comparer interface. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
      <typeparam name="T">Types of items to compare.</typeparam>
      <param name="sequence1">The first sequence to compare.</param>
      <param name="sequence2">The second sequence to compare.</param>
      <param name="comparer">The IComparer&lt;T&gt; used to compare items. 
            Only the Compare member function of this interface is called.</param>
      <returns>Less than zero if <paramref name="sequence1" /> is lexicographically less than <paramref name="sequence2" />.
            Greater than zero if <paramref name="sequence1" /> is lexicographically greater than <paramref name="sequence2" />.
            Zero if <paramref name="sequence1" /> is equal to <paramref name="sequence2" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sequence1" />, <paramref name="sequence2" />, or 
            <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetLexicographicalComparer``1">
      <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be used
            for collections or algorithms that use sequences of T as an item type. The Lexicographical
            ordered of sequences is for comparison.
            </summary>
      <remarks>T must implement either IComparable&lt;T&gt; and this implementation is used
            to compare the items. </remarks>
      <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetLexicographicalComparer``1(System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be uses
            for collections or algorithms that use sequences of T as an item type. The Lexicographics
            ordered of sequences is for comparison.
            </summary>
      <param name="comparer">A comparer instance used to compare individual items of type T.</param>
      <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetLexicographicalComparer``1(System.Comparison{``0})">
      <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be uses
            for collections or algorithms that use sequences of T as an item type. The Lexicographics
            ordered of sequences is for comparison.
            </summary>
      <param name="comparison">A comparison delegate used to compare individual items of type T.</param>
      <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetReverseComparer``1(System.Collections.Generic.IComparer{``0})">
      <summary>
            Reverses the order of comparison of an IComparer&lt;T&gt;. The resulting comparer can be used,
            for example, to sort a collection in descending order. Equality and hash codes are unchanged.
            </summary>
      <typeparam name="T">The type of items thta are being compared.</typeparam>
      <param name="comparer">The comparer to reverse.</param>
      <returns>An IComparer&lt;T&gt; that compares items in the reverse order of <paramref name="comparer" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetIdentityComparer``1">
      <summary>
            Gets an IEqualityComparer&lt;T&gt; instance that can be used to compare objects
            of type T for object identity only. Two objects compare equal only if they
            are references to the same object. 
            </summary>
      <returns>An IEqualityComparer&lt;T&gt; instance for identity comparison.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetReverseComparison``1(System.Comparison{``0})">
      <summary>
            Reverses the order of comparison of an Comparison&lt;T&gt;. The resulting comparison can be used,
            for example, to sort a collection in descending order. 
            </summary>
      <typeparam name="T">The type of items that are being compared.</typeparam>
      <param name="comparison">The comparison to reverse.</param>
      <returns>A Comparison&lt;T&gt; that compares items in the reverse order of <paramref name="comparison" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetComparerFromComparison``1(System.Comparison{``0})">
      <summary>
            Given a comparison delegate that compares two items of type T, gets an
            IComparer&lt;T&gt; instance that performs the same comparison.
            </summary>
      <param name="comparison">The comparison delegate to use.</param>
      <returns>An IComparer&lt;T&gt; that performs the same comparing operation
            as <paramref name="comparison" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetComparisonFromComparer``1(System.Collections.Generic.IComparer{``0})">
      <summary>
            Given in IComparer&lt;T&gt; instenace that comparers two items from type T, 
            gets a Comparison delegate that performs the same comparison.
            </summary>
      <param name="comparer">The IComparer&lt;T&gt; instance to use.</param>
      <returns>A Comparison&lt;T&gt; delegate that performans the same comparing
            operation as <paramref name="comparer" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetCollectionEqualityComparer``1">
      <summary>
            Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, considered in order. This is the same notion of equality as
            in Algorithms.EqualCollections, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.
            </summary>
      <example>
            The following code creates a Dictionary where the keys are a collection of strings.
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetCollectionEqualityComparer&lt;string&gt;());
            </code></example>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetCollectionEqualityComparer``1(System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
        <para>Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, considered in order. This is the same notion of equality as
            in Algorithms.EqualCollections, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.</para>
        <para>An IEqualityComparer&lt;T&gt; is used to determine if individual T's are equal</para>
      </summary>
      <example>
            The following code creates a Dictionary where the keys are a collection of strings, compared in a case-insensitive way
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetCollectionEqualityComparer&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase));
            </code></example>
      <param name="equalityComparer">An IEqualityComparer&lt;T&gt; implementation used to compare individual T's.</param>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetSetEqualityComparer``1">
      <summary>
        <para>Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, without regard to order. This is the same notion of equality as
            in Algorithms.EqualSets, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.</para>
        <para>An IEqualityComparer&lt;T&gt; is used to determine if individual T's are equal</para>
      </summary>
      <example>
            The following code creates a Dictionary where the keys are a set of strings, without regard to order
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetSetEqualityComparer&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase));
            </code></example>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality, without regard to order.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetSetEqualityComparer``1(System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, without regard to order. This is the same notion of equality as
            in Algorithms.EqualSets, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.
            </summary>
      <example>
            The following code creates a Dictionary where the keys are a set of strings, without regard to order
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetSetEqualityComparer&lt;string&gt;());
            </code></example>
      <param name="equalityComparer">An IEqualityComparer&lt;T&gt; implementation used to compare individual T's.</param>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality, without regard to order.</returns>
      <seealso cref="M:Magnum.Collections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
    </member>
    <member name="M:Magnum.Collections.Algorithms.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Determines if a collection contains any item that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate" />. False if the collection does not contain
            an item that satisfies <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.TrueForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.CountWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to count items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>The number of items in the collection that satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RemoveWhere``1(System.Collections.Generic.ICollection{``0},System.Predicate{``0})">
      <summary>
            Removes all the items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>If the collection if an array or implements IList&lt;T&gt;, an efficient algorithm that
            compacts items is used. If not, then ICollection&lt;T&gt;.Remove is used
            to remove items from the collection. If the collection is an array or fixed-size list,
            the non-removed elements are placed, in order, at the beginning of
            the list, and the remaining list items are filled with a default value (0 or null).</remarks>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>Returns a collection of the items that were removed. This collection contains the
            items in the same order that they orginally appeared in <paramref name="collection" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Convert``2(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,``1})">
      <summary>
            Convert a collection of items by applying a delegate to each item in the collection. The resulting collection
            contains the result of applying <paramref name="converter" /> to each item in <paramref name="sourceCollection" />, in
            order.
            </summary>
      <typeparam name="TSource">The type of items in the collection to convert.</typeparam>
      <typeparam name="TDest">The type each item is being converted to.</typeparam>
      <param name="sourceCollection">The collection of item being converted.</param>
      <param name="converter">A delegate to the method to call, passing each item in <paramref name="sourceCollection" />.</param>
      <returns>The resulting collection from applying <paramref name="converter" /> to each item in <paramref name="sourceCollection" />, in
            order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sourceCollection" /> or <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetDictionaryConverter``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            Creates a delegate that converts keys to values by used a dictionary to map values. Keys
            that a not present in the dictionary are converted to the default value (zero or null).
            </summary>
      <remarks>This delegate can be used as a parameter in Convert or ConvertAll methods to convert
            entire collections.</remarks>
      <param name="dictionary">The dictionary used to perform the conversion.</param>
      <returns>A delegate to a method that converts keys to values. </returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.GetDictionaryConverter``2(System.Collections.Generic.IDictionary{``0,``1},``1)">
      <summary>
            Creates a delegate that converts keys to values by used a dictionary to map values. Keys
            that a not present in the dictionary are converted to a supplied default value.
            </summary>
      <remarks>This delegate can be used as a parameter in Convert or ConvertAll methods to convert
            entire collections.</remarks>
      <param name="dictionary">The dictionary used to perform the conversion.</param>
      <param name="defaultValue">The result of the conversion for keys that are not present in the dictionary.</param>
      <returns>A delegate to a method that converts keys to values. </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="dictionary" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Performs the specified action on each item in a collection.
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="action">An Action delegate which is invoked for each item in <paramref name="collection" />.</param>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Partition``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
      <summary>
            Partition a list or array based on a predicate. After partitioning, all items for which
            the predicate returned true precede all items for which the predicate returned false.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to partition.</param>
      <param name="predicate">A delegate that defines the partitioning condition.</param>
      <returns>The index of the first item in the second half of the partition; i.e., the first item for
            which <paramref name="predicate" /> returned false. If the predicate was true for all items
            in the list, list.Count is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.StablePartition``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
      <summary>
            Partition a list or array based on a predicate. After partitioning, all items for which
            the predicate returned true precede all items for which the predicate returned false. 
            The partition is stable, which means that if items X and Y have the same result from
            the predicate, and X precedes Y in the original list, X will precede Y in the 
            partitioned list.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to partition.</param>
      <param name="predicate">A delegate that defines the partitioning condition.</param>
      <returns>The index of the first item in the second half of the partition; i.e., the first item for
            which <paramref name="predicate" /> returned false. If the predicate was true for all items
            in the list, list.Count is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Concatenate``1(System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Concatenates all the items from several collections. The collections need not be of the same type, but
            must have the same item type.
            </summary>
      <param name="collections">The set of collections to concatenate. In many languages, this parameter
            can be specified as several individual parameters.</param>
      <returns>An IEnumerable that enumerates all the items in each of the collections, in order.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if the two collections contain equal items in the same order. The two collections do not need
            to be of the same type; it is permissible to compare an array and an OrderedBag, for instance.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <typeparam name="T">The type of items in the collections.</typeparam>
      <param name="collection1">The first collection to compare.</param>
      <param name="collection2">The second collection to compare.</param>
      <returns>True if the collections have equal items in the same order. If both collections are empty, true is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the two collections contain equal items in the same order. The passed 
            instance of IEqualityComparer&lt;T&gt; is used for determining if two items are equal.
            </summary>
      <typeparam name="T">The type of items in the collections.</typeparam>
      <param name="collection1">The first collection to compare.</param>
      <param name="collection2">The second collection to compare.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals member function of this interface is called.</param>
      <returns>True if the collections have equal items in the same order. If both collections are empty, true is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" />, <paramref name="collection2" />, or
            <paramref name="equalityComparer" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},Magnum.Collections.BinaryPredicate{``0})">
      <summary>
            Determines if the two collections contain "equal" items in the same order. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested
            for need not be equality. For example, the following code determines if each integer in
            list1 is less than or equal to the corresponding integer in list2.
            <code>
            List&lt;int&gt; list1, list2;
            if (EqualCollections(list1, list2, delegate(int x, int y) { return x &lt;= y; }) {
                // the check is true...
            }
            </code></remarks>
      <typeparam name="T">The type of items in the collections.</typeparam>
      <param name="collection1">The first collection to compare.</param>
      <param name="collection2">The second collection to compare.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". 
            This predicate can compute any relation between two items; it need not represent equality or an equivalence relation.</param>
      <returns>True if <paramref name="predicate" />returns true for each corresponding pair of
            items in the two collections. If both collections are empty, true is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" />, <paramref name="collection2" />, or
            <paramref name="predicate" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Create an array with the items in a collection.
            </summary>
      <remarks>If <paramref name="collection" /> implements ICollection&lt;T&gt;T, then 
            ICollection&lt;T&gt;.CopyTo() is used to fill the array. Otherwise, the IEnumerable&lt;T&gt;.GetEnumerator()
            is used to fill the array.</remarks>
      <typeparam name="T">Element type of the collection.</typeparam>
      <param name="collection">Collection to create array from.</param>
      <returns>An array with the items from the collection, in enumeration order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Count``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Count the number of items in an IEnumerable&lt;T&gt; collection. If 
            a more specific collection type is being used, it is more efficient to use
            the Count property, if one is provided.
            </summary>
      <remarks>If the collection implements ICollection&lt;T&gt;, this method
            simply returns ICollection&lt;T&gt;.Count. Otherwise, it enumerates all items
            and counts them.</remarks>
      <param name="collection">The collection to count items in.</param>
      <returns>The number of items in the collection.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.CountEqual``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Counts the number of items in the collection that are equal to <paramref name="find" />.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="collection">The collection to count items in.</param>
      <param name="find">The item to compare to.</param>
      <returns>The number of items in the collection that are equal to <paramref name="find" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Algorithms.CountEqual``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Counts the number of items in the collection that are equal to <paramref name="find" />.
            </summary>
      <param name="collection">The collection to count items in.</param>
      <param name="find">The item to compare to.</param>
      <param name="equalityComparer">The comparer to use to determine if two items are equal. Only the Equals
            member function will be called.</param>
      <returns>The number of items in the collection that are equal to <paramref name="find" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="collection" /> or <paramref name="equalityComparer" />
            is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.NCopiesOf``1(System.Int32,``0)">
      <summary>
            Creates an IEnumerator that enumerates a given item <paramref name="n" /> times.
            </summary>
      <example>
            The following creates a list consisting of 1000 copies of the double 1.0.
            <code>
            List&lt;double&gt; list = new List&lt;double&gt;(Algorithms.NCopiesOf(1000, 1.0));
            </code></example>
      <param name="n">The number of times to enumerate the item.</param>
      <param name="item">The item that should occur in the enumeration.</param>
      <returns>An IEnumerable&lt;T&gt; that yields <paramref name="n" /> copies
            of <paramref name="item" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The argument <paramref name="n" /> is less than zero.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Fill``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Replaces each item in a list with a given value. The list does not change in size.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to modify.</param>
      <param name="value">The value to fill with.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="list" /> is a read-only list.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Fill``1(``0[],``0)">
      <summary>
            Replaces each item in a array with a given value. 
            </summary>
      <param name="array">The array to modify.</param>
      <param name="value">The value to fill with.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FillRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,``0)">
      <summary>
            Replaces each item in a part of a list with a given value.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to modify.</param>
      <param name="start">The index at which to start filling. The first index in the list has index 0.</param>
      <param name="count">The number of items to fill.</param>
      <param name="value">The value to fill with.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="list" /> is a read-only list.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative, or 
            <paramref name="start" /> + <paramref name="count" /> is greater than <paramref name="list" />.Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.FillRange``1(``0[],System.Int32,System.Int32,``0)">
      <summary>
            Replaces each item in a part of a array with a given value.
            </summary>
      <param name="array">The array to modify.</param>
      <param name="start">The index at which to start filling. The first index in the array has index 0.</param>
      <param name="count">The number of items to fill.</param>
      <param name="value">The value to fill with.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative, or 
            <paramref name="start" /> + <paramref name="count" /> is greater than <paramref name="array" />.Length.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Copies all of the items from the collection <paramref name="source" /> to the list <paramref name="dest" />, starting
            at the index <paramref name="destIndex" />. If necessary, the size of the destination list is expanded.
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="dest">The list to store the items into.</param>
      <param name="destIndex">The index to begin copying items to.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32)">
      <summary>
            Copies all of the items from the collection <paramref name="source" /> to the array <paramref name="dest" />, starting
            at the index <paramref name="destIndex" />. 
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="dest">The array to store the items into.</param>
      <param name="destIndex">The index to begin copying items to.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Length.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
      <exception cref="T:System.ArgumentException">The collection has more items than will fit into the array. In this case, the array
            has been filled with as many items as fit before the exception is thrown.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
      <summary>
            Copies at most <paramref name="count" /> items from the collection <paramref name="source" /> to the list <paramref name="dest" />, starting
            at the index <paramref name="destIndex" />. If necessary, the size of the destination list is expanded. The source collection must not be
            the destination list or part thereof.
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="dest">The list to store the items into.</param>
      <param name="destIndex">The index to begin copying items to.</param>
      <param name="count">The maximum number of items to copy.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Count</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32,System.Int32)">
      <summary>
            Copies at most <paramref name="count" /> items from the collection <paramref name="source" /> to the array <paramref name="dest" />, starting
            at the index <paramref name="destIndex" />. The source collection must not be
            the destination array or part thereof.
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="dest">The array to store the items into.</param>
      <param name="destIndex">The index to begin copying items to.</param>
      <param name="count">The maximum number of items to copy. The array must be large enought to fit this number of items.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Length.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or <paramref name="destIndex" /> + <paramref name="count" />
            is greater than <paramref name="dest" />.Length.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
      <summary>
            Copies <paramref name="count" /> items from the list <paramref name="source" />, starting at the index <paramref name="sourceIndex" />, 
            to the list <paramref name="dest" />, starting at the index <paramref name="destIndex" />. If necessary, the size of the destination list is expanded.
            The source and destination lists may be the same.
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="sourceIndex">The index within <paramref name="source" />to begin copying items from.</param>
      <param name="dest">The list to store the items into.</param>
      <param name="destIndex">The index within <paramref name="dest" />to begin copying items to.</param>
      <param name="count">The maximum number of items to copy.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sourceIndex" /> is negative or 
            greater than <paramref name="source" />.Count</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Count</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or too large.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Copy``1(System.Collections.Generic.IList{``0},System.Int32,``0[],System.Int32,System.Int32)">
      <summary>
            Copies <paramref name="count" /> items from the list or array <paramref name="source" />, starting at the index <paramref name="sourceIndex" />, 
            to the array <paramref name="dest" />, starting at the index <paramref name="destIndex" />. 
            The source may be the same as the destination array.
            </summary>
      <param name="source">The list or array that provide the source items. </param>
      <param name="sourceIndex">The index within <paramref name="source" />to begin copying items from.</param>
      <param name="dest">The array to store the items into.</param>
      <param name="destIndex">The index within <paramref name="dest" />to begin copying items to.</param>
      <param name="count">The maximum number of items to copy. The destination array must be large enough to hold this many items.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sourceIndex" /> is negative or 
            greater than <paramref name="source" />.Count</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Length</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or too large.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Reverse``1(System.Collections.Generic.IList{``0})">
      <summary>
            Reverses a list and returns the reversed list, without changing the source list.
            </summary>
      <param name="source">The list to reverse.</param>
      <returns>A collection that contains the items from <paramref name="source" /> in reverse order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.ReverseInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Reverses a list or array in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to reverse.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="list" /> is read only.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.Rotate``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Rotates a list and returns the rotated list, without changing the source list.
            </summary>
      <param name="source">The list to rotate.</param>
      <param name="amountToRotate">The number of elements to rotate. This value can be positive or negative. 
            For example, rotating by positive 3 means that source[3] is the first item in the returned collection.
            Rotating by negative 3 means that source[source.Count - 3] is the first item in the returned collection.</param>
      <returns>A collection that contains the items from <paramref name="source" /> in rotated order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Algorithms.RotateInPlace``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Rotates a list or array in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to rotate.</param>
      <param name="amountToRotate">The number of elements to rotate. This value can be positive or negative. 
            For example, rotating by positive 3 means that list[3] is the first item in the resulting list.
            Rotating by negative 3 means that list[list.Count - 3] is the first item in the resulting list.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="T:Magnum.Collections.CollectionBase`1">
      <summary>
            CollectionBase is a base class that can be used to more easily implement the
            generic ICollection&lt;T&gt; and non-generic ICollection interfaces.
            </summary>
      <remarks>
        <para>To use CollectionBase as a base class, the derived class must override
            the Count, GetEnumerator, Add, Clear, and Remove methods. </para>
        <para>ICollection&lt;T&gt;.Contains need not be implemented by the
            derived class, but it should be strongly considered, because the CollectionBase implementation
            may not be very efficient.</para>
      </remarks>
      <typeparam name="T">The item type of the collection.</typeparam>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.ToString">
      <summary>
            Shows the string representation of the collection. The string representation contains
            a list of the items in the collection. Contained collections (except string) are expanded
            recursively.
            </summary>
      <returns>The string representation of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.DebuggerDisplayString">
      <summary>
            Display the contents of the collection in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.Add(`0)">
      <summary>
            Must be overridden to allow adding items to this collection.
            </summary>
      <remarks>
        <p>This method is not abstract, although derived classes should always
            override it. It is not abstract because some derived classes may wish to reimplement
            Add with a different return type (typically bool). In C#, this can be accomplished
            with code like the following:</p>
        <code>
                public class MyCollection&lt;T&gt;: CollectionBase&lt;T&gt;, ICollection&lt;T&gt;
                {
                    public new bool Add(T item) {
                        /* Add the item */
                    }
             
                    void ICollection&lt;T&gt;.Add(T item) {
                        Add(item);
                    }
                }
            </code>
      </remarks>
      <param name="item">Item to be added to the collection.</param>
      <exception cref="T:System.NotImplementedException">Always throws this exception to indicated
            that the method must be overridden or re-implemented in the derived class.</exception>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.Clear">
      <summary>
            Must be overridden to allow clearing this collection.
            </summary>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.Remove(`0)">
      <summary>
            Must be overridden to allow removing items from this collection.
            </summary>
      <returns>True if <paramref name="item" /> existed in the collection and
            was removed. False if <paramref name="item" /> did not exist in the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.Contains(`0)">
      <summary>
            Determines if the collection contains a particular item. This default implementation
            iterates all of the items in the collection via GetEnumerator, testing each item
            against <paramref name="item" /> using IComparable&lt;T&gt;.Equals or
            Object.Equals.
            </summary>
      <remarks>You should strongly consider overriding this method to provide
            a more efficient implementation, or if the default equality comparison
            is inappropriate.</remarks>
      <param name="item">The item to check for in the collection.</param>
      <returns>True if the collection contains <paramref name="item" />, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
      <param name="array">Array to copy to.</param>
      <param name="arrayIndex">Starting index in <paramref name="array" /> to copy to.</param>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.ToArray">
      <summary>
            Creates an array of the correct size, and copies all the items in the 
            collection into the array, by calling CopyTo.
            </summary>
      <returns>An array containing all the elements in the collection, in order.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.AsReadOnly">
      <summary>
            Provides a read-only view of this collection. The returned ICollection&lt;T&gt; provides
            a view of the collection that prevents modifications to the collection. Use the method to provide
            access to the collection without allowing changes. Since the returned object is just a view,
            changes to the collection will be reflected in the view.
            </summary>
      <returns>An ICollection&lt;T&gt; that provides read-only access to the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.Exists(System.Predicate{`0})">
      <summary>
            Determines if the collection contains any item that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate" />. False if the collection does not contain
            an item that satisfies <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.TrueForAll(System.Predicate{`0})">
      <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.CountWhere(System.Predicate{`0})">
      <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>The number of items in the collection that satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.FindAll(System.Predicate{`0})">
      <summary>
            Enumerates the items in the collection that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.RemoveAll(System.Predicate{`0})">
      <summary>
            Removes all the items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>Returns a collection of the items that were removed, in sorted order.</returns>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.ForEach(System.Action{`0})">
      <summary>
            Performs the specified action on each item in this collection.
            </summary>
      <param name="action">An Action delegate which is invoked for each item in this collection.</param>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.ConvertAll``1(System.Converter{`0,``0})">
      <summary>
            Convert this collection of items by applying a delegate to each item in the collection. The resulting enumeration
            contains the result of applying <paramref name="converter" /> to each item in this collection, in
            order.
            </summary>
      <typeparam name="TOutput">The type each item is being converted to.</typeparam>
      <param name="converter">A delegate to the method to call, passing each item in this collection.</param>
      <returns>An IEnumerable&lt;TOutput^gt; that enumerates the resulting collection from applying <paramref name="converter" /> to each item in this collection in
            order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.CollectionBase`1.GetEnumerator">
      <summary>
            Must be overridden to enumerate all the members of the collection.
            </summary>
      <returns>A generic IEnumerator&lt;T&gt; that can be used
            to enumerate all the items in the collection.</returns>
    </member>
    <member name="P:Magnum.Collections.CollectionBase`1.Count">
      <summary>
            Must be overridden to provide the number of items in the collection.
            </summary>
      <value>The number of items in the collection.</value>
    </member>
    <member name="T:Magnum.Collections.ListBase`1">
      <summary>
            ListBase is an abstract class that can be used as a base class for a read-write collection that needs 
            to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs
            to override the following methods: Count, Clear, Insert, RemoveAt, and the indexer. The implementation
            of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Clear">
      <summary>
            This method must be overridden by the derived class to empty the list
            of all items.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Insert(System.Int32,`0)">
      <summary>
            This method must be overridden by the derived class to insert a new
            item at the given index. 
            </summary>
      <param name="index">The index in the list to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item in the list has index 0.</param>
      <param name="item">The item to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.RemoveAt(System.Int32)">
      <summary>
            This method must be overridden by the derived class to remove the
            item at the given index. 
            </summary>
      <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on.
            </summary>
      <remarks>The enumerator does not check for changes made
            to the structure of the list. Thus, changes to the list during
            enumeration may cause incorrect enumeration or out of range
            exceptions. Consider overriding this method and adding checks
            for structural changes.</remarks>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Contains(`0)">
      <summary>
            Determines if the list contains any item that compares equal to <paramref name="item" />.
            The implementation simply checks whether IndexOf(item) returns a non-negative value.
            </summary>
      <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the list contains an item that compares equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Add(`0)">
      <summary>
            Adds an item to the end of the list. This method is equivalent to calling: 
            <code>Insert(Count, item)</code></summary>
      <param name="item">The item to add to the list.</param>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Remove(`0)">
      <summary>
            Searches the list for the first item that compares equal to <paramref name="item" />.
            If one is found, it is removed. Otherwise, the list is unchanged.
            </summary>
      <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
      <param name="item">The item to remove from the list.</param>
      <returns>True if an item was found and removed that compared equal to
            <paramref name="item" />. False if no such item was in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.IndexOf(`0)">
      <summary>
            Finds the index of the first item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the first item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.CopyTo(`0[])">
      <summary>
            Copies all the items in the list, in order, to <paramref name="array" />,
            starting at index 0.
            </summary>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count.</param>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
      <summary>
            Copies a range of elements from the list to <paramref name="array" />,
            starting at <paramref name="arrayIndex" />.
            </summary>
      <param name="index">The starting index in the source list of the range to copy.</param>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
      <param name="arrayIndex">The starting index in <paramref name="array" />
            to copy to.</param>
      <param name="count">The number of items to copy.</param>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.AsReadOnly">
      <summary>
            Provides a read-only view of this list. The returned IList&lt;T&gt; provides
            a view of the list that prevents modifications to the list. Use the method to provide
            access to the list without allowing changes. Since the returned object is just a view,
            changes to the list will be reflected in the view.
            </summary>
      <returns>An IList&lt;T&gt; that provides read-only access to the list.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Find(System.Predicate{`0})">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:Magnum.Collections.ListBase`1.TryFind(System.Predicate{`0},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:Magnum.Collections.ListBase`1.TryFind(System.Predicate{`0},`0@)" />
    </member>
    <member name="M:Magnum.Collections.ListBase`1.TryFind(System.Predicate{`0},`0@)">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the first item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindLast(System.Predicate{`0})">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:Magnum.Collections.ListBase`1.TryFindLast(System.Predicate{`0},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:Magnum.Collections.ListBase`1.TryFindLast(System.Predicate{`0},`0@)" />
    </member>
    <member name="M:Magnum.Collections.ListBase`1.TryFindLast(System.Predicate{`0},`0@)">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the last item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindIndex(System.Predicate{`0})">
      <summary>
            Finds the index of the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindIndex(System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindLastIndex(System.Predicate{`0})">
      <summary>
            Finds the index of the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindLastIndex(System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.IndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.IndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.LastIndexOf(`0)">
      <summary>
            Finds the index of the last item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the last item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.LastIndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.LastIndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, 
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.Range(System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
      <remarks>
        <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
        <code>Algorithms.ReverseInPlace(deque.Range(3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
      <param name="start">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-part of this list. </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> + <paramref name="count" /> is greater than the
            size of the list.</exception>
    </member>
    <member name="M:Magnum.Collections.ListBase`1.ConvertToItemType(System.String,System.Object)">
      <summary>
            Convert the given parameter to T. Throw an ArgumentException
            if it isn't.
            </summary>
      <param name="name">parameter name</param>
      <param name="value">parameter value</param>
    </member>
    <member name="P:Magnum.Collections.ListBase`1.Count">
      <summary>
            The property must be overridden by the derived class to return the number of 
            items in the list.
            </summary>
      <value>The number of items in the list.</value>
    </member>
    <member name="P:Magnum.Collections.ListBase`1.Item(System.Int32)">
      <summary>
            The indexer must be overridden by the derived class to get and set
            values of the list at a particular index.
            </summary>
      <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.Bag`1">
      <summary>
             Bag&lt;T&gt; is a collection that contains items of type T. 
             Unlike a Set, duplicate items (items that compare equal to each other) are allowed in an Bag. 
             </summary>
      <remarks>
        <p>The items are compared in one of two ways. If T implements IComparable&lt;T&gt; 
             then the Equals method of that interface will be used to compare items, otherwise the Equals
             method from Object will be used. Alternatively, an instance of IComparer&lt;T&gt; can be passed
             to the constructor to use to compare items.</p>
        <p>Bag is implemented as a hash table. Inserting, deleting, and looking up an
             an element all are done in approximately constant time, regardless of the number of items in the bag.</p>
        <p>When multiple equal items are stored in the bag, they are stored as a representative item and a count. 
             If equal items can be distinguished, this may be noticable. For example, if a case-insensitive
             comparer is used with a Bag&lt;string&gt;, and both "hello", and "HELLO" are added to the bag, then the
             bag will appear to contain two copies of "hello" (the representative item).</p>
        <p>
          <see cref="T:Magnum.Collections.OrderedBag`1" /> is similar, but uses comparison instead of hashing, maintain
             the items in sorted order, and stores distinct copies of items that compare equal.</p>
      </remarks>
      <seealso cref="T:Magnum.Collections.OrderedBag`1" />
    </member>
    <member name="M:Magnum.Collections.Bag`1.NewPair(`0,System.Int32)">
      <summary>
            Helper function to create a new KeyValuePair struct with an item and a count.
            </summary>
      <param name="item">The item.</param>
      <param name="count">The number of appearances.</param>
      <returns>A new KeyValuePair.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.NewPair(`0)">
      <summary>
            Helper function to create a new KeyValuePair struct with a count of zero.
            </summary>
      <param name="item">The item.</param>
      <returns>A new KeyValuePair.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.#ctor">
      <summary>
             Creates a new Bag. 
             </summary>
      <remarks>
             Items that are null are permitted.
            </remarks>
    </member>
    <member name="M:Magnum.Collections.Bag`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Bag. The Equals and GetHashCode methods of the passed comparison object
            will be used to compare items in this bag for equality.
            </summary>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new Bag. The bag is
             initialized with all the items in the given collection.
             </summary>
      <remarks>
             Items that are null are permitted.
            </remarks>
      <param name="collection">A collection with items to be placed into the Bag.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Bag. The Equals and GetHashCode methods of the passed comparison object
            will be used to compare items in this bag. The bag is
            initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the Bag.</param>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.#ctor(System.Collections.Generic.IEqualityComparer{System.Collections.Generic.KeyValuePair{`0,System.Int32}},System.Collections.Generic.IEqualityComparer{`0},Magnum.Collections.Hash{System.Collections.Generic.KeyValuePair{`0,System.Int32}},System.Int32)">
      <summary>
            Creates a new Bag given a comparer and a hash that contains the data. Used
            internally for Clone.
            </summary>
      <param name="equalityComparer">IEqualityComparer for the bag.</param>
      <param name="keyEqualityComparer">IEqualityComparer for the key.</param>
      <param name="hash">Data for the bag.</param>
      <param name="count">Size of the bag.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Clone">
      <summary>
            Makes a shallow clone of this bag; i.e., if items of the
            bag are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the bag takes time O(N), where N is the number of unquie items in the bag.</remarks>
      <returns>The cloned bag.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.CloneContents">
      <summary>
            Makes a deep clone of this bag. A new bag is created with a clone of
            each element of this bag, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the bag takes time O(N log N), where N is the number of items in the bag.</para>
      </remarks>
      <returns>The cloned bag.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.NumberOfCopies(`0)">
      <summary>
            Returns the number of copies of <paramref name="item" /> in the bag. 
            </summary>
      <remarks>NumberOfCopies() takes approximately constant time, no matter how many items
            are stored in the bag.</remarks>
      <param name="item">The item to search for in the bag.</param>
      <returns>The number of items in the bag that compare equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.GetRepresentativeItem(`0,`0@)">
      <summary>
            Returns the representative item stored in the bag that is equal to
            the provided item. Also returns the number of copies of the item in the bag.
            </summary>
      <param name="item">Item to find in the bag.</param>
      <param name="representative">If one or more items equal to <paramref name="item" /> are present in the
            bag, returns the representative item. If no items equal to <paramref name="item" /> are stored in the bag, 
            returns <paramref name="item" />.</param>
      <returns>The number of items equal to <paramref name="item" /> stored in the bag.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the bag. 
            If an item is present multiple times in the bag, the representative item is yielded by the
            enumerator multiple times. The order of enumeration is haphazard and may change.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the bag while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the items in the bag takes time O(N), where N is the number
            of items in the bag.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the Bag.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Contains(`0)">
      <summary>
            Determines if this bag contains an item equal to <paramref name="item" />. The bag
            is not changed.
            </summary>
      <remarks>Searching the bag for an item takes time O(log N), where N is the number of items in the bag.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the bag contains <paramref name="item" />. False if the bag does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.DistinctItems">
      <summary>
            Enumerates all the items in the bag, but enumerates equal items
            just once, even if they occur multiple times in the bag.
            </summary>
      <remarks>If the bag is changed while items are being enumerated, the
            enumeration will terminate with an InvalidOperationException.</remarks>
      <returns>An IEnumerable&lt;T&gt; that enumerates the unique items.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Add(`0)">
      <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item" />. In
            this case, the count of items for the representative item is increased by one, but the existing
            represetative item is unchanged.
            </summary>
      <remarks>
        <para>Adding an item takes approximately constant time, regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to add to the bag.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.AddRepresentative(`0)">
      <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item" />. In
            this case (unlike Add), the new item becomes the representative item.
            </summary>
      <remarks>
        <para>Adding an item takes approximately constant time, regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to add to the bag.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.ChangeNumberOfCopies(`0,System.Int32)">
      <summary>
            Changes the number of copies of an existing item in the bag, or adds the indicated number
            of copies of the item to the bag. 
            </summary>
      <remarks>
        <para>Changing the number of copies takes approximately constant time, regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to change the number of copies of. This may or may not already be present in the bag.</param>
      <param name="numCopies">The new number of copies of the item.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the bag. 
            </summary>
      <remarks>
        <para>Adding the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the bag.</param>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Remove(`0)">
      <summary>
            Searches the bag for one item equal to <paramref name="item" />, and if found,
            removes it from the bag. If not found, the bag is unchanged. 
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>Removing an item from the bag takes approximated constant time,
            regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the bag.</returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.RemoveAllCopies(`0)">
      <summary>
            Searches the bag for all items equal to <paramref name="item" />, and 
            removes all of them from the bag. If not found, the bag is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparer instance used
            to create the bag.</para>
        <para>RemoveAllCopies() takes time O(M log N), where N is the total number of items in the bag, and M is
            the number of items equal to <paramref name="item" />.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>The number of copies of <paramref name="item" /> that were found and removed. </returns>
    </member>
    <member name="M:Magnum.Collections.Bag`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the bag. Items that
            are not present in the bag are ignored.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparer instance used
            to create the bag.</para>
        <para>Removing the collection takes time O(M), where M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the bag.</param>
      <returns>The number of items removed from the bag.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Clear">
      <summary>
            Removes all items from the bag.
            </summary>
      <remarks>Clearing the bag takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsEqualTo(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is equal to another bag. This bag is equal to
            <paramref name="otherBag" /> if they contain the same number of 
            of copies of equal elements.
            </summary>
      <remarks>IsSupersetOf is computed in time O(N), where N is the number of unique items in 
            this bag.</remarks>
      <param name="otherBag">Bag to compare to</param>
      <returns>True if this bag is equal to <paramref name="otherBag" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsSupersetOf(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is a superset of another bag. Neither bag is modified.
            This bag is a superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times.
            </summary>
      <remarks>IsSupersetOf is computed in time O(M), where M is the number of unique items in 
            <paramref name="otherBag" />.</remarks>
      <param name="otherBag">Bag to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsProperSupersetOf(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is a proper superset of another bag. Neither bag is modified.
            This bag is a proper superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times. Additional, this bag must have strictly more items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsProperSupersetOf is computed in time O(M), where M is the number of unique items in 
            <paramref name="otherBag" />.</remarks>
      <param name="otherBag">Set to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsSubsetOf(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is a subset of another ba11 items in this bag.
            </summary>
      <param name="otherBag">Bag to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsProperSubsetOf(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is a proper subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag" /> if every element in this bag
            is also in <paramref name="otherBag" />, at least the same number of
            times. Additional, this bag must have strictly fewer items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsProperSubsetOf is computed in time O(N), where N is the number of unique items in this bag.</remarks>
      <param name="otherBag">Bag to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IsDisjointFrom(Magnum.Collections.Bag{`0})">
      <summary>
            Determines if this bag is disjoint from another bag. Two bags are disjoint
            if no item from one set is equal to any item in the other bag.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherBag">Bag to check disjointness with.</param>
      <returns>True if the two bags are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.UnionWith(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. This bag receives
            the union of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M+N), where M and N are the size of the 
            two bags.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Union(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. A new bag is 
            created with the union of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M+N), where M and N are the size of the two bags.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <returns>The union of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.SumWith(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the sum of this bag with another bag. The sum of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. This bag receives
            the sum of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M), where M is the size of the 
            other bag..</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Sum(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the sum of this bag with another bag. he sum of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. A new bag is 
            created with the sum of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <returns>The sum of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.IntersectionWith(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. This bag receives
            the intersection of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N), where N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Intersection(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the intersection contains the item Minimum(X,Y) times. A new bag is 
            created with the intersection of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N), where N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <returns>The intersection of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.DifferenceWith(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). This bag receives
            the difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M), where M is the size of the 
            other bag.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.Difference(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X).  A new bag is 
            created with the difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M + N), where M and N are the size
            of the two bags.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <returns>The difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.SymmetricDifferenceWith(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y) times. This bag receives
            the symmetric difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.SymmetricDifference(Magnum.Collections.Bag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y) times. A new bag is 
            created with the symmetric difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <returns>The symmetric difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Bag`1.CheckConsistentComparison(Magnum.Collections.Bag{`0})">
      <summary>
            Check that this bag and another bag were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
      <param name="otherBag">Other bag to check comparision mechanism.</param>
      <exception cref="T:System.InvalidOperationException">If otherBag and this bag don't use the same method for comparing items.</exception>
    </member>
    <member name="P:Magnum.Collections.Bag`1.Comparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare items in this bag. 
            </summary>
      <value>If the bag was created using a comparer, that comparer is returned. Otherwise
            the default comparer for T (EqualityComparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.Bag`1.Count">
      <summary>
            Returns the number of items in the bag.
            </summary>
      <remarks>The size of the bag is returned in constant time.</remarks>
      <value>The number of items in the bag.</value>
    </member>
    <member name="T:Magnum.Collections.BigList`1">
      <summary>
            BigList&lt;T&gt; provides a list of items, in order, with indices of the items ranging from 0 to one less
            than the count of items in the collection. BigList&lt;T&gt; is optimized for efficient operations on large (&gt;100 items)
            lists, especially for insertions, deletions, copies, and concatinations.
            </summary>
      <remarks>
        <para>BigList&lt;T&gt; class is similar in functionality to the standard List&lt;T&gt; class. Both classes
            provide a collection that stores an set of items in order, with indices of the items ranging from 0 to one less
            than the count of items in the collection. Both classes provide the ability to add and remove items from any index,
            and the get or set the item at any index.</para>
        <para>BigList&lt;T&gt; differs significantly from List&lt;T&gt; in the performance of various operations, 
            especially when the lists become large (several hundred items or more). With List&lt;T&gt;, inserting or removing
            elements from anywhere in a large list except the end is very inefficient -- every item after the point of inserting
            or deletion has to be moved in the list. The BigList&lt;T&gt; class, however, allows for fast insertions
            and deletions anywhere in the list. Furthermore, BigList&lt;T&gt; allows copies of a list, sub-parts
            of a list, and concatinations of two lists to be very fast. When a copy is made of part or all of a BigList,
            two lists shared storage for the parts of the lists that are the same. Only when one of the lists is changed is additional
            memory allocated to store the distinct parts of the lists.</para>
        <para>Of course, there is a small price to pay for this extra flexibility. Although still quite efficient, using an 
            index to get or change one element of a BigList, while still reasonably efficient, is significantly slower than using
            a plain List. Because of this, if you want to process every element of a BigList, using a foreach loop is a lot
            more efficient than using a for loop and indexing the list.</para>
        <para>In general, use a List when the only operations you are using are Add (to the end), foreach,
            or indexing, or you are very sure the list will always remain small (less than 100 items). For large (&gt;100 items) lists
            that do insertions, removals, copies, concatinations, or sub-ranges, BigList will be more efficient than List. 
            In almost all cases, BigList is more efficient and easier to use than LinkedList.</para>
      </remarks>
      <typeparam name="T">The type of items to store in the BigList.</typeparam>
    </member>
    <member name="T:Magnum.Collections.BigList`1.Node">
      <summary>
            The base class for the two kinds of nodes in the tree: Concat nodes
            and Leaf nodes.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.MarkShared">
      <summary>
            Marks this node as shared by setting the shared variable.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.GetAt(System.Int32)">
      <summary>
            Returns the items at the given index in this node.
            </summary>
      <param name="index">0-based index, relative to this node.</param>
      <returns>Item at that index.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.Subrange(System.Int32,System.Int32)">
      <summary>
            Returns a node that has a sub-range of items from this node. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive first element, relative to this node.</param>
      <param name="last">Inclusize last element, relative to this node.</param>
      <returns>Node with the given sub-range.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. Never changes this node, but returns
            a new node with the removing done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A new node with the sub-range removed.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.RemoveRangeInPlace(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. May change this node, or returns
            a new node with the given appending done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A node with the sub-range removed. If done in-place, returns
            "this".</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.Validate">
      <summary>
            Validates the node for consistency, as much as possible. Also validates
            child nodes, if any.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.Print(System.String,System.String)">
      <summary>
            Print out the contents of this node.
            </summary>
      <param name="prefixNode">Prefix to use in front of this node.</param>
      <param name="prefixChildren">Prefixed to use in front of children of this node.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.IsBalanced">
      <summary>
            Determine if this node is balanced. A node is balanced if the number
            of items is greater than
            Fibonacci(Depth+2). Balanced nodes are never rebalanced unless
            they go out of balance again.
            </summary>
      <returns>True if the node is balanced by this definition.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Node.IsAlmostBalanced">
      <summary>
            Determine if this node is almost balanced. A node is almost balanced if t
            its depth is at most one greater than a fully balanced node with the same count.
            </summary>
      <returns>True if the node is almost balanced by this definition.</returns>
    </member>
    <member name="P:Magnum.Collections.BigList`1.Node.Count">
      <summary>
            The number of items stored in the node (or below it).
            </summary>
      <value>The number of items in the node or below.</value>
    </member>
    <member name="P:Magnum.Collections.BigList`1.Node.Shared">
      <summary>
            Is this node shared by more that one list (or within a single)
            lists. If true, indicates that this node, and any nodes below it,
            may never be modified. Never becomes false after being set to 
            true.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Magnum.Collections.BigList`1.Node.Depth">
      <summary>
            Gets the depth of this node. A leaf node has depth 0, 
            a concat node with two leaf children has depth 1, etc.
            </summary>
      <value>The depth of this node.</value>
    </member>
    <member name="T:Magnum.Collections.BigList`1.LeafNode">
      <summary>
            The LeafNode class is the type of node that lives at the leaf of a tree and holds
            the actual items stored in the list. Each leaf holds at least 1, and at most MAXLEAF
            items in the items array. The number of items stored is found in "count", which may
            be less than "items.Length".
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.GetAt(System.Int32)">
      <summary>
            Returns the items at the given index in this node.
            </summary>
      <param name="index">0-based index, relative to this node.</param>
      <returns>Item at that index.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.RemoveRangeInPlace(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. May change this node, or returns
            a new node with the given appending done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A node with the sub-range removed. If done in-place, returns
            "this".</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. Never changes this node, but returns
            a new node with the removing done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A new node with the sub-range removed.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.Subrange(System.Int32,System.Int32)">
      <summary>
            Returns a node that has a sub-range of items from this node. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive first element, relative to this node.</param>
      <param name="last">Inclusize last element, relative to this node.</param>
      <returns>Node with the given sub-range.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.Validate">
      <summary>
            Validates the node for consistency, as much as possible. Also validates
            child nodes, if any.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafNode.Print(System.String,System.String)">
      <summary>
            Print out the contents of this node.
            </summary>
      <param name="prefixNode">Prefix to use in front of this node.</param>
      <param name="prefixChildren">Prefixed to use in front of children of this node.</param>
    </member>
    <member name="T:Magnum.Collections.BigList`1.ConcatNode">
      <summary>
            A ConcatNode is an interior (non-leaf) node that represents the concatination of
            the left and right child nodes. Both children must always be non-null.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.GetAt(System.Int32)">
      <summary>
            Returns the items at the given index in this node.
            </summary>
      <param name="index">0-based index, relative to this node.</param>
      <returns>Item at that index.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.RemoveRangeInPlace(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. May change this node, or returns
            a new node with the given appending done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A node with the sub-range removed. If done in-place, returns
            "this".</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Remove a range of items from this node. Never changes this node, but returns
            a new node with the removing done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
      <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
      <returns>A new node with the sub-range removed.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.Subrange(System.Int32,System.Int32)">
      <summary>
            Returns a node that has a sub-range of items from this node. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
      <param name="first">Inclusive first element, relative to this node.</param>
      <param name="last">Inclusize last element, relative to this node.</param>
      <returns>Node with the given sub-range.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.Validate">
      <summary>
            Validates the node for consistency, as much as possible. Also validates
            child nodes, if any.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConcatNode.Print(System.String,System.String)">
      <summary>
            Print out the contents of this node.
            </summary>
      <param name="prefixNode">Prefix to use in front of this node.</param>
      <param name="prefixChildren">Prefixed to use in front of children of this node.</param>
    </member>
    <member name="P:Magnum.Collections.BigList`1.ConcatNode.Depth">
      <summary>
            The depth of this node -- the maximum length path to 
            a leaf. If this node has two children that are leaves, the
            depth in 1.
            </summary>
      <value>The depth of this node.</value>
    </member>
    <member name="T:Magnum.Collections.BigList`1.BigListRange">
      <summary>
            The class that is used to implement IList&lt;T&gt; to view a sub-range
            of a BigList. The object stores a wrapped list, and a start/count indicating
            a sub-range of the list. Insertion/deletions through the sub-range view
            cause the count to change also; insertions and deletions directly on
            the wrapped list do not.
            </summary>
      <remarks>This is different from Algorithms.Range in a very few respects:
            it is specialized to only wrap BigList, and it is a lot more efficient in enumeration.</remarks>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor">
      <summary>
            Creates a new BigList. The BigList is initially empty.
            </summary>
      <remarks>Creating a empty BigList takes constant time and consumes a very small amount of memory.</remarks>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new BigList initialized with the items from <paramref name="collection" />, in order.
            </summary>
      <remarks>Initializing the tree list with the elements of collection takes time O(N), where N is the number of
            items in <paramref name="collection" />.</remarks>
      <param name="collection">The collection used to initialize the BigList. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
      <summary>
            Creates a new BigList initialized with a given number of copies of the items from <paramref name="collection" />, in order. 
            </summary>
      <remarks>Initializing the tree list with the elements of collection takes time O(N + log K), where N is the number of
            items in <paramref name="collection" />, and K is the number of copies.</remarks>
      <param name="copies">Number of copies of the collection to use.</param>
      <param name="collection">The collection used to initialize the BigList. </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="copies" /> is negative.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor(Magnum.Collections.BigList{`0})">
      <summary>
            Creates a new BigList that is a copy of <paramref name="list" />.
            </summary>
      <remarks>Copying a BigList takes constant time, and little 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
      <param name="list">The BigList to copy. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor(Magnum.Collections.BigList{`0},System.Int32)">
      <summary>
            Creates a new BigList that is several copies of <paramref name="list" />.
            </summary>
      <remarks>Creating K copies of a BigList takes time O(log K), and O(log K) 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
      <param name="copies">Number of copies of the collection to use.</param>
      <param name="list">The BigList to copy. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.#ctor(Magnum.Collections.BigList{`0}.Node)">
      <summary>
            Creates a new BigList from the indicated Node.
            </summary>
      <param name="node">Node that becomes the new root. If null, the new BigList is empty.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Clear">
      <summary>
            Removes all of the items from the BigList.
            </summary>
      <remarks>Clearing a BigList takes constant time.</remarks>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Insert(System.Int32,`0)">
      <summary>
            Inserts a new item at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index" /> move up one index.
            </summary>
      <remarks>The amount of time to insert an item is O(log N), no matter where
            in the list the insertion occurs. Inserting an item at the beginning or end of the 
            list is O(N). 
            </remarks>
      <param name="index">The index to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item has index 0.</param>
      <param name="item">The item to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Inserts a collection of items at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index" /> increase their indices 
            by the number of items inserted.
            </summary>
      <remarks>The amount of time to insert an arbitrary collection in the BigList is O(M + log N), 
            where M is the number of items inserted, and N is the number of items in the list.
            </remarks>
      <param name="index">The index to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            first item has index 0.</param>
      <param name="collection">The collection of items to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.InsertRange(System.Int32,Magnum.Collections.BigList{`0})">
      <summary>
            Inserts a BigList of items at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index" /> increase their indices 
            by the number of items inserted.
            </summary>
      <remarks>The amount of time to insert another BigList is O(log N), 
            where N is the number of items in the list, regardless of the number of items in the 
            inserted list. Storage is shared between the two lists until one of them is changed.
            </remarks>
      <param name="index">The index to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            first item has index 0.</param>
      <param name="list">The BigList of items to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.RemoveAt(System.Int32)">
      <summary>
            Removes the item at the given index in the BigList. All items at indexes 
            greater than <paramref name="index" /> move down one index.
            </summary>
      <remarks>The amount of time to delete an item in the BigList is O(log N),
            where N is the number of items in the list. 
            </remarks>
      <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Removes a range of items at the given index in the Deque. All items at indexes 
            greater than <paramref name="index" /> move down <paramref name="count" /> indices
            in the Deque.
            </summary>
      <remarks>The amount of time to delete <paramref name="count" /> items in the Deque is proportional
            to the distance of index from the closest end of the Deque, plus <paramref name="count" />: 
            O(count + Min(<paramref name="index" />, Count - 1 - <paramref name="index" />)).
            </remarks>
      <param name="index">The index in the list to remove the range at. The
            first item in the list has index 0.</param>
      <param name="count">The number of items to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count, or <paramref name="count" /> is less than zero
            or too large.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Add(`0)">
      <summary>
            Adds an item to the end of the BigList. The indices of all existing items
            in the Deque are unchanged. 
            </summary>
      <remarks>Adding an item takes, on average, constant time.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddToFront(`0)">
      <summary>
            Adds an item to the beginning of the BigList. The indices of all existing items
            in the Deque are increased by one, and the new item has index zero. 
            </summary>
      <remarks>Adding an item takes, on average, constant time.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the end of BigList. The indices of all existing items
            are unchanged. The last item in the added collection becomes the
            last item in the BigList.
            </summary>
      <remarks>This method takes time O(M + log N), where M is the number of items in the 
            <paramref name="collection" />, and N is the size of the BigList.</remarks>
      <param name="collection">The collection of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddRangeToFront(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the front of BigList. The indices of all existing items
            in the are increased by the number of items in <paramref name="collection" />. 
            The first item in the added collection becomes the first item in the BigList.
            </summary>
      <remarks>This method takes time O(M + log N), where M is the number of items in the 
            <paramref name="collection" />, and N is the size of the BigList.</remarks>
      <param name="collection">The collection of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Clone">
      <summary>
            Creates a new BigList that is a copy of this list.
            </summary>
      <remarks>Copying a BigList takes constant time, and little 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
      <returns>A copy of the current list</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.CloneContents">
      <summary>
            Makes a deep clone of this BigList. A new BigList is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then this method is the same as Clone.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>If T is a reference type, cloning the list takes time approximate O(N), where N is the number of items in the list.</para>
      </remarks>
      <returns>The cloned set.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddRange(Magnum.Collections.BigList{`0})">
      <summary>
            Adds a BigList of items to the end of BigList. The indices of all existing items
            are unchanged. The last item in <paramref name="list" /> becomes the
            last item in this list. The added list <paramref name="list" /> is unchanged.
            </summary>
      <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in <paramref name="list" /> are
            copied, storage is shared between the two lists until changes are made to the 
            shared sections.</remarks>
      <param name="list">The list of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddRangeToFront(Magnum.Collections.BigList{`0})">
      <summary>
            Adds a BigList of items to the front of BigList. The indices of all existing items
            are increased by the number of items in <paramref name="list" />. The first item in <paramref name="list" /> 
            becomes the first item in this list. The added list <paramref name="list" /> is unchanged.
            </summary>
      <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in <paramref name="list" /> are
            copied, storage is shared between the two lists until changes are made to the 
            shared sections.</remarks>
      <param name="list">The list of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.GetRange(System.Int32,System.Int32)">
      <summary>
            Creates a new list that contains a subrange of elements from this list. The
            current list is unchanged.
            </summary>
      <remarks>This method takes take O(log N), where N is the size of the current list. Although
            the sub-range is conceptually copied, storage is shared between the two lists until a change
            is made to the shared items.</remarks>
      <remarks>If a view of a sub-range is desired, instead of a copy, use the
            more efficient <see cref="M:Magnum.Collections.BigList`1.Range(System.Int32,System.Int32)" /> method, which provides a view onto a sub-range of items.</remarks>
      <param name="index">The starting index of the sub-range.</param>
      <param name="count">The number of items in the sub-range. If this is zero,
            the returned list is empty.</param>
      <returns>A new list with the <paramref name="count" /> items that start at <paramref name="index" />.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Range(System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
      <remarks>
        <para>If a copy of the sub-range is desired, use the <see cref="M:Magnum.Collections.BigList`1.GetRange(System.Int32,System.Int32)" /> method instead.</para>
        <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
        <code>Algorithms.ReverseInPlace(list.Range(3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
      <param name="index">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-list. </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> + <paramref name="count" /> is greater than the
            size of this list.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on. Usually, the
            foreach statement is used to call this method implicitly.
            </summary>
      <remarks>Enumerating all of the items in the list take time O(N), where
            N is the number of items in the list. Using GetEnumerator() or foreach
            is much more efficient than accessing all items by index.</remarks>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.ConvertAll``1(System.Converter{`0,``0})">
      <summary>
            Convert the list to a new list by applying a delegate to each item in the collection. The resulting list
            contains the result of applying <paramref name="converter" /> to each item in the list, in
            order. The current list is unchanged.
            </summary>
      <typeparam name="TDest">The type each item is being converted to.</typeparam>
      <param name="converter">A delegate to the method to call, passing each item in <type name="BigList&lt;T&gt;" />.</param>
      <returns>The resulting BigList from applying <paramref name="converter" /> to each item in this list.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Reverse">
      <summary>
            Reverses the current list in place.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Reverse(System.Int32,System.Int32)">
      <summary>
            Reverses the items in the range of <paramref name="count" /> items starting from <paramref name="start" />, in place.
            </summary>
      <param name="start">The starting index of the range to reverse.</param>
      <param name="count">The number of items in range to reverse.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Sort">
      <summary>
            Sorts the list in place.
            </summary>
      <remarks>
        <para>The Quicksort algorithm is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Values are compared by using the IComparable or IComparable&lt;T&gt;
            interface implementation on the type T.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The type T does not implement either the IComparable or
            IComparable&lt;T&gt; interfaces.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
            Sorts the list in place. A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
      <remarks>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</remarks>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Sort(System.Comparison{`0})">
      <summary>
            Sorts the list in place. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
      <remarks>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</remarks>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.BinarySearch(`0)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            in the order defined by the default ordering of the item type; otherwise, 
            incorrect results will be returned.
            </summary>
      <param name="item">The item to search for.</param>
      <returns>Returns the index of the first occurence of <paramref name="item" /> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item" /> in the list is returned. If no item is 
            larger than <paramref name="item" />, the bitwise complement of Count is returned.</returns>
      <exception cref="T:System.InvalidOperationException">The type T does not implement either the IComparable or
            IComparable&lt;T&gt; interfaces.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering defined by the passed IComparer&lt;T&gt; interface; otherwise, 
            incorrect results will be returned.
            </summary>
      <param name="item">The item to search for.</param>
      <param name="comparer">The IComparer&lt;T&gt; interface used to sort the list.</param>
      <returns>Returns the index of the first occurence of <paramref name="item" /> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item" /> in the list is returned. If no item is 
            larger than <paramref name="item" />, the bitwise complement of Count is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.BinarySearch(`0,System.Comparison{`0})">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering defined by the passed Comparison&lt;T&gt; delegate; otherwise, 
            incorrect results will be returned.
            </summary>
      <param name="item">The item to search for.</param>
      <param name="comparison">The comparison delegate used to sort the list.</param>
      <returns>Returns the index of the first occurence of <paramref name="item" /> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item" /> in the list is returned. If no item is 
            larger than <paramref name="item" />, the bitwise complement of Count is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Validate">
      <summary>
            Attempts to validate the internal consistency of the tree.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Print">
      <summary>
            Prints out the internal structure of the tree, for debugging purposes.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.Rebalance">
      <summary>
            Rebalance the current tree. Once rebalanced, the depth of the current tree is no more than
            two levels from fully balanced, where fully balanced is defined as having Fibonacci(N+2) or more items
            in a tree of depth N.
            </summary>
      <remarks>The rebalancing algorithm is from "Ropes: an Alternative to Strings", by 
            Boehm, Atkinson, and Plass, in SOFTWARE--PRACTICE AND EXPERIENCE, VOL. 25(12), 13151330 (DECEMBER 1995).
            </remarks>
    </member>
    <member name="M:Magnum.Collections.BigList`1.StopEnumerations">
      <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.CheckEnumerationStamp(System.Int32)">
      <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
      <param name="startStamp">changeStamp at the start of the enumeration.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.GetEnumerator(System.Int32,System.Int32)">
      <summary>
            Enumerates a range of the items in the list, in order. The item at <paramref name="start" />
            is enumerated first, then the next item at index 1, and so on. At most <paramref name="maxItems" />
            items are enumerated. 
            </summary>
      <remarks>Enumerating all of the items in the list take time O(N), where
            N is the number of items being enumerated. Using GetEnumerator() or foreach
            is much more efficient than accessing all items by index.</remarks>
      <param name="start">Index to start enumerating at.</param>
      <param name="maxItems">Max number of items to enumerate.</param>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.CheckBalance">
      <summary>
            Check the balance of the current tree and rebalance it if it is more than BALANCEFACTOR
            levels away from fully balanced. Note that rebalancing a tree may leave it two levels away from 
            fully balanced.
            </summary>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddNodeToRebalanceArray(Magnum.Collections.BigList{`0}.Node[],Magnum.Collections.BigList{`0}.Node,System.Boolean)">
      <summary>
            Part of the rebalancing algorithm. Adds a node to the rebalance array. If it is already balanced, add it directly, otherwise
            add its children.
            </summary>
      <param name="rebalanceArray">Rebalance array to insert into.</param>
      <param name="node">Node to add.</param>
      <param name="shared">If true, mark the node as shared before adding, because one
            of its parents was shared.</param>
    </member>
    <member name="M:Magnum.Collections.BigList`1.op_Addition(Magnum.Collections.BigList{`0},Magnum.Collections.BigList{`0})">
      <summary>
            Concatenates two lists together to create a new list. Both lists being concatenated
            are unchanged. The resulting list contains all the items in <paramref name="first" />, followed
            by all the items in <paramref name="second" />.
            </summary>
      <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in both lists are
            copied, storage is shared until changes are made to the 
            shared sections.</remarks>
      <param name="first">The first list to concatenate.</param>
      <param name="second">The second list to concatenate.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.NodeFromEnumerable(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Given an IEnumerable&lt;T&gt;, create a new Node with all of the 
            items in the enumerable. Returns null if the enumerable has no items.
            </summary>
      <param name="collection">The collection to copy.</param>
      <returns>Returns a Node, not shared or with any shared children, 
            with the items from the collection. If the collection was empty,
            null is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.LeafFromEnumerator(System.Collections.Generic.IEnumerator{`0})">
      <summary>
            Consumes up to MAXLEAF items from an Enumerator and places them in a leaf
            node. If the enumerator is at the end, null is returned.
            </summary>
      <param name="enumerator">The enumerator to take items from.</param>
      <returns>A LeafNode with items taken from the enumerator. </returns>
    </member>
    <member name="M:Magnum.Collections.BigList`1.NCopiesOfNode(System.Int32,Magnum.Collections.BigList{`0}.Node)">
      <summary>
            Create a node that has N copies of the given node. 
            </summary>
      <param name="copies">Number of copies. Must be non-negative.</param>
      <param name="node">Node to make copies of.</param>
      <returns>null if node is null or copies is 0. Otherwise, a node consisting of <paramref name="copies" /> copies
            of node.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">copies is negative.</exception>
    </member>
    <member name="M:Magnum.Collections.BigList`1.AddBalancedNodeToRebalanceArray(Magnum.Collections.BigList{`0}.Node[],Magnum.Collections.BigList{`0}.Node)">
      <summary>
            Part of the rebalancing algorithm. Adds a balanced node to the rebalance array. 
            </summary>
      <param name="rebalanceArray">Rebalance array to insert into.</param>
      <param name="balancedNode">Node to add.</param>
    </member>
    <member name="P:Magnum.Collections.BigList`1.Count">
      <summary>
            Gets the number of items stored in the BigList. The indices of the items
            range from 0 to Count-1.
            </summary>
      <remarks>Getting the number of items in the BigList takes constant time.</remarks>
      <value>The number of items in the BigList.</value>
    </member>
    <member name="P:Magnum.Collections.BigList`1.Item(System.Int32)">
      <summary>
            Gets or sets an item in the list, by index.
            </summary>
      <remarks>
        <para> Gettingor setting an item takes time O(log N), where N is the number of items
            in the list.</para>
        <para>To process each of the items in the list, using GetEnumerator() or a foreach loop is more efficient
            that accessing each of the elements by index.</para>
      </remarks>
      <param name="index">The index of the item to get or set. The first item in the list
            has index 0, the last item has index Count-1.</param>
      <returns>The value of the item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero or 
            greater than or equal to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.Comparers">
      <summary>
            A collection of methods to create IComparer and IEqualityComparer instances in various ways.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Comparers.KeyValueEqualityComparer`2">
      <summary>
            Class to change an IEqualityComparer&lt;TKey&gt; to an IEqualityComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; 
            Only the keys are compared.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Comparers.KeyValueComparer`2">
      <summary>
            Class to change an IComparer&lt;TKey&gt; to an IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; 
            Only the keys are compared.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Comparers.PairComparer`2">
      <summary>
            Class to change an IComparer&lt;TKey&gt; and IComparer&lt;TValue&gt; to an IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; 
            Keys are compared, followed by values.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Comparers.ComparisonComparer`1">
      <summary>
            Class to change an Comparison&lt;T&gt; to an IComparer&lt;T&gt;.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Comparers.ComparisonKeyValueComparer`2">
      <summary>
            Class to change an Comparison&lt;TKey&gt; to an IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.
            GetHashCode cannot be used on this class.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Comparers.ComparerFromComparison``1(System.Comparison{``0})">
      <summary>
            Given an Comparison on a type, returns an IComparer on that type. 
            </summary>
      <typeparam name="T">T to compare.</typeparam>
      <param name="comparison">Comparison delegate on T</param>
      <returns>IComparer that uses the comparison.</returns>
    </member>
    <member name="M:Magnum.Collections.Comparers.ComparerKeyValueFromComparerKey``2(System.Collections.Generic.IComparer{``0})">
      <summary>
            Given an IComparer on TKey, returns an IComparer on
            key-value Pairs. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyComparer">IComparer on TKey</param>
      <returns>IComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:Magnum.Collections.Comparers.EqualityComparerKeyValueFromComparerKey``2(System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Given an IEqualityComparer on TKey, returns an IEqualityComparer on
            key-value Pairs. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyEqualityComparer">IComparer on TKey</param>
      <returns>IEqualityComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:Magnum.Collections.Comparers.ComparerPairFromKeyValueComparers``2(System.Collections.Generic.IComparer{``0},System.Collections.Generic.IComparer{``1})">
      <summary>
            Given an IComparer on TKey and TValue, returns an IComparer on
            key-value Pairs of TKey and TValue, comparing first keys, then values. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyComparer">IComparer on TKey</param>
      <param name="valueComparer">IComparer on TValue</param>
      <returns>IComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:Magnum.Collections.Comparers.ComparerKeyValueFromComparisonKey``2(System.Comparison{``0})">
      <summary>
            Given an Comparison on TKey, returns an IComparer on
            key-value Pairs. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyComparison">Comparison delegate on TKey</param>
      <returns>IComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:Magnum.Collections.Comparers.DefaultComparer``1">
      <summary>
            Given an element type, check that it implements IComparable&lt;T&gt; or IComparable, then returns
            a IComparer that can be used to compare elements of that type.
            </summary>
      <returns>The IComparer&lt;T&gt; instance.</returns>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;T&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.Comparers.DefaultKeyValueComparer``2">
      <summary>
            Given an key and value type, check that TKey implements IComparable&lt;T&gt; or IComparable, then returns
            a IComparer that can be used to compare KeyValuePairs of those types.
            </summary>
      <returns>The IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; instance.</returns>
      <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;T&gt;.</exception>
    </member>
    <member name="T:Magnum.Collections.Deque`1">
      <summary>
        <para>The Deque class implements a type of list known as a Double Ended Queue. A Deque
            is quite similar to a List, in that items have indices (starting at 0), and the item at any
            index can be efficiently retrieved. The difference between a List and a Deque lies in the
            efficiency of inserting elements at the beginning. In a List, items can be efficiently added
            to the end, but inserting an item at the beginning of the List is slow, taking time 
            proportional to the size of the List. In a Deque, items can be added to the beginning 
            or end equally efficiently, regardless of the number of items in the Deque. As a trade-off
            for this increased flexibility, Deque is somewhat slower than List (but still constant time) when
            being indexed to get or retrieve elements. </para>
      </summary>
      <remarks>
        <para>The Deque class can also be used as a more flexible alternative to the Queue 
            and Stack classes. Deque is as efficient as Queue and Stack for adding or removing items, 
            but is more flexible: it allows access
            to all items in the queue, and allows adding or removing from either end.</para>
        <para>Deque is implemented as a ring buffer, which is grown as necessary. The size
            of the buffer is doubled whenever the existing capacity is too small to hold all the
            elements.</para>
      </remarks>
      <typeparam name="T">The type of items stored in the Deque.</typeparam>
    </member>
    <member name="M:Magnum.Collections.Deque`1.#ctor">
      <summary>
            Create a new Deque that is initially empty.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Create a new Deque initialized with the items from the passed collection,
            in order.
            </summary>
      <param name="collection">A collection of items to initialize the Deque with.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the items in the Deque into an array.
            </summary>
      <param name="array">Array to copy to.</param>
      <param name="arrayIndex">Starting index in <paramref name="array" /> to copy to.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.TrimToSize">
      <summary>
            Trims the amount of memory used by the Deque by changing
            the Capacity to be equal to Count. If no more items will be added
            to the Deque, calling TrimToSize will reduce the amount of memory
            used by the Deque.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Deque`1.Clear">
      <summary>
            Removes all items from the Deque.
            </summary>
      <remarks>Clearing the Deque takes a small constant amount of time, regardless of
            how many items are currently in the Deque.</remarks>
    </member>
    <member name="M:Magnum.Collections.Deque`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on. If the items
            are added to or removed from the Deque during enumeration, the 
            enumeration ends with an InvalidOperationException.
            </summary>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.Insert(System.Int32,`0)">
      <summary>
            Inserts a new item at the given index in the Deque. All items at indexes 
            equal to or greater than <paramref name="index" /> move up one index
            in the Deque.
            </summary>
      <remarks>The amount of time to insert an item in the Deque is proportional
            to the distance of index from the closest end of the Deque: 
            O(Min(<paramref name="index" />, Count - <paramref name="index" />)).
            Thus, inserting an item at the front or end of the Deque is always fast; the middle of
            of the Deque is the slowest place to insert.
            </remarks>
      <param name="index">The index in the Deque to insert the item at. After the
            insertion, the inserted item is located at this index. The
            front item in the Deque has index 0.</param>
      <param name="item">The item to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Inserts a collection of items at the given index in the Deque. All items at indexes 
            equal to or greater than <paramref name="index" /> increase their indices in the Deque
            by the number of items inserted.
            </summary>
      <remarks>The amount of time to insert a collection in the Deque is proportional
            to the distance of index from the closest end of the Deque, plus the number of items
            inserted (M): 
            O(M + Min(<paramref name="index" />, Count - <paramref name="index" />)).
            </remarks>
      <param name="index">The index in the Deque to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            front item in the Deque has index 0.</param>
      <param name="collection">The collection of items to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.RemoveAt(System.Int32)">
      <summary>
            Removes the item at the given index in the Deque. All items at indexes 
            greater than <paramref name="index" /> move down one index
            in the Deque.
            </summary>
      <remarks>The amount of time to delete an item in the Deque is proportional
            to the distance of index from the closest end of the Deque: 
            O(Min(<paramref name="index" />, Count - 1 - <paramref name="index" />)).
            Thus, deleting an item at the front or end of the Deque is always fast; the middle of
            of the Deque is the slowest place to delete.
            </remarks>
      <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Removes a range of items at the given index in the Deque. All items at indexes 
            greater than <paramref name="index" /> move down <paramref name="count" /> indices
            in the Deque.
            </summary>
      <remarks>The amount of time to delete <paramref name="count" /> items in the Deque is proportional
            to the distance to the closest end of the Deque: 
            O(Min(<paramref name="index" />, Count - <paramref name="index" /> - <paramref name="count" />)).
            </remarks>
      <param name="index">The index in the list to remove the range at. The
            first item in the list has index 0.</param>
      <param name="count">The number of items to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count, or <paramref name="count" /> is less than zero
            or too large.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.AddToFront(`0)">
      <summary>
            Adds an item to the front of the Deque. The indices of all existing items
            in the Deque are increased by 1. This method is 
            equivalent to <c>Insert(0, item)</c> but is a little more
            efficient.
            </summary>
      <remarks>Adding an item to the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.AddManyToFront(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the front of the Deque. The indices of all existing items
            in the Deque are increased by the number of items inserted. The first item in the added collection becomes the
            first item in the Deque. 
            </summary>
      <remarks>This method takes time O(M), where M is the number of items in the 
            <paramref name="collection" />.</remarks>
      <param name="collection">The collection of items to add.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.AddToBack(`0)">
      <summary>
            Adds an item to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>Insert(Count, item)</c> but is a little more
            efficient.
            </summary>
      <remarks>Adding an item to the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.Add(`0)">
      <summary>
            Adds an item to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>AddToBack(item)</c>.
            </summary>
      <remarks>Adding an item to the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.AddManyToBack(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. The last item in the added collection becomes the
            last item in the Deque.
            </summary>
      <remarks>This method takes time O(M), where M is the number of items in the 
            <paramref name="collection" />.</remarks>
      <param name="collection">The collection of item to add.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.RemoveFromFront">
      <summary>
            Removes an item from the front of the Deque. The indices of all existing items
            in the Deque are decreased by 1. This method is 
            equivalent to <c>RemoveAt(0)</c> but is a little more
            efficient.
            </summary>
      <remarks>Removing an item from the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <returns>The item that was removed.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.RemoveFromBack">
      <summary>
            Removes an item from the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>RemoveAt(Count-1)</c> but is a little more
            efficient.
            </summary>
      <remarks>Removing an item from the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.GetAtFront">
      <summary>
            Retreives the item currently at the front of the Deque. The Deque is 
            unchanged. This method is 
            equivalent to <c>deque[0]</c> (except that a different exception is thrown).
            </summary>
      <remarks>Retreiving the item at the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <returns>The item at the front of the Deque.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.GetAtBack">
      <summary>
            Retreives the item currently at the back of the Deque. The Deque is 
            unchanged. This method is 
            equivalent to <c>deque[deque.Count - 1]</c> (except that a different exception is thrown).
            </summary>
      <remarks>Retreiving the item at the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <returns>The item at the back of the Deque.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.Clone">
      <summary>
            Creates a new Deque that is a copy of this one.
            </summary>
      <remarks>Copying a Deque takes O(N) time, where N is the number of items in this Deque..</remarks>
      <returns>A copy of the current deque.</returns>
    </member>
    <member name="M:Magnum.Collections.Deque`1.CloneContents">
      <summary>
            Makes a deep clone of this Deque. A new Deque is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the Deque takes time O(N), where N is the number of items in the Deque.</para>
      </remarks>
      <returns>The cloned Deque.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.Deque`1.Print">
      <summary>
            Print out the internal state of the Deque for debugging.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Deque`1.StopEnumerations">
      <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Deque`1.CheckEnumerationStamp(System.Int32)">
      <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
      <param name="startStamp">changeStamp at the start of the enumeration.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.CreateInitialBuffer(`0)">
      <summary>
            Creates the initial buffer and initialized the Deque to contain one initial
            item.
            </summary>
      <param name="firstItem">First and only item for the Deque.</param>
    </member>
    <member name="M:Magnum.Collections.Deque`1.IncreaseBuffer">
      <summary>
            Increase the amount of buffer space. When calling this method, the Deque
            must not be empty. If start and end are equal, that indicates a completely
            full Deque.
            </summary>
    </member>
    <member name="P:Magnum.Collections.Deque`1.Count">
      <summary>
            Gets the number of items currently stored in the Deque. The last item
            in the Deque has index Count-1.
            </summary>
      <remarks>Getting the count of items in the Deque takes a small constant
            amount of time.</remarks>
      <value>The number of items stored in this Deque.</value>
    </member>
    <member name="P:Magnum.Collections.Deque`1.Capacity">
      <summary>
            Gets or sets the capacity of the Deque. The Capacity is the number of
            items that this Deque can hold without expanding its internal buffer. Since
            Deque will automatically expand its buffer when necessary, in almost all cases
            it is unnecessary to worry about the capacity. However, if it is known that a
            Deque will contain exactly 1000 items eventually, it can slightly improve 
            efficiency to set the capacity to 1000 up front, so that the Deque does not
            have to expand automatically.
            </summary>
      <value>The number of items that this Deque can hold without expanding its
            internal buffer.</value>
      <exception cref="T:System.ArgumentOutOfRangeException">The capacity is being set
            to less than Count, or to too large a value.</exception>
    </member>
    <member name="P:Magnum.Collections.Deque`1.Item(System.Int32)">
      <summary>
            Gets or sets an item at a particular index in the Deque. 
            </summary>
      <remarks>Getting or setting the item at a particular index takes a small constant amount
            of time, no matter what index is used.</remarks>
      <param name="index">The index of the item to retrieve or change. The front item has index 0, and
            the back item has index Count-1.</param>
      <returns>The value at the indicated index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The index is less than zero or greater than or equal
            to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.DictionaryBase`2">
      <summary>
            DictionaryBase is a base class that can be used to more easily implement the
            generic IDictionary&lt;T&gt; and non-generic IDictionary interfaces.
            </summary>
      <remarks>
        <para>To use DictionaryBase as a base class, the derived class must override
            Count, GetEnumerator, TryGetValue, Clear, Remove, and the indexer set accessor. </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="T:Magnum.Collections.DictionaryBase`2.DictionaryEnumeratorWrapper">
      <summary>
            A class that wraps a IDictionaryEnumerator around an IEnumerator that
            enumerates KeyValuePairs. This is useful in implementing IDictionary, because
            IEnumerator can be implemented with an iterator, but IDictionaryEnumerator cannot.
            </summary>
    </member>
    <member name="T:Magnum.Collections.DictionaryBase`2.KeysCollection">
      <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.DictionaryBase`2.ValuesCollection">
      <summary>
            A private class that implements ICollection&lt;TValue&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Clear">
      <summary>
            Clears the dictionary. This method must be overridden in the derived class.
            </summary>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Remove(`0)">
      <summary>
            Removes a key from the dictionary. This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <returns>True if the key was found, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.TryGetValue(`0,`1@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, the value
            associated with that key is returned through the value parameter. This method must be
            overridden by the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">Returns the value associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Add(`0,`1)">
      <summary>
            Adds a new key-value pair to the dictionary. 
            </summary>
      <remarks>The default implementation of this method
            checks to see if the key already exists using 
            ContainsKey, then calls the indexer setter if the key doesn't
            already exist. </remarks>
      <param name="key">Key to add.</param>
      <param name="value">Value to associated with the key.</param>
      <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found
            in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryGetValue and returns
            what it returns.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.AsReadOnly">
      <summary>
            Provides a read-only view of this dictionary. The returned IDictionary&lt;TKey,TValue&gt; provides
            a view of the dictionary that prevents modifications to the dictionary. Use the method to provide
            access to the dictionary without allowing changes. Since the returned object is just a view,
            changes to the dictionary will be reflected in the view.
            </summary>
      <returns>An IIDictionary&lt;TKey,TValue&gt; that provides read-only access to the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Adds a key-value pair to the collection. This implementation calls the Add method
            with the Key and Value from the item.
            </summary>
      <param name="item">A KeyValuePair contains the Key and Value to add.</param>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Determines if a dictionary contains a given KeyValuePair. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value.
            </summary>
      <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Determines if a dictionary contains a given KeyValuePair, and if so, removes it. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value. If so, the key-value pair is removed.
            </summary>
      <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
      <returns>True if the item was found and removed. False otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.DictionaryBase`2.CheckGenericType``1(System.String,System.Object)">
      <summary>
            Check that the given parameter is of the expected generic type. Throw an ArgumentException
            if it isn't.
            </summary>
      <typeparam name="ExpectedType">Expected type of the parameter</typeparam>
      <param name="name">parameter name</param>
      <param name="value">parameter value</param>
    </member>
    <member name="P:Magnum.Collections.DictionaryBase`2.Item(`0)">
      <summary>
            The indexer of the dictionary. This is used to store keys and values and
            retrieve values from the dictionary. The setter
            accessor must be overridden in the derived class.
            </summary>
      <param name="key">Key to find in the dictionary.</param>
      <returns>The value associated with the key.</returns>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown from the get accessor if the key
            was not found in the dictionary.</exception>
    </member>
    <member name="P:Magnum.Collections.DictionaryBase`2.Keys">
      <summary>
            Returns a collection of the keys in this dictionary. 
            </summary>
      <value>A read-only collection of the keys in this dictionary.</value>
    </member>
    <member name="P:Magnum.Collections.DictionaryBase`2.Values">
      <summary>
            Returns a collection of the values in this dictionary. The ordering of 
            values in this collection is the same as that in the Keys collection.
            </summary>
      <value>A read-only collection of the values in this dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyCollectionBase`1">
      <summary>
            ReadOnlyCollectionBase is a base class that can be used to more easily implement the
            generic ICollection&lt;T&gt; and non-generic ICollection interfaces for a read-only collection:
            a collection that does not allow adding or removing elements.
            </summary>
      <remarks>
        <para>To use ReadOnlyCollectionBase as a base class, the derived class must override
            the Count and GetEnumerator methods. </para>
        <para>ICollection&lt;T&gt;.Contains need not be implemented by the
            derived class, but it should be strongly considered, because the ReadOnlyCollectionBase implementation
            may not be very efficient.</para>
      </remarks>
      <typeparam name="T">The item type of the collection.</typeparam>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.DebuggerDisplayString">
      <summary>
            Display the contents of the collection in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.ToString">
      <summary>
            Shows the string representation of the collection. The string representation contains
            a list of the items in the collection.
            </summary>
      <returns>The string representation of the collection.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.Exists(System.Predicate{`0})">
      <summary>
            Determines if the collection contains any item that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate" />. False if the collection does not contain
            an item that satisfies <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.TrueForAll(System.Predicate{`0})">
      <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.CountWhere(System.Predicate{`0})">
      <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>The number of items in the collection that satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.FindAll(System.Predicate{`0})">
      <summary>
            Enumerates the items in the collection that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.ForEach(System.Action{`0})">
      <summary>
            Performs the specified action on each item in this collection.
            </summary>
      <param name="action">An Action delegate which is invoked for each item in this collection.</param>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.ConvertAll``1(System.Converter{`0,``0})">
      <summary>
            Convert this collection of items by applying a delegate to each item in the collection. The resulting enumeration
            contains the result of applying <paramref name="converter" /> to each item in this collection, in
            order.
            </summary>
      <typeparam name="TOutput">The type each item is being converted to.</typeparam>
      <param name="converter">A delegate to the method to call, passing each item in this collection.</param>
      <returns>An IEnumerable&lt;TOutput^gt; that enumerates the resulting collection from applying <paramref name="converter" /> to each item in this collection in
            order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.Contains(`0)">
      <summary>
            Determines if the collection contains a particular item. This default implementation
            iterates all of the items in the collection via GetEnumerator, testing each item
            against <paramref name="item" /> using IComparable&lt;T&gt;.Equals or
            Object.Equals.
            </summary>
      <remarks>You should strongly consider overriding this method to provide
            a more efficient implementation.</remarks>
      <param name="item">The item to check for in the collection.</param>
      <returns>True if the collection contains <paramref name="item" />, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
      <param name="array">Array to copy to.</param>
      <param name="arrayIndex">Starting index in <paramref name="array" /> to copy to.</param>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.ToArray">
      <summary>
            Creates an array of the correct size, and copies all the items in the 
            collection into the array, by calling CopyTo.
            </summary>
      <returns>An array containing all the elements in the collection, in order.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyCollectionBase`1.GetEnumerator">
      <summary>
            Must be overridden to enumerate all the members of the collection.
            </summary>
      <returns>A generic IEnumerator&lt;T&gt; that can be used
            to enumerate all the items in the collection.</returns>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyCollectionBase`1.Count">
      <summary>
            Must be overridden to provide the number of items in the collection.
            </summary>
      <value>The number of items in the collection.</value>
    </member>
    <member name="T:Magnum.Collections.Hash`1">
      <summary>
             The base implementation for various collections classes that use hash tables
             as part of their implementation. This class should not (and can not) be 
             used directly by end users; it's only for internal use by the collections package. The Hash
             does not handle duplicate values.
             </summary>
      <remarks>
             The Hash manages items of type T, and uses a IComparer&lt;ItemTYpe&gt; that
             hashes compares items to hash items into the table.  
            </remarks>
    </member>
    <member name="T:Magnum.Collections.Hash`1.Slot">
      <summary>
            The structure that has each slot in the hash table. Each slot has three parts:
            1. The collision bit. Indicates whether some item visited this slot but had to
            keep looking because the slot was full. 
            2. 31-bit full hash value of the item. If zero, the slot is empty.
            3. The item itself.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Slot.Clear">
      <summary>
            Clear this slot, leaving the collision bit alone.
            </summary>
    </member>
    <member name="P:Magnum.Collections.Hash`1.Slot.HashValue">
      <summary>
            The full hash value associated with the value in this slot, or zero
            if the slot is empty.
            </summary>
    </member>
    <member name="P:Magnum.Collections.Hash`1.Slot.Empty">
      <summary>
            Is this slot empty?
            </summary>
    </member>
    <member name="P:Magnum.Collections.Hash`1.Slot.Collision">
      <summary>
            The "Collision" bit indicates that some value hit this slot and
            collided, so had to try another slot.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Constructor. Create a new hash table.
            </summary>
      <param name="equalityComparer">The comparer to use to compare items. </param>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetEnumerator">
      <summary>
            Enumerate all of the items in the hash table. The items
            are enumerated in a haphazard, unpredictable order.
            </summary>
      <returns>An IEnumerator&lt;T&gt; that enumerates the items
            in the hash table.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Insert(`0,System.Boolean,`0@)">
      <summary>
            Insert a new item into the hash table. If a duplicate item exists, can replace or
            do nothing.
            </summary>
      <param name="item">The item to insert.</param>
      <param name="replaceOnDuplicate">If true, duplicate items are replaced. If false, nothing
            is done if a duplicate already exists.</param>
      <param name="previous">If a duplicate was found, returns it (whether replaced or not).</param>
      <returns>True if no duplicate existed, false if a duplicate was found.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Delete(`0,`0@)">
      <summary>
            Deletes an item from the hash table. 
            </summary>
      <param name="item">Item to search for and delete.</param>
      <param name="itemDeleted">If true returned, the actual item stored in the hash table (must be 
            equal to <paramref name="item" />, but may not be identical.</param>
      <returns>True if item was found and deleted, false if item wasn't found.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Find(`0,System.Boolean,`0@)">
      <summary>
            Find an item in the hash table. If found, optionally replace it with the
            finding item.
            </summary>
      <param name="find">Item to find.</param>
      <param name="replace">If true, replaces the equal item in the hash table
            with <paramref name="item" />.</param>
      <param name="item">Returns the equal item found in the table, if true was returned.</param>
      <returns>True if the item was found, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Clone(System.Converter{`0,`0})">
      <summary>
            Creates a clone of this hash table.
            </summary>
      <param name="cloneItem">If non-null, this function is applied to each item when cloning. It must be the 
            case that this function does not modify the hash code or equality function.</param>
      <returns>A shallow clone that contains the same items.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetEnumerationStamp">
      <summary>
            Gets the current enumeration stamp. Call CheckEnumerationStamp later
            with this value to throw an exception if the hash table is changed.
            </summary>
      <returns>The current enumeration stamp.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.StopEnumerations">
      <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.CheckEnumerationStamp(System.Int32)">
      <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
      <param name="startStamp">changeStamp at the start of the enumeration.</param>
    </member>
    <member name="M:Magnum.Collections.Hash`1.PrintStats">
      <summary>
            Print out basic stats about the hash table.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Print">
      <summary>
            Print out the state of the hash table and each of the slots. Each slot looks like:
                Slot    4: C 4513e41e hello
            where the "C" indicates the collision bit is on
            the next hex number is the hash value
            followed by ToString() on the item.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.Validate">
      <summary>
            Check that everything appears to be OK in the hash table.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetFullHash(`0)">
      <summary>
            Gets the full hash code for an item.
            </summary>
      <param name="item">Item to get hash code for.</param>
      <returns>The full hash code. It is never zero.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetHashValuesFromFullHash(System.Int32,System.Int32@,System.Int32@)">
      <summary>
            Get the initial bucket number and skip amount from the full hash value.
            </summary>
      <param name="hash">The full hash value.</param>
      <param name="initialBucket">Returns the initial bucket. Always in the range 0..(totalSlots - 1).</param>
      <param name="skip">Returns the skip values. Always odd in the range 0..(totalSlots - 1).</param>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetHashValues(`0,System.Int32@,System.Int32@)">
      <summary>
            Gets the full hash value, initial bucket number, and skip amount for an item.
            </summary>
      <param name="item">Item to get hash value of.</param>
      <param name="initialBucket">Returns the initial bucket. Always in the range 0..(totalSlots - 1).</param>
      <param name="skip">Returns the skip values. Always odd in the range 0..(totalSlots - 1).</param>
      <returns>The full hash value. This is never zero.</returns>
    </member>
    <member name="M:Magnum.Collections.Hash`1.EnsureEnoughSlots(System.Int32)">
      <summary>
            Make sure there are enough slots in the hash table that <paramref name="additionalItems" />
            items can be inserted into the table.
            </summary>
      <param name="additionalItems">Number of additional items we are inserting.</param>
    </member>
    <member name="M:Magnum.Collections.Hash`1.ShrinkIfNeeded">
      <summary>
            Check if the number of items in the table is small enough that
            we should shrink the table again.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.ResizeTable(System.Int32)">
      <summary>
            Resize the hash table to the given new size, moving all items into the
            new hash table.
            </summary>
      <param name="newSize">The new size of the hash table. Must be a power
            of two.</param>
    </member>
    <member name="M:Magnum.Collections.Hash`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Called on deserialization. We cannot deserialize now, because hash codes
            might not be correct now. We do real deserialization in the OnDeserialization call.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Hash`1.GetSecondaryShift(System.Int32)">
      <summary>
            Given the size of a hash table, compute the "secondary shift" value -- the shift
            that is used to determine the skip amount for collision resolution.
            </summary>
      <param name="newSize">The new size of the table.</param>
      <returns>The secondary skip amount.</returns>
    </member>
    <member name="P:Magnum.Collections.Hash`1.ElementCount">
      <summary>
            Get the number of items in the hash table.
            </summary>
      <value>The number of items stored in the hash table.</value>
    </member>
    <member name="P:Magnum.Collections.Hash`1.LoadFactor">
      <summary>
            Get or change the load factor. Changing the load factor may cause
            the size of the table to grow or shrink accordingly.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Magnum.Collections.Hash`1.SlotCount">
      <summary>
            Get the number of slots in the hash table. Exposed internally
            for testing purposes.
            </summary>
      <value>The number of slots in the hash table.</value>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2">
      <summary>
            MultiDictionaryBase is a base class that can be used to more easily implement a class
            that associates multiple values to a single key. The class implements the generic
            IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt; interface.
            </summary>
      <remarks>
        <para>To use MultiDictionaryBase as a base class, the derived class must override
            Count, Clear, Add, Remove(TKey), Remove(TKey,TValue), Contains(TKey,TValue), 
            EnumerateKeys, and TryEnumerateValuesForKey. </para>
        <para>It may wish consider overriding CountValues, CountAllValues, ContainsKey,
            and EqualValues, but these are not required.
            </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2.ValuesForKeyCollection">
      <summary>
            A private class that provides the ICollection&lt;TValue&gt; for a particular key. This is the collection
            that is returned from the indexer. The collections is read-write, live, and can be used to add, remove,
            etc. values from the multi-dictionary.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.Clear">
      <summary>
            Remove the key and all values associated with it.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.GetEnumerator">
      <summary>
            Enumerate all the values associated with key.
            </summary>
      <returns>An IEnumerator&lt;TValue&gt; that enumerates all the values associated with key.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.NoValues">
      <summary>
            A simple function that returns an IEnumerator&lt;TValue&gt; that
            doesn't yield any values. A helper.
            </summary>
      <returns>An IEnumerator&lt;TValue&gt; that yields no values.</returns>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.ValuesForKeyCollection.Count">
      <summary>
            Get the number of values associated with the key.
            </summary>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2.KeysCollection">
      <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2.ValuesCollection">
      <summary>
            A private class that implements ICollection&lt;TValue&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2.EnumerableValuesCollection">
      <summary>
            A private class that implements ICollection&lt;ICollection&lt;TValue&gt;&gt; and ICollection for the
            Values collection on IDictionary. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.MultiDictionaryBase`2.KeyValuePairsCollection">
      <summary>
            A private class that implements ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; and ICollection for the
            KeyValuePairs collection. The collection is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Clear">
      <summary>
            Clears the dictionary. This method must be overridden in the derived class.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Adds a key-value pair to the collection. The value part of the pair must be a collection
            of values to associate with the key. If values are already associated with the given
            key, the new values are added to the ones associated with that key.
            </summary>
      <param name="item">A KeyValuePair contains the Key and Value collection to add.</param>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Remove(`0)">
      <summary>
            Removes a key from the dictionary. This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <returns>True if the key was found, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Removes a set of values from a given key. If all values associated with a key are
            removed, then the key is removed also.
            </summary>
      <param name="pair">A KeyValuePair contains a key and a set of values to remove from that key.</param>
      <returns>True if at least one values was found and removed.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryEnumerateValuesForKey.
            It may be appropriate to override this method to 
            provide a more efficient implementation.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Determines if this dictionary contains the given key and all of the values associated with that key..
            </summary>
      <param name="pair">A key and collection of values to search for.</param>
      <returns>True if the dictionary has associated all of the values in <paramref name="pair" />.Value with <paramref name="pair" />.Key.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.GetEnumerator">
      <summary>
            Enumerate all the keys in the dictionary, and for each key, the collection of values for that key.
            </summary>
      <returns>An enumerator to enumerate all the key, ICollection&lt;value&gt; pairs in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.AddMany(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
        <para>Adds new values to be associated with a key. If duplicate values are permitted, this
            method always adds new key-value pairs to the dictionary.</para>
        <para>If duplicate values are not permitted, and <paramref name="key" /> already has a value
            equal to one of <paramref name="values" /> associated with it, then that value is replaced,
            and the number of values associate with <paramref name="key" /> is unchanged.</para>
      </summary>
      <param name="key">The key to associate with.</param>
      <param name="values">A collection of values to associate with <paramref name="key" />.</param>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Add(`0,`1)">
      <summary>
            Adds a new key-value pair to the dictionary.  This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to add.</param>
      <param name="value">Value to associated with the key.</param>
      <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Remove(`0,`1)">
      <summary>
            Removes a key-value pair from the dictionary. This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <param name="value">Associated value to remove from the dictionary.</param>
      <returns>True if the key-value pair was found, false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.RemoveMany(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Removes a collection of values from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
      <param name="key">A key to remove values from.</param>
      <param name="values">A collection of values to remove.</param>
      <returns>The number of values that were present and removed. </returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all of the keys (and any associated values) in a collection
            of keys. If a key is not present in the dictionary, nothing happens.
            </summary>
      <param name="keyCollection">A collection of key values to remove.</param>
      <returns>The number of keys from the collection that were present and removed.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Contains(`0,`1)">
      <summary>
            Determines if this dictionary contains a key-value pair equal to <paramref name="key" /> and 
            <paramref name="value" />. The dictionary is not changed. This method must be overridden in the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">The value to search for.</param>
      <returns>True if the dictionary has associated <paramref name="value" /> with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.Replace(`0,`1)">
      <summary>
            Replaces all values associated with <paramref name="key" /> with the single value <paramref name="value" />.
            </summary>
      <remarks>This implementation simply calls Remove, followed by Add.</remarks>
      <param name="key">The key to associate with.</param>
      <param name="value">The new values to be associated with <paramref name="key" />.</param>
      <returns>Returns true if some values were removed. Returns false if <paramref name="key" /> was not
            present in the dictionary before Replace was called.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ReplaceMany(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Replaces all values associated with <paramref name="key" /> with a new collection
            of values. If the collection does not permit duplicate values, and <paramref name="values" /> has duplicate
            items, then only the last of duplicates is added.
            </summary>
      <param name="key">The key to associate with.</param>
      <param name="values">The new values to be associated with <paramref name="key" />.</param>
      <returns>Returns true if some values were removed. Returns false if <paramref name="key" /> was not
            present in the dictionary before Replace was called.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. This method must be overridden by a derived
            class.
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Enumerate all of the values associated with a given key. This method must be overridden
            by the derived class. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values" />. If the key does not exist, false is returned.
            </summary>
      <param name="key">The key to get values for.</param>
      <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
      <returns>True if the key exists and has values associated with it. False otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.EqualValues(`1,`1)">
      <summary>
            If the derived class does not use the default comparison for values, this
            methods should be overridden to compare two values for equality. This is
            used for the correct implementation of ICollection.Contains on the Values
            and KeyValuePairs collections.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.CountValues(`0)">
      <summary>
            Gets a count of the number of values associated with a key. The
            default implementation is slow; it enumerators all of the values
            (using TryEnumerateValuesForKey) to count them. A derived class
            may be able to supply a more efficient implementation.
            </summary>
      <param name="key">The key to count values for.</param>
      <returns>The number of values associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.CountAllValues">
      <summary>
            Gets a total count of values in the collection. This default implementation
            is slow; it enumerates all of the keys in the dictionary and calls CountValues on each.
            A derived class may be able to supply a more efficient implementation.
            </summary>
      <returns>The total number of values associated with all keys in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.Values">
      <summary>
            Gets a read-only collection of all the values in the dictionary. 
            </summary>
      <returns>A read-only ICollection&lt;TValue&gt; of all the values in the dictionary.</returns>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.KeyValuePairs">
      <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.Item(`0)">
      <summary>
            Returns a collection of all of the values in the dictionary associated with <paramref name="key" />,
            or changes the set of values associated with <paramref name="key" />.
            If the key is not present in the dictionary, an ICollection enumerating no
            values is returned. The returned collection of values is read-write, and can be used to 
            modify the collection of values associated with the key.
            </summary>
      <param name="key">The key to get the values associated with.</param>
      <value>An ICollection&lt;TValue&gt; with all the values associated with <paramref name="key" />.</value>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.Count">
      <summary>
            Gets the number of keys in the dictionary. This property must be overridden
            in the derived class.
            </summary>
    </member>
    <member name="P:Magnum.Collections.MultiDictionaryBase`2.Keys">
      <summary>
            Gets a read-only collection all the keys in this dictionary.
            </summary>
      <value>An readonly ICollection&lt;TKey&gt; of all the keys in this dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.MultiDictionary`2">
      <summary>
        <para>The MultiDictionary class that associates values with a key. Unlike an Dictionary,
             each key can have multiple values associated with it. When indexing an MultiDictionary, instead
             of a single value associated with a key, you retrieve an enumeration of values.</para>
        <para>When constructed, you can chose to allow the same value to be associated with a key multiple
             times, or only one time. </para>
      </summary>
      <typeparam name="TKey">The type of the keys.</typeparam>
      <typeparam name="TValue">The of values associated with the keys.</typeparam>
      <seealso cref="T:System.Collections.Generic.Dictionary`2" />
      <seealso cref="T:Magnum.Collections.OrderedMultiDictionary`2" />
    </member>
    <member name="T:Magnum.Collections.MultiDictionary`2.KeyAndValuesEqualityComparer">
      <summary>
            This class implements IEqualityComparer for KeysAndValues, allowing them to be
            compared by their keys. An IEqualityComparer on keys is required.
            </summary>
    </member>
    <member name="T:Magnum.Collections.MultiDictionary`2.KeyAndValues">
      <summary>
            A structure to hold the key and the values associated with the key.
            The number of values must always be 1 or greater in a version that is stored, but 
            can be zero in a dummy version used only for lookups.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.#ctor(System.Boolean)">
      <summary>
            Create a new MultiDictionary. The default ordering of keys and values are used. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <remarks>The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented). If a different ordering should be
            used, other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.</remarks>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <exception cref="T:System.InvalidOperationException">TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a new MultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyEqualityComparer">An IEqualityComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Create a new MultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyEqualityComparer">An IEqualityComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <param name="valueEqualityComparer">An IEqualityComparer&lt;TValue&gt; instance that will be used to compare values.</param>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1},System.Collections.Generic.IEqualityComparer{Magnum.Collections.MultiDictionary{`0,`1}.KeyAndValues},Magnum.Collections.Hash{Magnum.Collections.MultiDictionary{`0,`1}.KeyAndValues})">
      <summary>
            Create a new MultiDictionary. Private constructor, for use by Clone().
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Add(`0,`1)">
      <summary>
        <para>Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.</para>
        <para>If duplicate values are not permitted, and <paramref name="key" /> already has a value
            equal to <paramref name="value" /> associated with it, then that value is replaced with <paramref name="value" />,
            and the number of values associate with <paramref name="key" /> is unchanged.</para>
      </summary>
      <param name="key">The key to associate with.</param>
      <param name="value">The value to associated with <paramref name="key" />.</param>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Remove(`0,`1)">
      <summary>
            Removes a given value from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
      <param name="key">A key to remove a value from.</param>
      <param name="value">The value to remove.</param>
      <returns>True if <paramref name="value" /> was associated with <paramref name="key" /> (and was
            therefore removed). False if <paramref name="value" /> was not associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Remove(`0)">
      <summary>
            Removes a key and all associated values from the dictionary. If the
            key is not present in the dictionary, it is unchanged and false is returned.
            </summary>
      <param name="key">The key to remove.</param>
      <returns>True if the key was present and was removed. Returns 
            false if the key was not present.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Clear">
      <summary>
            Removes all keys and values from the dictionary.
            </summary>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Contains(`0,`1)">
      <summary>
            Checks to see if <paramref name="value" /> is associated with <paramref name="key" />
            in the dictionary.
            </summary>
      <param name="key">The key to check.</param>
      <param name="value">The value to check.</param>
      <returns>True if <paramref name="value" /> is associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.ContainsKey(`0)">
      <summary>
            Checks to see if the key is present in the dictionary and has
            at least one value associated with it.
            </summary>
      <param name="key">The key to check.</param>
      <returns>True if <paramref name="key" /> is present and has at least
            one value associated with it. Returns false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.EqualValues(`1,`1)">
      <summary>
            Determine if two values are equal.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the dictionary that
            have at least one value associated with them.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, all the values
            associated with that key are returned through the values parameter. 
            </summary>
      <param name="key">The key to search for.</param>
      <param name="values">Returns all values associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.CountValues(`0)">
      <summary>
            Gets the number of values associated with a given key.
            </summary>
      <param name="key">The key to count values of.</param>
      <returns>The number of values associated with <paramref name="key" />. If <paramref name="key" />
            is not present in the dictionary, zero is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.EnumerateValues(Magnum.Collections.MultiDictionary{`0,`1}.KeyAndValues)">
      <summary>
             Enumerate the values in the a KeyAndValues structure. Can't return
            the array directly because:
              a) The array might be larger than the count.
              b) We can't allow clients to down-cast to the array and modify it.
              c) We have to abort enumeration if the hash changes.
            </summary>
      <param name="keyAndValues">Item with the values to enumerate..</param>
      <returns>An enumerable that enumerates the items in the KeyAndValues structure.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.Clone">
      <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.</remarks>
      <returns>The cloned dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.CloneContents">
      <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para>
      </remarks>
      <returns>The cloned dictionary.</returns>
      <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.MultiDictionary`2.NonCloneableType(System.Type)">
      <summary>
            Throw an InvalidOperationException indicating that this type is not cloneable.
            </summary>
      <param name="t">Type to test.</param>
    </member>
    <member name="P:Magnum.Collections.MultiDictionary`2.KeyComparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for TKey (EqualityComparer&lt;TKey&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.MultiDictionary`2.ValueComparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for TValue (EqualityComparer&lt;TValue&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.MultiDictionary`2.Count">
      <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted. If duplicate values are permitted, each duplicate
            value is included in the count.
            </summary>
      <value>The number of key-value pairs in the dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.ObjectToDictionaryConverter">
      <summary>
            Converts an object of an anonymous type to a dictionary
            </summary>
    </member>
    <member name="T:Magnum.Collections.OrderedBag`1">
      <summary>
             OrderedBag&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a sorted order. Unlike a OrderedSet, duplicate items (items that
             compare equal to each other) are allows in an OrderedBag.
             </summary>
      <remarks>
        <p>The items are compared in one of three ways. If T implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare items. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
        <p>OrderedBag is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) + M time, where N is the number of keys in the tree, and M is the current number
             of copies of the element being handled.</p>
        <p>
          <see cref="T:Magnum.Collections.Bag`1" /> is similar, but uses hashing instead of comparison, and does not maintain
             the keys in sorted order.</p>
      </remarks>
      <seealso cref="T:Magnum.Collections.Bag`1" />
    </member>
    <member name="T:Magnum.Collections.OrderedBag`1.ListView">
      <summary>
            The nested class that provides a read-only list view
            of all or part of the collection.
            </summary>
    </member>
    <member name="T:Magnum.Collections.OrderedBag`1.View">
      <summary>
             The OrderedBag&lt;T&gt;.View class is used to look at a subset of the items
             inside an ordered bag. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying bag changes, the view changes in sync. If a change is made
             to the view, the underlying bag changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the items 
             in a subset of the OrderedBag. For example:</p>
        <code>
             foreach(T item in bag.Range(from, to)) {
                // process item
             }
            </code>
      </remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.GetEnumerator">
      <summary>
            Enumerate all the items in this view.
            </summary>
      <returns>An IEnumerator&lt;T&gt; with the items in this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.Clear">
      <summary>
            Removes all the items within this view from the underlying bag.
            </summary>
      <example>The following removes all the items that start with "A" from an OrderedBag.
            <code>
            bag.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.AsList">
      <summary>
            Get a read-only list view of the items in this view. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.Reversed">
      <summary>
            Creates a new View that has the same items as this view, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view, with the same upper 
            and lower bounds.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.GetFirst">
      <summary>
            Returns the first item in this view: the item
            that would appear first if the view was enumerated. 
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The first item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.View.GetLast">
      <summary>
            Returns the last item in the view: the item
            that would appear last if the view was enumerated. 
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The last item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="P:Magnum.Collections.OrderedBag`1.View.Count">
      <summary>
            Number of items in this view.
            </summary>
      <value>Number of items that lie within the bounds the view.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedBag`1.View.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor">
      <summary>
             Creates a new OrderedBag. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this bag.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Comparison{`0})">
      <summary>
            Creates a new OrderedBag. The passed delegate will be used to compare items in this bag.
            </summary>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedBag. The Compare method of the passed comparison object
            will be used to compare items in this bag.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new OrderedBag. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this bag. The bag is
             initialized with all the items in the given collection.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedBag.</param>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Comparison{`0})">
      <summary>
            Creates a new OrderedBag. The passed delegate will be used to compare items in this bag.
            The bag is initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the OrderedBag.</param>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedBag. The Compare method of the passed comparison object
            will be used to compare items in this bag. The bag is
            initialized with all the items in the given collection.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedBag.</param>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.#ctor(System.Collections.Generic.IComparer{`0},Magnum.Collections.RedBlackTree{`0})">
      <summary>
            Creates a new OrderedBag given a comparer and a tree that contains the data. Used
            internally for Clone.
            </summary>
      <param name="comparer">Comparer for the bag.</param>
      <param name="tree">Data for the bag.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Clone">
      <summary>
            Makes a shallow clone of this bag; i.e., if items of the
            bag are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the bag takes time O(N), where N is the number of items in the bag.</remarks>
      <returns>The cloned bag.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.CloneContents">
      <summary>
            Makes a deep clone of this bag. A new bag is created with a clone of
            each element of this bag, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the bag takes time O(N log N), where N is the number of items in the bag.</para>
      </remarks>
      <returns>The cloned bag.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.NumberOfCopies(`0)">
      <summary>
            Returns the number of copies of <paramref name="item" /> in the bag. More precisely, returns
            the number of items in the bag that compare equal to <paramref name="item" />.
            </summary>
      <remarks>NumberOfCopies() takes time O(log N + M), where N is the total number of items in the
            bag, and M is the number of copies of <paramref name="item" /> in the bag.</remarks>
      <param name="item">The item to search for in the bag.</param>
      <returns>The number of items in the bag that compare equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the bag. 
            The items are enumerated in sorted order.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the bag while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the items in the bag takes time O(N), where N is the number
            of items in the bag.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the OrderedBag.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Contains(`0)">
      <summary>
            Determines if this bag contains an item equal to <paramref name="item" />. The bag
            is not changed.
            </summary>
      <remarks>Searching the bag for an item takes time O(log N), where N is the number of items in the bag.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the bag contains <paramref name="item" />. False if the bag does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.GetEqualItems(`0)">
      <summary>
        <para>Enumerates all of the items in this bag that are equal to <paramref name="item" />, according to the 
            comparison mechanism that was used when the bag was created. The bag
            is not changed.</para>
        <para>If the bag does contain an item equal to <paramref name="item" />, then the enumeration contains
            no items.</para>
      </summary>
      <remarks>Enumeration the items in the bag equal to <paramref name="item" /> takes time O(log N + M), where N 
            is the total number of items in the bag, and M is the number of items equal to <paramref name="item" />.</remarks>
      <param name="item">The item to search for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates all the items in the bag equal to <paramref name="item" />. </returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.DistinctItems">
      <summary>
            Enumerates all the items in the bag, but enumerates equal items
            just once, even if they occur multiple times in the bag.
            </summary>
      <remarks>If the bag is changed while items are being enumerated, the
            enumeration will terminate with an InvalidOperationException.</remarks>
      <returns>An IEnumerable&lt;T&gt; that enumerates the unique items.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.LastIndexOf(`0)">
      <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. If multiple
            equal items exist, the largest index of the equal items is returned.
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the last item in the sorted bag equal to <paramref name="item" />, or -1 if the item is not present
            in the set.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IndexOf(`0)">
      <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. If multiple
            equal items exist, the smallest index of the equal items is returned.
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the first item in the sorted bag equal to <paramref name="item" />, or -1 if the item is not present
            in the set.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Add(`0)">
      <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item" />. In
            this case, the new item is placed after all equal items already present in the bag.
            </summary>
      <remarks>
        <para>Adding an item takes time O(log N), where N is the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to add to the bag.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the bag. 
            </summary>
      <remarks>
        <para>Adding the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the bag.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Remove(`0)">
      <summary>
            Searches the bag for one item equal to <paramref name="item" />, and if found,
            removes it from the bag. If not found, the bag is unchanged. If more than one item
            equal to <paramref name="item" />, the item that was last inserted is removed.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>Removing an item from the bag takes time O(log N), where N is the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the bag.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RemoveAllCopies(`0)">
      <summary>
            Searches the bag for all items equal to <paramref name="item" />, and 
            removes all of them from the bag. If not found, the bag is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>RemoveAllCopies() takes time O(M log N), where N is the total number of items in the bag, and M is
            the number of items equal to <paramref name="item" />.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>The number of copies of <paramref name="item" /> that were found and removed. </returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the bag. Items not
            present in the bag are ignored.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>Removing the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the bag.</param>
      <returns>The number of items removed from the bag.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Clear">
      <summary>
            Removes all items from the bag.
            </summary>
      <remarks>Clearing the bag takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.GetFirst">
      <summary>
            Returns the first item in the bag: the item
            that would appear first if the bag was enumerated. This is also
            the smallest item in the bag.
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The first item in the bag. If more than one item
            is smallest, the first one added is returned.</returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.GetLast">
      <summary>
            Returns the last item in the bag: the item
            that would appear last if the bag was enumerated. This is also the largest
            item in the bag.
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The last item in the bag. If more than one item
            is largest, the last one added is returned.</returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RemoveFirst">
      <summary>
            Removes the first item in the bag. This is also the smallest
            item in the bag.
            </summary>
      <remarks>RemoveFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The item that was removed, which was the smallest item in the bag. </returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RemoveLast">
      <summary>
            Removes the last item in the bag. This is also the largest item in the bag.
            </summary>
      <remarks>RemoveLast() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The item that was removed, which was the largest item in the bag. </returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.CheckEmpty">
      <summary>
            If the collection is empty, throw an invalid operation exception.
            </summary>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsSupersetOf(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a superset of another bag. Neither bag is modified.
            This bag is a superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times.
            </summary>
      <remarks>IsSupersetOf is computed in time O(M log N), where M is the size of the 
            <paramref name="otherBag" />, and N is the size of the this set.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsProperSupersetOf(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a proper superset of another bag. Neither bag is modified.
            This bag is a proper superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times. Additional, this bag must have strictly more items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in 
            <paramref name="otherBag" />.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsSubsetOf(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag" /> if every element in this bag
            is also in <paramref name="otherBag" />, at least the same number of
            times.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherBag" />, and N is the size of the this bag.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsProperSubsetOf(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a proper subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag" /> if every element in this bag
            is also in <paramref name="otherBag" />, at least the same number of
            times. Additional, this bag must have strictly fewer items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref nameb="otherBag" />, and N is the size of the this bag.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsDisjointFrom(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is disjoint from another bag. Two bags are disjoint
            if no item from one set is equal to any item in the other bag.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherBag">Bag to check disjointness with.</param>
      <returns>True if the two bags are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IsEqualTo(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Determines if this bag is equal to another bag. This bag is equal to
            <paramref name="otherBag" /> if they contain the same items, each the
            same number of times.
            </summary>
      <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this bag.</remarks>
      <param name="otherBag">OrderedBag to compare to</param>
      <returns>True if this bag is equal to <paramref name="otherBag" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.UnionWith(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. This bag receives
            the union of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Union(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. A new bag is 
            created with the union of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <returns>The union of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.SumWith(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the sum of this bag with another bag. The sum of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. This bag receives
            the sum of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Sum(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the sum of this bag with another bag. he sum of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. A new bag is 
            created with the sum of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <returns>The sum of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.IntersectionWith(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. This bag receives
            the intersection of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Intersection(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. A new bag is 
            created with the intersection of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <returns>The intersection of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.DifferenceWith(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). This bag receives
            the difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Difference(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X).  A new bag is 
            created with the difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <returns>The difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.SymmetricDifferenceWith(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). This bag receives
            the symmetric difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.SymmetricDifference(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). A new bag is 
            created with the symmetric difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <returns>The symmetric difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.CheckConsistentComparison(Magnum.Collections.OrderedBag{`0})">
      <summary>
            Check that this bag and another bag were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
      <param name="otherBag">Other bag to check comparision mechanism.</param>
      <exception cref="T:System.InvalidOperationException">If otherBag and this bag don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.AsList">
      <summary>
            Get a read-only list view of the items in this ordered bag. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedBag.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this OrderedBag.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the items in the bag in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.Reversed()) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedBag.View of items in reverse order.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The items are enumerated in sorted order.
             Items equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than or equal to <paramref name="to" />, the returned collection is empty. </p>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.Range(from, true, to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedBag.View of items in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.RangeFrom(from, true)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedBag.View of items in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedBag`1.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.RangeTo(to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedBag.View of items in the given range.</returns>
    </member>
    <member name="P:Magnum.Collections.OrderedBag`1.Comparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare items in this bag. 
            </summary>
      <value>If the bag was created using a comparer, that comparer is returned. If the bag was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedBag`1.Count">
      <summary>
            Returns the number of items in the bag.
            </summary>
      <remarks>The size of the bag is returned in constant time.</remarks>
      <value>The number of items in the bag.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedBag`1.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyListBase`1">
      <summary>
            ReadOnlyListBase is an abstract class that can be used as a base class for a read-only collection that needs 
            to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs
            to override the Count property and the get part of the indexer. The implementation
            of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on.
            </summary>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.Contains(`0)">
      <summary>
            Determines if the list contains any item that compares equal to <paramref name="item" />.
            The implementation simply checks whether IndexOf(item) returns a non-negative value.
            </summary>
      <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the list contains an item that compares equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.IndexOf(`0)">
      <summary>
            Finds the index of the first item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the first item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.CopyTo(`0[])">
      <summary>
            Copies all the items in the list, in order, to <paramref name="array" />,
            starting at index 0.
            </summary>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count.</param>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
      <summary>
            Copies a range of elements from the list to <paramref name="array" />,
            starting at <paramref name="arrayIndex" />.
            </summary>
      <param name="index">The starting index in the source list of the range to copy.</param>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
      <param name="arrayIndex">The starting index in <paramref name="array" />
            to copy to.</param>
      <param name="count">The number of items to copy.</param>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.Find(System.Predicate{`0})">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:Magnum.Collections.ReadOnlyListBase`1.TryFind(System.Predicate{`0},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:Magnum.Collections.ReadOnlyListBase`1.TryFind(System.Predicate{`0},`0@)" />
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.TryFind(System.Predicate{`0},`0@)">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the first item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindLast(System.Predicate{`0})">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:Magnum.Collections.ReadOnlyListBase`1.TryFindLast(System.Predicate{`0},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:Magnum.Collections.ReadOnlyListBase`1.TryFindLast(System.Predicate{`0},`0@)" />
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.TryFindLast(System.Predicate{`0},`0@)">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the last item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindIndex(System.Predicate{`0})">
      <summary>
            Finds the index of the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindIndex(System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindLastIndex(System.Predicate{`0})">
      <summary>
            Finds the index of the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindLastIndex(System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.IndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.IndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.LastIndexOf(`0)">
      <summary>
            Finds the index of the last item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the last item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.LastIndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.LastIndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, 
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.Range(System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. 
            </summary>
      <remarks>
        <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
        <code>Algorithms.Reverse(deque.Range(3, 6))</code>
            will return the reverse opf the 6 items beginning at index 3.</remarks>
      <param name="start">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-part of this list. </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> + <paramref name="count" /> is greater than the
            size of the list.</exception>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyListBase`1.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyListBase`1.Count">
      <summary>
            The property must be overridden by the derived class to return the number of 
            items in the list.
            </summary>
      <value>The number of items in the list.</value>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyListBase`1.Item(System.Int32)">
      <summary>
            The get part of the indexer must be overridden by the derived class to get 
            values of the list at a particular index.
            </summary>
      <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.OrderedDictionary`2">
      <summary>
             OrderedDictionary&lt;TKey, TValue&gt; is a collection that maps keys of type TKey
             to values of type TValue. The keys are maintained in a sorted order, and at most one value
             is permitted for each key.
             </summary>
      <remarks>
        <p>The keys are compared in one of three ways. If TKey implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare elements. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
        <p>OrderedDictionary is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) type, where N is the number of keys in the tree.</p>
        <p>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> is similar, but uses hashing instead of comparison, and does not maintain
             the keys in sorted order.</p>
      </remarks>
      <seealso cref="T:System.Collections.Generic.Dictionary`2" />
    </member>
    <member name="T:Magnum.Collections.OrderedDictionary`2.View">
      <summary>
             The OrderedDictionary&lt;TKey,TValue&gt;.View class is used to look at a subset of the keys and values
             inside an ordered dictionary. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying dictionary changes, the view changes in sync. If a change is made
             to the view, the underlying dictionary changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the keys
             and values in a subset of the OrderedDictionary. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, to)) {
                // process pair
             }
            </code>
      </remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.View.GetEnumerator">
      <summary>
            Enumerate all the keys and values in this view.
            </summary>
      <returns>An IEnumerator of KeyValuePairs with the keys and views in this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.View.Clear">
      <summary>
            Removes all the keys and values within this view from the underlying OrderedDictionary.
            </summary>
      <example>The following removes all the keys that start with "A" from an OrderedDictionary.
            <code>
            dictionary.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.View.Reversed">
      <summary>
            Creates a new View that has the same keys and values as this, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view.</returns>
    </member>
    <member name="P:Magnum.Collections.OrderedDictionary`2.View.Count">
      <summary>
            Number of keys in this view.
            </summary>
      <value>Number of keys that lie within the bounds the view.</value>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor">
      <summary>
            Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt;
            or IComparable. 
            The CompareTo method of this interface will be used to compare keys in this dictionary.
            </summary>
      <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedDictionary. The Compare method of the passed comparison object
            will be used to compare keys in this dictionary.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
            be called, and need not be implemented.</remarks>
      <param name="comparer">An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Comparison{`0})">
      <summary>
            Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.
            </summary>
      <param name="comparison">A delegate to a method that will be used to compare keys.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
        <para>Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt;
            or IComparable. 
            The CompareTo method of this interface will be used to compare keys in this dictionary.</para>
        <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
      </summary>
      <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
      <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0})">
      <summary>
        <para>Creates a new OrderedDictionary. The Compare method of the passed comparison object
            will be used to compare keys in this dictionary.</para>
        <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
      </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
            be called, and need not be implemented.</remarks>
      <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
      <param name="comparer">An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Comparison{`0})">
      <summary>
        <para>Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.</para>
        <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
      </summary>
      <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
      <param name="comparison">A delegate to a method that will be used to compare keys.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Creates a new OrderedDictionary. The passed comparer 
            will be used to compare key-value pairs in this dictionary. Used internally  
            from other constructors.
            </summary>
      <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
      <param name="keyComparer">An IComparer that will be used to compare keys.</param>
      <param name="pairComparer">An IComparer that will be used to compare key-value pairs.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{`0,`1}},Magnum.Collections.RedBlackTree{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Creates a new OrderedDictionary. The passed comparison delegate 
            will be used to compare keys in this dictionary, and the given tree is used. Used internally for Clone().
            </summary>
      <param name="keyComparer">An IComparer that will be used to compare keys.</param>
      <param name="pairComparer">A delegate to a method that will be used to compare key-value pairs.</param>
      <param name="tree">RedBlackTree that contains the data for the dictionary.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Clone">
      <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the dictionary takes time O(N), where N is the number of keys in the dictionary.</remarks>
      <returns>The cloned dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.CloneContents">
      <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the dictionary takes time O(N log N), where N is the number of keys in the dictionary.</para>
      </remarks>
      <returns>The cloned dictionary.</returns>
      <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the keys and values in the collection in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Reversed()) {
                // process pair
             }
            </code></p>
        <p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedDictionary.View of key-value pairs in reverse order.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The keys are enumerated in sorted order.
             Keys equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than or equal to <paramref name="to" />, the returned collection is empty. </p>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, true, to, false)) {
                // process pair
             }
            </code>
        <p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The keys are enumerated in sorted order. Keys equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, true)) {
                // process pair
             }
            </code>
        <p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, false)) {
                // process pair
             }
            </code>
        <p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Remove(`0)">
      <summary>
            Removes the key (and associated value) from the collection that is equal to the passed in key. If
            no key in the dictionary is equal to the passed key, false is returned and the 
            dictionary is unchanged.
            </summary>
      <remarks>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</remarks>
      <param name="key">The key to remove.</param>
      <returns>True if the key was found and removed. False if the key was not found.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Clear">
      <summary>
            Removes all keys and values from the dictionary.
            </summary>
      <remarks>Clearing the dictionary takes a constant amount of time, regardless of the number of keys in it.</remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.GetValueElseAdd(`0,`1@)">
      <summary>
            Finds a key in the dictionary. If the dictionary already contains
            a key equal to the passed key, then the existing value is returned via value. If the dictionary
            doesn't contain that key, then value is associated with that key.
            </summary>
      <remarks>
        <para> between keys is determined by the comparison instance or delegate used
            to create the dictionary.</para>
        <para>This method takes time O(log N), where N is the number of keys in the dictionary. If a value is added, It is more efficient than
            calling TryGetValue followed by Add, because the dictionary is not searched twice.</para>
      </remarks>
      <param name="key">The new key. </param>
      <param name="value">The new value to associated with that key, if the key isn't present. If the key was present, 
            returns the exist value associated with that key.</param>
      <returns>True if key was already present, false if key wasn't present (and a new value was added).</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Add(`0,`1)">
      <summary>
            Adds a new key and value to the dictionary. If the dictionary already contains
            a key equal to the passed key, then an ArgumentException is thrown
            </summary>
      <remarks>
        <para>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</para>
        <para>Adding an key and value takes time O(log N), where N is the number of keys in the dictionary.</para>
      </remarks>
      <param name="key">The new key. "null" is a valid key value.</param>
      <param name="value">The new value to associated with that key.</param>
      <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.Replace(`0,`1)">
      <summary>
            Changes the value associated with a given key. If the dictionary does not contain
            a key equal to the passed key, then an ArgumentException is thrown.
            </summary>
      <remarks>
        <p>Unlike adding or removing an element, changing the value associated with a key
            can be performed while an enumeration (foreach) on the the dictionary is in progress.</p>
        <p>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</p>
        <p>Replace takes time O(log N), where N is the number of entries in the dictionary.</p>
      </remarks>
      <param name="key">The new key. </param>
      <param name="value">The new value to associated with that key.</param>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">key is not present in the dictionary</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.AddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Adds multiple key-value pairs to a dictionary. If a key exists in both the current instance and dictionaryToAdd,
            then the value is updated with the value from <paramref name="keysAndValues&gt;" /> (no exception is thrown).
            Since IDictionary&lt;TKey,TValue&gt; inherits from IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;, this
            method can be used to merge one dictionary into another.
            </summary>
      <remarks>AddMany takes time O(M log (N+M)), where M is the size of <paramref name="keysAndValues&gt;" />, and N is the size of
            this dictionary.</remarks>
      <param name="keysAndValues">A collection of keys and values whose contents are added to the current dictionary.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the keys found in another collection (such as an array or List&lt;TKey&gt;). Each key in keyCollectionToRemove
            is removed from the dictionary. Keys that are not present are ignored.
            </summary>
      <remarks>RemoveMany takes time O(M log N), where M is the size of keyCollectionToRemove, and N is this
            size of this collection.</remarks>
      <returns>The number of keys removed from the dictionary.</returns>
      <param name="keyCollectionToRemove">A collection of keys to remove from the dictionary.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.ContainsKey(`0)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. The dictionary
            is not changed.
            </summary>
      <remarks>Searching the dictionary for a key takes time O(log N), where N is the number of keys in the dictionary.</remarks>
      <param name="key">The key to search for.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.TryGetValue(`0,`1@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, the value
            associated with that key is returned through the value parameter.
            </summary>
      <remarks>TryGetValue takes time O(log N), where N is the number of entries in the dictionary.</remarks>
      <param name="key">The key to search for.</param>
      <param name="value">Returns the value associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the entries in the dictionary. Each entry is 
            returned as a KeyValuePair&lt;TKey,TValue&gt;.
            The entries are enumerated in the sorted order of the keys.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the elements of the dictionary, which uses this method implicitly.</p>
        <p>If an element is added to or deleted from the dictionary while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the entries in the dictionary takes time O(N log N), where N is the number
            of entries in the dictionary.</p>
      </remarks>
      <returns>An enumerator for enumerating all the elements in the OrderedDictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.NewPair(`0,`1)">
      <summary>
            Helper function to create a new KeyValuePair struct.
            </summary>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
      <returns>A new KeyValuePair.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.NewPair(`0)">
      <summary>
            Helper function to create a new KeyValuePair struct with a default value.
            </summary>
      <param name="key">The key.</param>
      <returns>A new KeyValuePair.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedDictionary`2.NonCloneableType(System.Type)">
      <summary>
            Throw an InvalidOperationException indicating that this type is not cloneable.
            </summary>
      <param name="t">Type to test.</param>
    </member>
    <member name="P:Magnum.Collections.OrderedDictionary`2.Comparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedDictionary`2.Item(`0)">
      <summary>
            Gets or sets the value associated with a given key. When getting a value, if this
            key is not found in the collection, then an ArgumentException is thrown. When setting
            a value, the value replaces any existing value in the dictionary.
            </summary>
      <remarks>The indexer takes time O(log N), where N is the number of entries in the dictionary.</remarks>
      <value>The value associated with the key</value>
      <exception cref="T:System.ArgumentException">A value is being retrieved, and the key is not present in the dictionary.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null.</exception>
    </member>
    <member name="P:Magnum.Collections.OrderedDictionary`2.Count">
      <summary>
            Returns the number of keys in the dictionary.
            </summary>
      <remarks>The size of the dictionary is returned in constant time..</remarks>
      <value>The number of keys in the dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.OrderedMultiDictionary`2">
      <summary>
        <para>The OrderedMultiDictionary class that associates values with a key. Unlike an OrderedDictionary,
             each key can have multiple values associated with it. When indexing an OrderedMultidictionary, instead
             of a single value associated with a key, you retrieve an enumeration of values.</para>
        <para>All of the key are stored in sorted order. Also, the values associated with a given key 
             are kept in sorted order as well.</para>
        <para>When constructed, you can chose to allow the same value to be associated with a key multiple
             times, or only one time. </para>
      </summary>
      <typeparam name="TKey">The type of the keys.</typeparam>
      <typeparam name="TValue">The of values associated with the keys.</typeparam>
      <seealso cref="T:Magnum.Collections.MultiDictionary`2" />
      <seealso cref="T:Magnum.Collections.OrderedDictionary`2" />
    </member>
    <member name="T:Magnum.Collections.OrderedMultiDictionary`2.View">
      <summary>
             The OrderedMultiDictionary&lt;TKey,TValue&gt;.View class is used to look at a subset of the keys and values
             inside an ordered multi-dictionary. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying dictionary changes, the view changes in sync. If a change is made
             to the view, the underlying dictionary changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the keys
             and values in a subset of the OrderedMultiDictionary. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, to)) {
                // process pair
             }
            </code>
      </remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.View.Clear">
      <summary>
            Removes all the keys and values within this view from the underlying OrderedMultiDictionary.
            </summary>
      <example>The following removes all the keys that start with "A" from an OrderedMultiDictionary.
            <code>
            dictionary.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.View.Reversed">
      <summary>
            Creates a new View that has the same keys and values as this, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.View.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
    </member>
    <member name="P:Magnum.Collections.OrderedMultiDictionary`2.View.Count">
      <summary>
            Number of keys in this view.
            </summary>
      <value>Number of keys that lie within the bounds the view.</value>
    </member>
    <member name="T:Magnum.Collections.OrderedMultiDictionary`2.KeyValuePairsCollection">
      <summary>
            A private class that implements ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; and ICollection for the
            KeyValuePairs collection. The collection is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.KeyRange(`0)">
      <summary>
            Get a RangeTester that maps to the range of all items with the 
            given key.
            </summary>
      <param name="key">Key in the given range.</param>
      <returns>A RangeTester delegate that selects the range of items with that range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.DoubleBoundedKeyRangeTester(`0,System.Boolean,`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
      <param name="first">The lower bound.</param>
      <param name="firstInclusive">True if the lower bound is inclusive, false if exclusive.</param>
      <param name="last">The upper bound.</param>
      <param name="lastInclusive">True if the upper bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for a key in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.LowerBoundedKeyRangeTester(`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by a lower bound.
            </summary>
      <param name="first">The lower bound.</param>
      <param name="inclusive">True if the lower bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for a key in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.UpperBoundedKeyRangeTester(`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by upper bound.
            </summary>
      <param name="last">The upper bound.</param>
      <param name="inclusive">True if the upper bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for a key in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean)">
      <summary>
            Create a new OrderedMultiDictionary. The default ordering of keys and values are used. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <remarks>The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented). If a different ordering should be
            used, other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.</remarks>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <exception cref="T:System.InvalidOperationException">TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparison">A delegate to a method that will be used to compare keys.</param>
      <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0},System.Comparison{`1})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparison">A delegate to a method that will be used to compare keys.</param>
      <param name="valueComparison">A delegate to a method that will be used to compare values.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <param name="valueComparer">An IComparer&lt;TValue&gt; instance that will be used to compare values.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Int32,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{`0,`1}},Magnum.Collections.RedBlackTree{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Create a new OrderedMultiDictionary. Used internally for cloning.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyCount">Number of keys.</param>
      <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <param name="valueComparer">An IComparer&lt;TValue&gt; instance that will be used to compare values.</param>
      <param name="comparer">Comparer of key-value pairs.</param>
      <param name="tree">The red-black tree used to store the data.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Add(`0,`1)">
      <summary>
        <para>Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.</para>
        <para>If duplicate values are not permitted, and <paramref name="key" /> already has a value
            equal to <paramref name="value" /> associated with it, then that value is replaced with <paramref name="value" />,
            and the number of values associate with <paramref name="key" /> is unchanged.</para>
      </summary>
      <param name="key">The key to associate with.</param>
      <param name="value">The value to associated with <paramref name="key" />.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Remove(`0,`1)">
      <summary>
            Removes a given value from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
      <param name="key">A key to remove a value from.</param>
      <param name="value">The value to remove.</param>
      <returns>True if <paramref name="value" /> was associated with <paramref name="key" /> (and was
            therefore removed). False if <paramref name="value" /> was not associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Remove(`0)">
      <summary>
            Removes a key and all associated values from the dictionary. If the
            key is not present in the dictionary, it is unchanged and false is returned.
            </summary>
      <param name="key">The key to remove.</param>
      <returns>True if the key was present and was removed. Returns 
            false if the key was not present.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Clear">
      <summary>
            Removes all keys and values from the dictionary.
            </summary>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Contains(`0,`1)">
      <summary>
            Checks to see if <paramref name="value" /> is associated with <paramref name="key" />
            in the dictionary.
            </summary>
      <param name="key">The key to check.</param>
      <param name="value">The value to check.</param>
      <returns>True if <paramref name="value" /> is associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.ContainsKey(`0)">
      <summary>
            Checks to see if the key is present in the dictionary and has
            at least one value associated with it.
            </summary>
      <param name="key">The key to check.</param>
      <returns>True if <paramref name="key" /> is present and has at least
            one value associated with it. Returns false otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.EqualValues(`1,`1)">
      <summary>
            Determine if two values are equal.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, all the values
            associated with that key are returned through the values parameter. 
            </summary>
      <param name="key">The key to search for.</param>
      <param name="values">Returns all values associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.EnumerateKeys">
      <summary>
            Enumerate all of the keys in the dictionary.
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; of all of the keys in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.CountValues(`0)">
      <summary>
            Gets the number of values associated with a given key.
            </summary>
      <param name="key">The key to count values of.</param>
      <returns>The number of values associated with <paramref name="key" />. If <paramref name="key" />
            is not present in the dictionary, zero is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.CountAllValues">
      <summary>
            Gets a total count of values in the collection. 
            </summary>
      <returns>The total number of values associated with all keys in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.EnumerateKeys(Magnum.Collections.RedBlackTree{System.Collections.Generic.KeyValuePair{`0,`1}}.RangeTester,System.Boolean)">
      <summary>
            A private helper method that returns an enumerable that
            enumerates all the keys in a range.
            </summary>
      <param name="rangeTester">Defines the range to enumerate.</param>
      <param name="reversed">Should the keys be enumerated in reverse order?</param>
      <returns>An IEnumerable&lt;TKey&gt; that enumerates the keys in the given range.
            in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.EnumerateValuesForKey(`0)">
      <summary>
            A private helper method for the indexer to return an enumerable that
            enumerates all the values for a key. This is separate method because indexers
            can't use the yield return construct.
            </summary>
      <param name="key">
      </param>
      <returns>An IEnumerable&lt;TValue&gt; that can be used to enumerate all the
            values associated with <paramref name="key" />. If <paramref name="key" /> is not present,
            an enumerable that enumerates no items is returned.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Clone">
      <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.</remarks>
      <returns>The cloned dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.CloneContents">
      <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para>
      </remarks>
      <returns>The cloned dictionary.</returns>
      <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.NonCloneableType(System.Type)">
      <summary>
            Throw an InvalidOperationException indicating that this type is not cloneable.
            </summary>
      <param name="t">Type to test.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the keys and values in the collection in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Reversed()) {
                // process pair
             }
            </code></p>
        <p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedDictionary.View of key-value pairs in reverse order.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The keys are enumerated in sorted order.
             Keys equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than or equal to <paramref name="to" />, the returned collection is empty. </p>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, true, to, false)) {
                // process pair
             }
            </code>
        <p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The keys are enumerated in sorted order. Keys equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, true)) {
                // process pair
             }
            </code>
        <p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, false)) {
                // process pair
             }
            </code>
        <p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedMultiDictionary`2.NewPair(`0,`1)">
      <summary>
            Helper function to create a new KeyValuePair struct.
            </summary>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
      <returns>A new KeyValuePair.</returns>
    </member>
    <member name="P:Magnum.Collections.OrderedMultiDictionary`2.KeyComparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedMultiDictionary`2.ValueComparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TValue (Comparer&lt;TValue&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedMultiDictionary`2.Count">
      <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted. If duplicate values are permitted, each duplicate
            value is included in the count.
            </summary>
      <value>The number of key-value pairs in the dictionary.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedMultiDictionary`2.KeyValuePairs">
      <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
    </member>
    <member name="T:Magnum.Collections.OrderedSet`1">
      <summary>
             OrderedSet&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a sorted order, and duplicate items are not allowed. Each item has
             an index in the set: the smallest item has index 0, the next smallest item has index 1,
             and so forth.
             </summary>
      <remarks>
        <p>The items are compared in one of three ways. If T implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare items. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
        <p>OrderedSet is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) type, where N is the number of keys in the tree.</p>
        <p>
          <see cref="T:Magnum.Collections.Set`1" /> is similar, but uses hashing instead of comparison, and does not maintain
             the items in sorted order.</p>
      </remarks>
      <seealso cref="T:Magnum.Collections.Set`1" />
    </member>
    <member name="T:Magnum.Collections.OrderedSet`1.ListView">
      <summary>
            The nested class that provides a read-only list view
            of all or part of the collection.
            </summary>
    </member>
    <member name="T:Magnum.Collections.OrderedSet`1.View">
      <summary>
             The OrderedSet&lt;T&gt;.View class is used to look at a subset of the Items
             inside an ordered set. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying set changes, the view changes in sync. If a change is made
             to the view, the underlying set changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the items 
             in a subset of the OrderedSet. For example:</p>
        <code>
             foreach(T item in set.Range(from, to)) {
                // process item
             }
            </code>
      </remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.GetEnumerator">
      <summary>
            Enumerate all the items in this view.
            </summary>
      <returns>An IEnumerator&lt;T&gt; with the items in this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.Clear">
      <summary>
            Removes all the items within this view from the underlying set.
            </summary>
      <example>The following removes all the items that start with "A" from an OrderedSet.
            <code>
            set.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.AsList">
      <summary>
            Get a read-only list view of the items in this view. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this view.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.Reversed">
      <summary>
            Creates a new View that has the same items as this view, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view, with the same upper 
            and lower bounds.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.GetFirst">
      <summary>
            Returns the first item in this view: the item
            that would appear first if the view was enumerated. 
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The first item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.View.GetLast">
      <summary>
            Returns the last item in the view: the item
            that would appear last if the view was enumerated. 
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The last item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="P:Magnum.Collections.OrderedSet`1.View.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="P:Magnum.Collections.OrderedSet`1.View.Count">
      <summary>
            Number of items in this view.
            </summary>
      <value>Number of items that lie within the bounds the view.</value>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor">
      <summary>
             Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this set.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Comparison{`0})">
      <summary>
            Creates a new OrderedSet. The passed delegate will be used to compare items in this set.
            </summary>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedSet. The Compare method of the passed comparison object
            will be used to compare items in this set.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this set. The set is
             initialized with all the items in the given collection.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedSet.</param>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Comparison{`0})">
      <summary>
            Creates a new OrderedSet. The passed delegate will be used to compare items in this set.
            The set is initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the OrderedSet.</param>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedSet. The Compare method of the passed comparison object
            will be used to compare items in this set. The set is
            initialized with all the items in the given collection.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedSet.</param>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.#ctor(System.Collections.Generic.IComparer{`0},Magnum.Collections.RedBlackTree{`0})">
      <summary>
            Creates a new OrderedSet given a comparer and a tree that contains the data. Used
            internally for Clone.
            </summary>
      <param name="comparer">Comparer for the set.</param>
      <param name="tree">Data for the set.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Clone">
      <summary>
            Makes a shallow clone of this set; i.e., if items of the
            set are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the set takes time O(N), where N is the number of items in the set.</remarks>
      <returns>The cloned set.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.CloneContents">
      <summary>
            Makes a deep clone of this set. A new set is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the set takes time O(N log N), where N is the number of items in the set.</para>
      </remarks>
      <returns>The cloned set.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the set. 
            The items are enumerated in sorted order.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the set while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the items in the set takes time O(N log N), where N is the number
            of items in the set.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the OrderedSet.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Contains(`0)">
      <summary>
            Determines if this set contains an item equal to <paramref name="item" />. The set
            is not changed.
            </summary>
      <remarks>Searching the set for an item takes time O(log N), where N is the number of items in the set.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.TryGetItem(`0,`0@)">
      <summary>
        <para>Determines if this set contains an item equal to <paramref name="item" />, according to the 
            comparison mechanism that was used when the set was created. The set
            is not changed.</para>
        <para>If the set does contain an item equal to <paramref name="item" />, then the item from the set is returned.</para>
      </summary>
      <remarks>Searching the set for an item takes time O(log N), where N is the number of items in the set.</remarks>
      <example>
            In the following example, the set contains strings which are compared in a case-insensitive manner. 
            <code>
            OrderedSet&lt;string&gt; set = new OrderedSet&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase);
            set.Add("HELLO");
            string s;
            bool b = set.TryGetItem("Hello", out s);   // b receives true, s receives "HELLO".
            </code></example>
      <param name="item">The item to search for.</param>
      <param name="foundItem">Returns the item from the set that was equal to <paramref name="item" />.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IndexOf(`0)">
      <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the item in the sorted set, or -1 if the item is not present
            in the set.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Add(`0)">
      <summary>
            Adds a new item to the set. If the set already contains an item equal to
            <paramref name="item" />, that item is replaced with <paramref name="item" />.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding an item takes time O(log N), where N is the number of items in the set.</para>
      </remarks>
      <param name="item">The item to add to the set.</param>
      <returns>True if the set already contained an item equal to <paramref name="item" /> (which was replaced), false 
            otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the set. If the set already contains an item equal to
            one of the items in <paramref name="collection" />, that item will be replaced.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding the collection takes time O(M log N), where N is the number of items in the set, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the set.</param>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Remove(`0)">
      <summary>
            Searches the set for an item equal to <paramref name="item" />, and if found,
            removes it from the set. If not found, the set is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing an item from the set takes time O(log N), where N is the number of items in the set.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the set.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Clear">
      <summary>
            Removes all items from the set.
            </summary>
      <remarks>Clearing the sets takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the set. Items
            not present in the set are ignored.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing the collection takes time O(M log N), where N is the number of items in the set, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the set.</param>
      <returns>The number of items removed from the set.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.GetFirst">
      <summary>
            Returns the first item in the set: the item
            that would appear first if the set was enumerated. This is also
            the smallest item in the set.
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The first item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.GetLast">
      <summary>
            Returns the lastl item in the set: the item
            that would appear last if the set was enumerated. This is also the
            largest item in the set.
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The lastl item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.RemoveFirst">
      <summary>
            Removes the first item in the set. This is also the smallest item in the set.
            </summary>
      <remarks>RemoveFirst() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The item that was removed, which was the smallest item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.RemoveLast">
      <summary>
            Removes the last item in the set. This is also the largest item in the set.
            </summary>
      <remarks>RemoveLast() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The item that was removed, which was the largest item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.CheckEmpty">
      <summary>
            If the collection is empty, throw an invalid operation exception.
            </summary>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsSupersetOf(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is a superset of another set. Neither set is modified.
            This set is a superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            <remarks>IsSupersetOf is computed in time O(M log N), where M is the size of the 
            <paramref name="otherSet" />, and N is the size of the this set.</remarks></summary>
      <param name="otherSet">OrderedSet to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsProperSupersetOf(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is a proper superset of another set. Neither set is modified.
            This set is a proper superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            Additionally, this set must have strictly more items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in 
            <paramref name="otherSet" />.</remarks>
      <param name="otherSet">OrderedSet to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsSubsetOf(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is a subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherSet" />, and N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsProperSubsetOf(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is a proper subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />. Additionally, this set must have strictly 
            fewer items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherSet" />, and N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsEqualTo(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is equal to another set. This set is equal to
            <paramref name="otherSet" /> if they contain the same items.
            </summary>
      <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this set.</remarks>
      <param name="otherSet">Set to compare to</param>
      <returns>True if this set is equal to <paramref name="otherSet" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.UnionWith(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. This set receives
            the union of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IsDisjointFrom(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Determines if this set is disjoint from another set. Two sets are disjoint
            if no item from one set is equal to any item in the other set.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to check disjointness with.</param>
      <returns>True if the two sets are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Union(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. A new set is 
            created with the union of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <returns>The union of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.IntersectionWith(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. This set receives
            the intersection of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Intersection(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. A new set is 
            created with the intersection of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <returns>The intersection of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.DifferenceWith(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. This set receives
            the difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Difference(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. A new set is 
            created with the difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <returns>The difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.SymmetricDifferenceWith(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. This set receives
            the symmetric difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.SymmetricDifference(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. A new set is 
            created with the symmetric difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <returns>The symmetric difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.CheckConsistentComparison(Magnum.Collections.OrderedSet{`0})">
      <summary>
            Check that this set and another set were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
      <param name="otherSet">Other set to check comparision mechanism.</param>
      <exception cref="T:System.InvalidOperationException">If otherSet and this set don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.AsList">
      <summary>
            Get a read-only list view of the items in this ordered set. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this OrderedSet.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the items in the set in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.Reversed()) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedSet.View of items in reverse order.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The items are enumerated in sorted order.
             Items equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than <paramref name="to" />, the returned collection is empty. </p>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.Range(from, true, to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedSet.View of items in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.RangeFrom(from, true)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedSet.View of items in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.OrderedSet`1.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.RangeTo(to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedSet.View of items in the given range.</returns>
    </member>
    <member name="P:Magnum.Collections.OrderedSet`1.Comparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare items in this set. 
            </summary>
      <value>If the set was created using a comparer, that comparer is returned. If the set was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedSet`1.Count">
      <summary>
            Returns the number of items in the set.
            </summary>
      <remarks>The size of the set is returned in constant time.</remarks>
      <value>The number of items in the set.</value>
    </member>
    <member name="P:Magnum.Collections.OrderedSet`1.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:Magnum.Collections.Pair`2">
      <summary>
            Stores a pair of objects within a single struct. This struct is useful to use as the
            T of a collection, or as the TKey or TValue of a dictionary.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Pair`2.firstComparer">
      <summary>
            Comparers for the first and second type that are used to compare
            values.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Pair`2.First">
      <summary>
            The first element of the pair.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Pair`2.Second">
      <summary>
            The second element of the pair.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Pair`2.#ctor(`0,`1)">
      <summary>
            Creates a new pair with given first and second elements.
            </summary>
      <param name="first">The first element of the pair.</param>
      <param name="second">The second element of the pair.</param>
    </member>
    <member name="M:Magnum.Collections.Pair`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Creates a new pair using elements from a KeyValuePair structure. The
            First element gets the Key, and the Second elements gets the Value.
            </summary>
      <param name="keyAndValue">The KeyValuePair to initialize the Pair with .</param>
    </member>
    <member name="M:Magnum.Collections.Pair`2.CompareTo(Magnum.Collections.Pair{`0,`1})">
      <summary>
        <para> Compares this pair to another pair of the some type. The pairs are compared by using
            the IComparable&lt;T&gt; or IComparable interface on TFirst and TSecond. The pairs
            are compared by their first elements first, if their first elements are equal, then they
            are compared by their second elements.</para>
        <para>If either TFirst or TSecond does not implement IComparable&lt;T&gt; or IComparable, then
            an NotSupportedException is thrown, because the pairs cannot be compared.</para>
      </summary>
      <param name="other">The pair to compare to.</param>
      <returns>An integer indicating how this pair compares to <paramref name="other" />. Less
            than zero indicates this pair is less than <paramref name="other" />. Zero indicate this pair is
            equals to <paramref name="other" />. Greater than zero indicates this pair is greater than
            <paramref name="other" />.</returns>
      <exception cref="T:System.NotSupportedException">Either FirstSecond or TSecond is not comparable
            via the IComparable&lt;T&gt; or IComparable interfaces.</exception>
    </member>
    <member name="M:Magnum.Collections.Pair`2.Equals(System.Object)">
      <summary>
            Determines if this pair is equal to another object. The pair is equal to another object 
            if that object is a Pair, both element types are the same, and the first and second elements
            both compare equal using object.Equals.
            </summary>
      <param name="obj">Object to compare for equality.</param>
      <returns>True if the objects are equal. False if the objects are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.Equals(Magnum.Collections.Pair{`0,`1})">
      <summary>
            Determines if this pair is equal to another pair. The pair is equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="other">Pair to compare with for equality.</param>
      <returns>True if the pairs are equal. False if the pairs are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.GetHashCode">
      <summary>
            Returns a hash code for the pair, suitable for use in a hash-table or other hashed collection.
            Two pairs that compare equal (using Equals) will have the same hash code. The hash code for
            the pair is derived by combining the hash codes for each of the two elements of the pair.
            </summary>
      <returns>The hash code.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.ToString">
      <summary>
            Returns a string representation of the pair. The string representation of the pair is
            of the form:
            <c>First: {0}, Second: {1}</c>
            where {0} is the result of First.ToString(), and {1} is the result of Second.ToString() (or
            "null" if they are null.)
            </summary>
      <returns> The string representation of the pair.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.ToKeyValuePair">
      <summary>
            Converts this Pair to a KeyValuePair. The Key part of the KeyValuePair gets
            the First element, and the Value part of the KeyValuePair gets the Second 
            elements.
            </summary>
      <returns>The KeyValuePair created from this Pair.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.op_Equality(Magnum.Collections.Pair{`0,`1},Magnum.Collections.Pair{`0,`1})">
      <summary>
            Determines if two pairs are equal. Two pairs are equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First pair to compare.</param>
      <param name="pair2">Second pair to compare.</param>
      <returns>True if the pairs are equal. False if the pairs are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.op_Inequality(Magnum.Collections.Pair{`0,`1},Magnum.Collections.Pair{`0,`1})">
      <summary>
            Determines if two pairs are not equal. Two pairs are equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First pair to compare.</param>
      <param name="pair2">Second pair to compare.</param>
      <returns>True if the pairs are not equal. False if the pairs are equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.op_Explicit(Magnum.Collections.Pair{`0,`1})~System.Collections.Generic.KeyValuePair{`0,`1}">
      <summary>
            Converts a Pair to a KeyValuePair. The Key part of the KeyValuePair gets
            the First element, and the Value part of the KeyValuePair gets the Second 
            elements.
            </summary>
      <param name="pair">Pair to convert.</param>
      <returns>The KeyValuePair created from <paramref name="pair" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Pair`2.op_Explicit(System.Collections.Generic.KeyValuePair{`0,`1})~Magnum.Collections.Pair{`0,`1}">
      <summary>
            Converts a KeyValuePair structure into a Pair. The
            First element gets the Key, and the Second element gets the Value.
            </summary>
      <param name="keyAndValue">The KeyValuePair to convert.</param>
      <returns>The Pair created by converted the KeyValuePair into a Pair.</returns>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyDictionaryBase`2">
      <summary>
            ReadOnlyDictionaryBase is a base class that can be used to more easily implement the
            generic IDictionary&lt;T&gt; and non-generic IDictionary interfaces.
            </summary>
      <remarks>
        <para>To use ReadOnlyDictionaryBase as a base class, the derived class must override
            Count, TryGetValue, GetEnumerator. </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyDictionaryBase`2.DictionaryEnumeratorWrapper">
      <summary>
            A class that wraps a IDictionaryEnumerator around an IEnumerator that
            enumerates KeyValuePairs. This is useful in implementing IDictionary, because
            IEnumerator can be implemented with an iterator, but IDictionaryEnumerator cannot.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyDictionaryBase`2.KeysCollection">
      <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyDictionaryBase`2.ValuesCollection">
      <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.Remove(`0)">
      <summary>
            Removes a key from the dictionary. Always throws an exception
            indicating that this method is not supported in a read-only dictionary.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <returns>True if the key was found, false otherwise.</returns>
      <exception cref="T:System.NotSupportedException">Always thrown.</exception>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found
            in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryGetValue and returns
            what it returns.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.TryGetValue(`0,`1@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, the value
            associated with that key is returned through the value parameter. This method must be overridden 
            in the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">Returns the value associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Determines if a dictionary contains a given KeyValuePair. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value.
            </summary>
      <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyDictionaryBase`2.Item(`0)">
      <summary>
            The indexer of the dictionary. The set accessor throws an NotSupportedException
            stating the dictionary is read-only.
            </summary>
      <remarks>The get accessor is implemented by calling TryGetValue.</remarks>
      <param name="key">Key to find in the dictionary.</param>
      <returns>The value associated with the key.</returns>
      <exception cref="T:System.NotSupportedException">Always thrown from the set accessor, indicating
            that the dictionary is read only.</exception>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown from the get accessor if the key
            was not found.</exception>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyDictionaryBase`2.Keys">
      <summary>
            Returns a collection of the keys in this dictionary. 
            </summary>
      <value>A read-only collection of the keys in this dictionary.</value>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyDictionaryBase`2.Values">
      <summary>
            Returns a collection of the values in this dictionary. The ordering of 
            values in this collection is the same as that in the Keys collection.
            </summary>
      <value>A read-only collection of the values in this dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2">
      <summary>
            MultiDictionaryBase is a base class that can be used to more easily implement a class
            that associates multiple values to a single key. The class implements the generic
            IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt; interface. The resulting collection
            is read-only -- items cannot be added or removed.
            </summary>
      <remarks>
        <para>To use ReadOnlyMultiDictionaryBase as a base class, the derived class must override
            Count, Contains(TKey,TValue), EnumerateKeys, and TryEnumerateValuesForKey . </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection">
      <summary>
            A private class that provides the ICollection&lt;TValue&gt; for a particular key. This is the collection
            that is returned from the indexer. The collections is read-write, live, and can be used to add, remove,
            etc. values from the multi-dictionary.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection.GetEnumerator">
      <summary>
            Enumerate all the values associated with key.
            </summary>
      <returns>An IEnumerator&lt;TValue&gt; that enumerates all the values associated with key.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection.NoValues">
      <summary>
            A simple function that returns an IEnumerator&lt;TValue&gt; that
            doesn't yield any values. A helper.
            </summary>
      <returns>An IEnumerator&lt;TValue&gt; that yields no values.</returns>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection.Count">
      <summary>
            Get the number of values associated with the key.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.KeysCollection">
      <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ValuesCollection">
      <summary>
            A private class that implements ICollection&lt;TValue&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.EnumerableValuesCollection">
      <summary>
            A private class that implements ICollection&lt;IEnumerable&lt;TValue&gt;&gt; and ICollection for the
            Values collection on IDictionary. The collection is read-only.
            </summary>
    </member>
    <member name="T:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.KeyValuePairsCollection">
      <summary>
            A private class that implements ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; and ICollection for the
            KeyValuePairs collection. The collection is read-only.
            </summary>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryGetValue.
            It may be appropriate to override this method to 
            provide a more efficient implementation.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Determines if this dictionary contains the given key and all of the values associated with that key..
            </summary>
      <param name="pair">A key and collection of values to search for.</param>
      <returns>True if the dictionary has associated all of the values in <paramref name="pair" />.Value with <paramref name="pair" />.Key.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.GetEnumerator">
      <summary>
            Enumerate all the keys in the dictionary, and for each key, the collection of values for that key.
            </summary>
      <returns>An enumerator to enumerate all the key, ICollection&lt;value&gt; pairs in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Contains(`0,`1)">
      <summary>
            Determines if this dictionary contains a key-value pair equal to <paramref name="key" /> and 
            <paramref name="value" />. The dictionary is not changed. This method must be overridden in the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">The value to search for.</param>
      <returns>True if the dictionary has associated <paramref name="value" /> with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. This method must be overridden by a derived
            class.
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Enumerate all of the values associated with a given key. This method must be overridden
            by the derived class. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values" />. If the key does not exist, false is returned.
            </summary>
      <param name="key">The key to get values for.</param>
      <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
      <returns>True if the key exists and has values associated with it. False otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.EqualValues(`1,`1)">
      <summary>
            If the derived class does not use the default comparison for values, this
            methods should be overridden to compare two values for equality. This is
            used for the correct implementation of ICollection.Contains on the Values
            and KeyValuePairs collections.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.CountValues(`0)">
      <summary>
            Gets a count of the number of values associated with a key. The
            default implementation is slow; it enumerators all of the values
            (using TryEnumerateValuesForKey) to count them. A derived class
            may be able to supply a more efficient implementation.
            </summary>
      <param name="key">The key to count values for.</param>
      <returns>The number of values associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.CountAllValues">
      <summary>
            Gets a total count of values in the collection. This default implementation
            is slow; it enumerates all of the keys in the dictionary and calls CountValues on each.
            A derived class may be able to supply a more efficient implementation.
            </summary>
      <returns>The total number of values associated with all keys in the dictionary.</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.MethodModifiesCollection">
      <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Values">
      <summary>
            Gets a read-only collection of all the values in the dictionary. 
            </summary>
      <returns>A read-only ICollection&lt;TValue&gt; of all the values in the dictionary.</returns>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.KeyValuePairs">
      <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Item(`0)">
      <summary>
            Returns a collection of all of the values in the dictionary associated with <paramref name="key" />.
            If the key is not present in the dictionary, an ICollection with no
            values is returned. The returned ICollection is read-only.
            </summary>
      <param name="key">The key to get the values associated with.</param>
      <value>An ICollection&lt;TValue&gt; with all the values associated with <paramref name="key" />.</value>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Count">
      <summary>
            Gets the number of keys in the dictionary. This property must be overridden
            in the derived class.
            </summary>
    </member>
    <member name="P:Magnum.Collections.ReadOnlyMultiDictionaryBase`2.Keys">
      <summary>
            Gets a read-only collection all the keys in this dictionary.
            </summary>
      <value>An readonly ICollection&lt;TKey&gt; of all the keys in this dictionary.</value>
    </member>
    <member name="T:Magnum.Collections.DuplicatePolicy">
      <summary>
            Describes what to do if a key is already in the tree when doing an
            insertion.
            </summary>
    </member>
    <member name="T:Magnum.Collections.RedBlackTree`1">
      <summary>
             The base implementation for various collections classes that use Red-Black trees
             as part of their implementation. This class should not (and can not) be 
             used directly by end users; it's only for internal use by the collections package.
             </summary>
      <remarks>
             The Red-Black tree manages items of type T, and uses a IComparer&lt;T&gt; that
             compares items to sort the tree. Multiple items can compare equal and be stored
             in the tree. Insert, Delete, and Find operations are provided in their full generality;
             all operations allow dealing with either the first or last of items that compare equal. 
            </remarks>
    </member>
    <member name="T:Magnum.Collections.RedBlackTree`1.RangeTester">
      <summary>
            A delegate that tests if an item is within a custom range. The range must be a contiguous
            range of items with the ordering of this tree. The range test function must test
            if an item is before, withing, or after the range.
            </summary>
      <param name="item">Item to test against the range.</param>
      <returns>Returns negative if item is before the range, zero if item is withing the range,
            and positive if item is after the range.</returns>
    </member>
    <member name="T:Magnum.Collections.RedBlackTree`1.Node">
      <summary>
            The class that is each node in the red-black tree.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Node.IncrementCount">
      <summary>
            Add one to the Count.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Node.DecrementCount">
      <summary>
            Subtract one from the Count. The current
            Count must be non-zero.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Node.Clone">
      <summary>
            Clones a node and all its descendants.
            </summary>
      <returns>The cloned node.</returns>
    </member>
    <member name="P:Magnum.Collections.RedBlackTree`1.Node.IsRed">
      <summary>
            Is this a red node?
            </summary>
    </member>
    <member name="P:Magnum.Collections.RedBlackTree`1.Node.Count">
      <summary>
            Get or set the Count field -- a 31-bit field
            that holds the number of nodes at or below this
            level.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Initialize a red-black tree, using the given interface instance to compare elements. Only
            Compare is used on the IComparer interface.
            </summary>
      <param name="comparer">The IComparer&lt;T&gt; used to sort keys.</param>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.GetEnumerator">
      <summary>
            Enumerate all the items in-order
            </summary>
      <returns>An enumerator for all the items, in order.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.BoundedRangeTester(System.Boolean,`0,System.Boolean,`0)">
      <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
      <param name="useFirst">If true, bound the range on the bottom by first.</param>
      <param name="first">If useFirst is true, the inclusive lower bound.</param>
      <param name="useLast">If true, bound the range on the top by last.</param>
      <param name="last">If useLast is true, the exclusive upper bound.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.DoubleBoundedRangeTester(`0,System.Boolean,`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
      <param name="first">The lower bound.</param>
      <param name="firstInclusive">True if the lower bound is inclusive, false if exclusive.</param>
      <param name="last">The upper bound.</param>
      <param name="lastInclusive">True if the upper bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.LowerBoundedRangeTester(`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by a lower bound.
            </summary>
      <param name="first">The lower bound.</param>
      <param name="inclusive">True if the lower bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.UpperBoundedRangeTester(`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by upper bound.
            </summary>
      <param name="last">The upper bound.</param>
      <param name="inclusive">True if the upper bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EqualRangeTester(`0)">
      <summary>
            Gets a range tester that defines a range by all items equal to an item.
            </summary>
      <param name="equalTo">The item that is contained in the range.</param>
      <returns>A RangeTester delegate that tests for an item equal to <paramref name="equalTo" />.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EntireRangeTester(`0)">
      <summary>
            A range tester that defines a range that is the entire tree.
            </summary>
      <param name="item">Item to test.</param>
      <returns>Always returns 0.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EnumerateRange(Magnum.Collections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Enumerate the items in a custom range in the tree. The range is determined by 
            a RangeTest delegate.
            </summary>
      <param name="rangeTester">Tests an item against the custom range.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the custom range in order.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EnumerateRangeReversed(Magnum.Collections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Enumerate the items in a custom range in the tree, in reversed order. The range is determined by 
            a RangeTest delegate.
            </summary>
      <param name="rangeTester">Tests an item against the custom range.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the custom range in reversed order.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.DeleteItemFromRange(Magnum.Collections.RedBlackTree{`0}.RangeTester,System.Boolean,`0@)">
      <summary>
            Deletes either the first or last item from a range, as identified by a RangeTester
            delegate. If the range is empty, returns false.
            </summary>
      <remarks>Top-down algorithm from Weiss. Basic plan is to move down in the tree, 
            rotating and recoloring along the way to always keep the current node red, which 
            ensures that the node we delete is red. The details are quite complex, however! </remarks>
      <param name="rangeTester">Range to delete from.</param>
      <param name="deleteFirst">If true, delete the first item from the range, else the last.</param>
      <param name="item">Returns the item that was deleted, if true returned.</param>
      <returns>True if an element was deleted, false if the range is empty.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.DeleteRange(Magnum.Collections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Delete all the items in a range, identified by a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range to delete.</param>
      <returns>The number of items deleted.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.CountRange(Magnum.Collections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Count the items in a custom range in the tree. The range is determined by 
            a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range.</param>
      <returns>The number of items in the range.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.FirstItemInRange(Magnum.Collections.RedBlackTree{`0}.RangeTester,`0@)">
      <summary>
            Find the first item in a custom range in the tree, and it's index. The range is determined
            by a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range.</param>
      <param name="item">Returns the item found, if true was returned.</param>
      <returns>Index of first item in range if range is non-empty, -1 otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.LastItemInRange(Magnum.Collections.RedBlackTree{`0}.RangeTester,`0@)">
      <summary>
            Find the last item in a custom range in the tree, and it's index. The range is determined
            by a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range.</param>
      <param name="item">Returns the item found, if true was returned.</param>
      <returns>Index of the item if range is non-empty, -1 otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EnumerateRangeInOrder(Magnum.Collections.RedBlackTree{`0}.RangeTester,Magnum.Collections.RedBlackTree{`0}.Node)">
      <summary>
            Enumerate all the items in a custom range, under and including node, in-order.
            </summary>
      <param name="rangeTester">Tests an item against the custom range.</param>
      <param name="node">Node to begin enumeration. May be null.</param>
      <returns>An enumerable of the items.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.EnumerateRangeInReversedOrder(Magnum.Collections.RedBlackTree{`0}.RangeTester,Magnum.Collections.RedBlackTree{`0}.Node)">
      <summary>
            Enumerate all the items in a custom range, under and including node, in reversed order.
            </summary>
      <param name="rangeTester">Tests an item against the custom range.</param>
      <param name="node">Node to begin enumeration. May be null.</param>
      <returns>An enumerable of the items, in reversed oreder.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.CountRangeUnderNode(Magnum.Collections.RedBlackTree{`0}.RangeTester,Magnum.Collections.RedBlackTree{`0}.Node,System.Boolean,System.Boolean)">
      <summary>
            Count all the items in a custom range, under and including node.
            </summary>
      <param name="rangeTester">The delegate that defines the range.</param>
      <param name="node">Node to begin enumeration. May be null.</param>
      <param name="belowRangeTop">This node and all under it are either in the range or below it.</param>
      <param name="aboveRangeBottom">This node and all under it are either in the range or above it.</param>
      <returns>The number of items in the range, under and include node.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Clone">
      <summary>
            Clone the tree, returning a new tree containing the same items. Should
            take O(N) take.
            </summary>
      <returns>Clone version of this tree.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Find(`0,System.Boolean,System.Boolean,`0@)">
      <summary>
            Finds the key in the tree. If multiple items in the tree have
            compare equal to the key, finds the first or last one. Optionally replaces the item
            with the one searched for.
            </summary>
      <param name="key">Key to search for.</param>
      <param name="findFirst">If true, find the first of duplicates, else finds the last of duplicates.</param>
      <param name="replace">If true, replaces the item with key (if function returns true)</param>
      <param name="item">Returns the found item, before replacing (if function returns true).</param>
      <returns>True if the key was found.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.FindIndex(`0,System.Boolean)">
      <summary>
            Finds the index of the key in the tree. If multiple items in the tree have
            compare equal to the key, finds the first or last one. 
            </summary>
      <param name="key">Key to search for.</param>
      <param name="findFirst">If true, find the first of duplicates, else finds the last of duplicates.</param>
      <returns>Index of the item found if the key was found, -1 if not found.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.GetItemByIndex(System.Int32)">
      <summary>
            Find the item at a particular index in the tree.
            </summary>
      <param name="index">The zero-based index of the item. Must be &gt;= 0 and &lt; Count.</param>
      <returns>The item at the particular index.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Insert(`0,Magnum.Collections.DuplicatePolicy,`0@)">
      <summary>
            Insert a new node into the tree, maintaining the red-black invariants.
            </summary>
      <remarks>Algorithm from Sedgewick, "Algorithms".</remarks>
      <param name="item">The new item to insert</param>
      <param name="dupPolicy">What to do if equal item is already present.</param>
      <param name="previous">If false, returned, the previous item.</param>
      <returns>false if duplicate exists, otherwise true.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Delete(`0,System.Boolean,`0@)">
      <summary>
            Deletes a key from the tree. If multiple elements are equal to key, 
            deletes the first or last. If no element is equal to the key, 
            returns false.
            </summary>
      <remarks>Top-down algorithm from Weiss. Basic plan is to move down in the tree, 
            rotating and recoloring along the way to always keep the current node red, which 
            ensures that the node we delete is red. The details are quite complex, however! </remarks>
      <param name="key">Key to delete.</param>
      <param name="deleteFirst">Which item to delete if multiple are equal to key. True to delete the first, false to delete last.</param>
      <param name="item">Returns the item that was deleted, if true returned.</param>
      <returns>True if an element was deleted, false if no element had 
            specified key.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Print">
      <summary>
            Prints out the tree.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Validate">
      <summary>
            Validates that the tree is correctly sorted, and meets the red-black tree 
            axioms.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.StopEnumerations">
      <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.GetNodeStack">
      <summary>
            Create an array of Nodes big enough for any path from top 
            to bottom. This is cached, and reused from call-to-call, so only one
            can be around at a time per tree.
            </summary>
      <returns>The node stack.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.CheckEnumerationStamp(System.Int32)">
      <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
      <param name="startStamp">changeStamp at the start of the enumeration.</param>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.InsertSplit(Magnum.Collections.RedBlackTree{`0}.Node,Magnum.Collections.RedBlackTree{`0}.Node,Magnum.Collections.RedBlackTree{`0}.Node,Magnum.Collections.RedBlackTree{`0}.Node,System.Boolean@)">
      <summary>
            Split a node with two red children (a 4-node in the 2-3-4 tree formalism), as
            part of an insert operation.
            </summary>
      <param name="ggparent">great grand-parent of "node", can be null near root</param>
      <param name="gparent">grand-parent of "node", can be null near root</param>
      <param name="parent">parent of "node", can be null near root</param>
      <param name="node">Node to split, can't be null</param>
      <param name="rotated">Indicates that rotation(s) occurred in the tree.</param>
      <returns>Node to continue searching from.</returns>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.Rotate(Magnum.Collections.RedBlackTree{`0}.Node,Magnum.Collections.RedBlackTree{`0}.Node,Magnum.Collections.RedBlackTree{`0}.Node)">
      <summary>
            Performs a rotation involving the node, it's child and grandchild. The counts of 
            childs and grand-child are set the correct values from their children; this is important
            if they have been adjusted on the way down the try as part of an insert/delete.
            </summary>
      <param name="node">Top node of the rotation. Can be null if child==root.</param>
      <param name="child">One child of "node". Not null.</param>
      <param name="gchild">One child of "child". Not null.</param>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.PrintSubTree(Magnum.Collections.RedBlackTree{`0}.Node,System.String,System.String)">
      <summary>
            Prints a sub-tree.
            </summary>
      <param name="node">Node to print from</param>
      <param name="prefixNode">Prefix for the node</param>
      <param name="prefixChildren">Prefix for the node's children</param>
    </member>
    <member name="M:Magnum.Collections.RedBlackTree`1.ValidateSubTree(Magnum.Collections.RedBlackTree{`0}.Node,System.Int32@)">
      <summary>
            Validates a sub-tree and returns the count and black height.
            </summary>
      <param name="node">Sub-tree to validate. May be null.</param>
      <param name="blackHeight">Returns the black height of the tree.</param>
      <returns>Returns the number of nodes in the sub-tree. 0 if node is null.</returns>
    </member>
    <member name="P:Magnum.Collections.RedBlackTree`1.ElementCount">
      <summary>
            Returns the number of elements in the tree.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Set`1">
      <summary>
             Set&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a haphazard, unpredictable order, and duplicate items are not allowed.
             </summary>
      <remarks>
        <p>The items are compared in one of two ways. If T implements IComparable&lt;T&gt; 
             then the Equals method of that interface will be used to compare items, otherwise the Equals
             method from Object will be used. Alternatively, an instance of IComparer&lt;T&gt; can be passed
             to the constructor to use to compare items.</p>
        <p>Set is implemented as a hash table. Inserting, deleting, and looking up an
             an element all are done in approximately constant time, regardless of the number of items in the Set.</p>
        <p>
          <see cref="T:Magnum.Collections.OrderedSet`1" /> is similar, but uses comparison instead of hashing, and does maintains
             the items in sorted order.</p>
      </remarks>
      <seealso cref="T:Magnum.Collections.OrderedSet`1" />
    </member>
    <member name="M:Magnum.Collections.Set`1.#ctor">
      <summary>
             Creates a new Set. The Equals method and GetHashCode method on T
             will be used to compare items for equality.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
    </member>
    <member name="M:Magnum.Collections.Set`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Set. The Equals and GetHashCode method of the passed comparer object
            will be used to compare items in this set.
            </summary>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new Set. The Equals method and GetHashCode method on T
             will be used to compare items for equality.
             </summary>
      <remarks>
             Items that are null are permitted.
            </remarks>
      <param name="collection">A collection with items to be placed into the Set.</param>
    </member>
    <member name="M:Magnum.Collections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Set. The Equals and GetHashCode method of the passed comparer object
            will be used to compare items in this set. The set is
            initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the Set.</param>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:Magnum.Collections.Set`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},Magnum.Collections.Hash{`0})">
      <summary>
            Creates a new Set given a comparer and a tree that contains the data. Used
            internally for Clone.
            </summary>
      <param name="equalityComparer">EqualityComparer for the set.</param>
      <param name="hash">Data for the set.</param>
    </member>
    <member name="M:Magnum.Collections.Set`1.Clone">
      <summary>
            Makes a shallow clone of this set; i.e., if items of the
            set are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the set takes time O(N), where N is the number of items in the set.</remarks>
      <returns>The cloned set.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.CloneContents">
      <summary>
            Makes a deep clone of this set. A new set is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the set takes time O(N), where N is the number of items in the set.</para>
      </remarks>
      <returns>The cloned set.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the set. 
            The items are enumerated in sorted order.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the set while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumerating all the items in the set takes time O(N), where N is the number
            of items in the set.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the Set.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.Contains(`0)">
      <summary>
            Determines if this set contains an item equal to <paramref name="item" />. The set
            is not changed.
            </summary>
      <remarks>Searching the set for an item takes approximately constant time, regardless of the number of items in the set.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.TryGetItem(`0,`0@)">
      <summary>
        <para>Determines if this set contains an item equal to <paramref name="item" />, according to the 
            comparison mechanism that was used when the set was created. The set
            is not changed.</para>
        <para>If the set does contain an item equal to <paramref name="item" />, then the item from the set is returned.</para>
      </summary>
      <remarks>Searching the set for an item takes approximately constant time, regardless of the number of items in the set.</remarks>
      <example>
            In the following example, the set contains strings which are compared in a case-insensitive manner. 
            <code>
            Set&lt;string&gt; set = new Set&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase);
            set.Add("HELLO");
            string s;
            bool b = set.TryGetItem("Hello", out s);   // b receives true, s receives "HELLO".
            </code></example>
      <param name="item">The item to search for.</param>
      <param name="foundItem">Returns the item from the set that was equal to <paramref name="item" />.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.Add(`0)">
      <summary>
            Adds a new item to the set. If the set already contains an item equal to
            <paramref name="item" />, that item is replaced with <paramref name="item" />.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding an item takes approximately constant time, regardless of the number of items in the set.</para>
      </remarks>
      <param name="item">The item to add to the set.</param>
      <returns>True if the set already contained an item equal to <paramref name="item" /> (which was replaced), false 
            otherwise.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the set. If the set already contains an item equal to
            one of the items in <paramref name="collection" />, that item will be replaced.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding the collection takes time O(M), where M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the set.</param>
    </member>
    <member name="M:Magnum.Collections.Set`1.Remove(`0)">
      <summary>
            Searches the set for an item equal to <paramref name="item" />, and if found,
            removes it from the set. If not found, the set is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing an item from the set takes approximately constant time, regardless of the size of the set.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the set.</returns>
    </member>
    <member name="M:Magnum.Collections.Set`1.Clear">
      <summary>
            Removes all items from the set.
            </summary>
      <remarks>Clearing the set takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:Magnum.Collections.Set`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the set. 
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing the collection takes time O(M), where M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the set.</param>
      <returns>The number of items removed from the set.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsSupersetOf(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is a superset of another set. Neither set is modified.
            This set is a superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            <remarks>IsSupersetOf is computed in time O(M), where M is the size of the 
            <paramref name="otherSet" />.</remarks></summary>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsProperSupersetOf(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is a proper superset of another set. Neither set is modified.
            This set is a proper superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            Additionally, this set must have strictly more items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsProperSubsetOf is computed in time O(M), where M is the size of
            <paramref name="otherSet" />.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsSubsetOf(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is a subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N), where N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsProperSubsetOf(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is a proper subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />. Additionally, this set must have strictly 
            fewer items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsProperSubsetOf is computed in time O(N), where N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsEqualTo(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is equal to another set. This set is equal to
            <paramref name="otherSet" /> if they contain the same items.
            </summary>
      <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this set.</remarks>
      <param name="otherSet">Set to compare to</param>
      <returns>True if this set is equal to <paramref name="otherSet" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IsDisjointFrom(Magnum.Collections.Set{`0})">
      <summary>
            Determines if this set is disjoint from another set. Two sets are disjoint
            if no item from one set is equal to any item in the other set.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to check disjointness with.</param>
      <returns>True if the two sets are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.UnionWith(Magnum.Collections.Set{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. This set receives
            the union of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.Union(Magnum.Collections.Set{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. A new set is 
            created with the union of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N), where M is the size of the 
            one set, and N is the size of the other set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <returns>The union of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.IntersectionWith(Magnum.Collections.Set{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. This set receives
            the intersection of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.Intersection(Magnum.Collections.Set{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. A new set is 
            created with the intersection of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <returns>The intersection of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.DifferenceWith(Magnum.Collections.Set{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. This set receives
            the difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.Difference(Magnum.Collections.Set{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. A new set is 
            created with the difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <returns>The difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.SymmetricDifferenceWith(Magnum.Collections.Set{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. This set receives
            the symmetric difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.SymmetricDifference(Magnum.Collections.Set{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. A new set is 
            created with the symmetric difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <returns>The symmetric difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:Magnum.Collections.Set`1.CheckConsistentComparison(Magnum.Collections.Set{`0})">
      <summary>
            Check that this set and another set were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
      <param name="otherSet">Other set to check comparision mechanism.</param>
      <exception cref="T:System.InvalidOperationException">If otherSet and this set don't use the same method for comparing items.</exception>
    </member>
    <member name="P:Magnum.Collections.Set`1.Comparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare items in this set. 
            </summary>
      <value>If the set was created using a comparer, that comparer is returned. Otherwise
            the default comparer for T (EqualityComparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:Magnum.Collections.Set`1.Count">
      <summary>
            Returns the number of items in the set.
            </summary>
      <remarks>The size of the set is returned in constant time.</remarks>
      <value>The number of items in the set.</value>
    </member>
    <member name="T:Magnum.Collections.Strings">
      <summary>
            A holder class for localizable strings that are used. Currently, these are not loaded from resources, but 
            just coded into this class. To make this library localizable, simply change this class to load the
            given strings from resources.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Triple`3">
      <summary>
            Stores a triple of objects within a single struct. This struct is useful to use as the
            T of a collection, or as the TKey or TValue of a dictionary.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Triple`3.firstComparer">
      <summary>
            Comparers for the first and second type that are used to compare
            values.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Triple`3.First">
      <summary>
            The first element of the triple.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Triple`3.Second">
      <summary>
            The second element of the triple.
            </summary>
    </member>
    <member name="F:Magnum.Collections.Triple`3.Third">
      <summary>
            The thrid element of the triple.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Triple`3.#ctor(`0,`1,`2)">
      <summary>
            Creates a new triple with given elements.
            </summary>
      <param name="first">The first element of the triple.</param>
      <param name="second">The second element of the triple.</param>
      <param name="third">The third element of the triple.</param>
    </member>
    <member name="M:Magnum.Collections.Triple`3.CompareTo(Magnum.Collections.Triple{`0,`1,`2})">
      <summary>
        <para> Compares this triple to another triple of the some type. The triples are compared by using
            the IComparable&lt;T&gt; or IComparable interface on TFirst, TSecond, and TThird. The triples
            are compared by their first elements first, if their first elements are equal, then they
            are compared by their second elements. If their second elements are also equal, then they
            are compared by their third elements.</para>
        <para>If TFirst, TSecond, or TThird does not implement IComparable&lt;T&gt; or IComparable, then
            an NotSupportedException is thrown, because the triples cannot be compared.</para>
      </summary>
      <param name="other">The triple to compare to.</param>
      <returns>An integer indicating how this triple compares to <paramref name="other" />. Less
            than zero indicates this triple is less than <paramref name="other" />. Zero indicate this triple is
            equals to <paramref name="other" />. Greater than zero indicates this triple is greater than
            <paramref name="other" />.</returns>
      <exception cref="T:System.NotSupportedException">Either FirstSecond, TSecond, or TThird is not comparable
            via the IComparable&lt;T&gt; or IComparable interfaces.</exception>
    </member>
    <member name="M:Magnum.Collections.Triple`3.Equals(System.Object)">
      <summary>
            Determines if this triple is equal to another object. The triple is equal to another object 
            if that object is a Triple, all element types are the same, and the all three elements
            compare equal using object.Equals.
            </summary>
      <param name="obj">Object to compare for equality.</param>
      <returns>True if the objects are equal. False if the objects are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Triple`3.Equals(Magnum.Collections.Triple{`0,`1,`2})">
      <summary>
            Determines if this triple is equal to another triple. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="other">Triple to compare with for equality.</param>
      <returns>True if the triples are equal. False if the triples are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Triple`3.GetHashCode">
      <summary>
            Returns a hash code for the triple, suitable for use in a hash-table or other hashed collection.
            Two triples that compare equal (using Equals) will have the same hash code. The hash code for
            the triple is derived by combining the hash codes for each of the two elements of the triple.
            </summary>
      <returns>The hash code.</returns>
    </member>
    <member name="M:Magnum.Collections.Triple`3.ToString">
      <summary>
            Returns a string representation of the triple. The string representation of the triple is
            of the form:
            <c>First: {0}, Second: {1}, Third: {2}</c>
            where {0} is the result of First.ToString(), {1} is the result of Second.ToString(), and
            {2} is the result of Third.ToString() (or "null" if they are null.)
            </summary>
      <returns> The string representation of the triple.</returns>
    </member>
    <member name="M:Magnum.Collections.Triple`3.op_Equality(Magnum.Collections.Triple{`0,`1,`2},Magnum.Collections.Triple{`0,`1,`2})">
      <summary>
            Determines if two triples are equal. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First triple to compare.</param>
      <param name="pair2">Second triple to compare.</param>
      <returns>True if the triples are equal. False if the triples are not equal.</returns>
    </member>
    <member name="M:Magnum.Collections.Triple`3.op_Inequality(Magnum.Collections.Triple{`0,`1,`2},Magnum.Collections.Triple{`0,`1,`2})">
      <summary>
            Determines if two triples are not equal. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First triple to compare.</param>
      <param name="pair2">Second triple to compare.</param>
      <returns>True if the triples are not equal. False if the triples are equal.</returns>
    </member>
    <member name="T:Magnum.Collections.Util">
      <summary>
            A holder class for various internal utility functions that need to be shared.
            </summary>
    </member>
    <member name="T:Magnum.Collections.Util.WrapEnumerable`1">
      <summary>
            Wrap an enumerable so that clients can't get to the underlying 
            implementation via a down-cast.
            </summary>
    </member>
    <member name="M:Magnum.Collections.Util.WrapEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Create the wrapper around an enumerable.
            </summary>
      <param name="wrapped">IEnumerable to wrap.</param>
    </member>
    <member name="M:Magnum.Collections.Util.IsCloneableType(System.Type,System.Boolean@)">
      <summary>
            Determine if a type is cloneable: either a value type or implementing
            ICloneable.
            </summary>
      <param name="type">Type to check.</param>
      <param name="isValue">Returns if the type is a value type, and does not implement ICloneable.</param>
      <returns>True if the type is cloneable.</returns>
    </member>
    <member name="M:Magnum.Collections.Util.SimpleClassName(System.Type)">
      <summary>
            Returns the simple name of the class, for use in exception messages. 
            </summary>
      <returns>The simple name of this class.</returns>
    </member>
    <member name="M:Magnum.Collections.Util.CreateEnumerableWrapper``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Wrap an enumerable so that clients can't get to the underlying
            implementation via a down-case
            </summary>
      <param name="wrapped">Enumerable to wrap.</param>
      <returns>A wrapper around the enumerable.</returns>
    </member>
    <member name="M:Magnum.Collections.Util.GetHashCode``1(``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Gets the hash code for an object using a comparer. Correctly handles
            null.
            </summary>
      <param name="item">Item to get hash code for. Can be null.</param>
      <param name="equalityComparer">The comparer to use.</param>
      <returns>The hash code for the item.</returns>
    </member>
    <member name="T:Magnum.CommandLineParser.CommandLine">
      <summary>
            Tools for parsing the command line
            </summary>
    </member>
    <member name="M:Magnum.CommandLineParser.CommandLine.GetUnparsedCommandLine">
      <summary>
            Gets the command line from the Environment.CommandLine, removing the application name if present
            </summary>
      <returns>The complete, unparsed command line that was specified when the program was executed</returns>
    </member>
    <member name="M:Magnum.CommandLineParser.CommandLine.Parse">
      <summary>
            Parses the command line
            </summary>
      <returns>The command line elements that were found</returns>
    </member>
    <member name="M:Magnum.CommandLineParser.CommandLine.Parse(System.String)">
      <summary>
            Parses the command line
            </summary>
      <param name="commandLine">The command line to parse</param>
      <returns>The command line elements that were found</returns>
    </member>
    <member name="M:Magnum.CommandLineParser.CommandLine.Parse``1(System.String,System.Action{Magnum.CommandLineParser.ICommandLineElementParser{``0}})">
      <summary>
            Parses the command line and matches any specified patterns
            </summary>
      <typeparam name="T">The output type of the parser</typeparam>
      <param name="commandLine">The command line text</param>
      <param name="initializer">Used by the caller to add patterns and object generators</param>
      <returns>The elements that were found on the command line</returns>
    </member>
    <member name="T:Magnum.CommandLineParser.ICommandLineElementParser`1">
      <summary>
            Used to configure the command line element parser
            </summary>
      <typeparam name="TResult">The type of object returned as a result of the parse</typeparam>
    </member>
    <member name="M:Magnum.CommandLineParser.ICommandLineElementParser`1.Add(Magnum.Monads.Parser.Parser{System.Collections.Generic.IEnumerable{Magnum.CommandLineParser.ICommandLineElement},`0})">
      <summary>
            Adds a new pattern to the parser
            </summary>
      <param name="parser">The pattern to match and return the resulting object</param>
    </member>
    <member name="T:Magnum.Data.IUnitOfWork">
      <summary>
            An interface to resolve from the container to encapsulate a unit of work
            </summary>
    </member>
    <member name="M:Magnum.Data.IUnitOfWork.BeginTransaction">
      <summary>
            Begins a transaction for the data source
            </summary>
      <returns>The transaction instance that was created</returns>
    </member>
    <member name="M:Magnum.Data.IUnitOfWork.BeginTransaction(System.Data.IsolationLevel)">
      <summary>
            Begins a transaction for the data source
            </summary>
      <param name="isolationLevel">The isolation level to use for the transaction</param>
      <returns>The transaction instance that was created</returns>
    </member>
    <member name="M:Magnum.Data.IUnitOfWork.Flush">
      <summary>
            Flush any changes made outside of a transaction
            </summary>
    </member>
    <member name="M:Magnum.Data.IUnitOfWork.Commit">
      <summary>
            Commit any changes made inside of a transaction
            </summary>
    </member>
    <member name="M:Magnum.Data.IUnitOfWork.Commit(System.Data.IsolationLevel)">
      <summary>
            Commit any changes made inside of a transaction using the isolation level specified
            </summary>
      <param name="isolationLevel">
      </param>
    </member>
    <member name="P:Magnum.Data.IUnitOfWork.IsInTransaction">
      <summary>
            True if the <see cref="T:Magnum.Data.UnitOfWork" /> is currently inside of a transaction
            </summary>
    </member>
    <member name="T:Magnum.Data.UnitOfWork">
      <summary>
            This is really just a facade around the <see cref="T:Magnum.LocalContext" /> storage
            </summary>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToAttributes.GetAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
            Returns the first attribute of the specified type for the object specified
            </summary>
      <typeparam name="T">The type of attribute</typeparam>
      <param name="provider">An attribute provider, which can be a MethodInfo, PropertyInfo, Type, etc.</param>
      <returns>The attribute instance if found, or null</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToAttributes.HasAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
            Determines if the target has the specified attribute
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="provider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToAttributes.ForAttributesOf``1(System.Reflection.ICustomAttributeProvider,System.Action{``0})">
      <summary>
            Calls the provided action for each instance of the specified attribute type for the object specified
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="provider">
      </param>
      <param name="action">
      </param>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDateTime.FromNow(System.TimeSpan)">
      <summary>
            Gets the current DateTime and adjusts it by the specified TimeSpan
            </summary>
      <param name="span">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDateTime.ToUnixTimestamp(System.DateTime)">
      <summary>
            Gets a Unix Timestamp from a DateTime, converting local time to UTC if necessary.
            </summary>
      <param name="date">The date to convert</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDictionary.Retrieve``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
      <summary>
            Gets the value for the specified key or adds a new value to the dictionary
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDictionary.Retrieve``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Gets the value for the specified key or adds a new value to the dictionary
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <param name="missingValue">The value to add if the key is not found</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDictionary.Retrieve``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
      <summary>
            Gets the value for the specified key or adds a new value to the dictionary
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <param name="valueProvider">The function to return the value to add if the key is not found</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDictionary.StrongGet``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
      <summary>
            Converts an object to the strongly typed version of a dictionary
            </summary>
      <typeparam name="TResult">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToDisposable.AutoDispose``1(``0)">
      <summary>
            Wraps an object that implements IDisposable in an enumeration to make it safe for use in LINQ expressions
            </summary>
      <typeparam name="T">The type of the object, which must implement IDisposable</typeparam>
      <param name="target">The target to wrap</param>
      <returns>An enumeration with a single entry equal to the target</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToEnumerable.Each``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Enumerates a collection, calling the specified action for each entry in the collection
            </summary>
      <typeparam name="T">The type of the enumeration</typeparam>
      <param name="collection">The collection to enumerate</param>
      <param name="callback">The action to call for each entry in the collection</param>
      <returns>The collection that was enumerated</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToEnumerable.WhileTrue``1(System.Collections.IEnumerable,System.Func{``0,System.Boolean})">
      <summary>
            Enumerates a collection, calling the callback until false is returned
            </summary>
      <typeparam name="T">The type of item being enumerated</typeparam>
      <param name="collection">The collection to enumerate</param>
      <param name="callback">The callback to call for each element</param>
      <returns>True if all of the elements were enumerated, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToEventHandler.Raise``1(System.EventHandler{``0},System.Object,``0)">
      <summary>
            thanks, http://kohari.org/2009/02/07/eventhandler-extension-method/
            </summary>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToExpression.MemberName``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Gets the name of the member specified
            </summary>
      <typeparam name="T">The type referenced</typeparam>
      <typeparam name="TMember">The type of the member referenced</typeparam>
      <param name="expression">The expression referencing the member</param>
      <returns>The name of the member referenced by the expression</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToExpression.MemberName``1(System.Linq.Expressions.Expression{System.Action{``0}})">
      <summary>
            Gets the name of the member specified
            </summary>
      <typeparam name="T">The type referenced</typeparam>
      <param name="expression">The expression referencing the member</param>
      <returns>The name of the member referenced by the expression</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToExpression.MemberName``2(System.Linq.Expressions.Expression{System.Action{``0,``1}})">
      <summary>
            Gets the name of the member specified
            </summary>
      <typeparam name="T1">The type referenced</typeparam>
      <typeparam name="T2">The type of the member referenced</typeparam>
      <param name="expression">The expression referencing the member</param>
      <returns>The name of the member referenced by the expression</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToExpression.WrapActionWithArgument``1(System.Linq.Expressions.Expression{System.Action})">
      <summary>
            Wraps an action expression with no arguments inside an expression that takes an 
            argument of the specified type (the argument is ignored, but the original expression is
            invoked)
            </summary>
      <typeparam name="TArgument">The type of argument to accept in the wrapping expression</typeparam>
      <param name="expression">The expression to wrap</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.Implements``1(System.Object)">
      <summary>
              Checks if an object implements the specified interface
            </summary>
      <typeparam name="T">The interface type</typeparam>
      <param name="obj">The object to check</param>
      <returns>True if the interface is implemented by the object, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.Implements(System.Object,System.Type)">
      <summary>
              Checks if an object implements the specified interface
            </summary>
      <param name="obj">The object to check</param>
      <param name="interfaceType">The interface type (can be generic, either specific or open)</param>
      <returns>True if the interface is implemented by the object, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.Implements``1(System.Type)">
      <summary>
              Checks if a type implements the specified interface
            </summary>
      <typeparam name="T">The interface type (can be generic, either specific or open)</typeparam>
      <param name="objectType">The type to check</param>
      <returns>True if the interface is implemented by the type, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.Implements(System.Type,System.Type)">
      <summary>
              Checks if a type implements the specified interface
            </summary>
      <param name="objectType">The type to check</param>
      <param name="interfaceType">The interface type (can be generic, either specific or open)</param>
      <returns>True if the interface is implemented by the type, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.ImplementsGeneric(System.Type,System.Type)">
      <summary>
              Checks if a type implements an open generic at any level of the inheritance chain, including all
              base classes
            </summary>
      <param name="objectType">The type to check</param>
      <param name="interfaceType">The interface type (must be a generic type definition)</param>
      <returns>True if the interface is implemented by the type, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToInterfaces.ImplementsGeneric(System.Type,System.Type,System.Type@)">
      <summary>
              Checks if a type implements an open generic at any level of the inheritance chain, including all
              base classes
            </summary>
      <param name="objectType">The type to check</param>
      <param name="interfaceType">The interface type (must be a generic type definition)</param>
      <param name="matchedType">The matching type that was found for the interface type</param>
      <returns>True if the interface is implemented by the type, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToObject.ValueOrDefault``2(``0,System.Func{``0,``1},``1)">
      <summary>
            Returns the value of the instance member, or the default value if the instance is null
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="instance">
      </param>
      <param name="accessor">
      </param>
      <param name="defaultValue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToString.IsNotEmpty(System.String)">
      <summary>
            Checks if a string is not null or empty
            </summary>
      <param name="value">A string instance</param>
      <returns>True if the string has a value</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToString.IsEmpty(System.String)">
      <summary>
            Check if a string is null or empty
            </summary>
      <param name="value">A string instance</param>
      <returns>True if the string is null or empty, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToString.IsNull(System.String)">
      <summary>
            Returns true if a string is null (the string can, however, be empty)
            </summary>
      <param name="value">A string value</param>
      <returns>True if the string value is null, otherwise false</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToString.FormatWith(System.String,System.Object[])">
      <summary>
            Uses the string as a template and applies the specified arguments
            </summary>
      <param name="format">The format string</param>
      <param name="args">The arguments to pass to the format provider</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToString.ToUtf8String(System.Byte[])">
      <summary>
            Returns the UTF-8 encoded string from the specified byte array
            </summary>
      <param name="data">The byte array</param>
      <returns>The UTF-8 string</returns>
    </member>
    <member name="T:Magnum.FileSystem.FileSystemEventProducer">
      <summary>
            Wraps a FileSystemWatcher as an event producer that sends file system events to the
            specified channel
            </summary>
    </member>
    <member name="M:Magnum.FileSystem.FileSystemEventProducer.#ctor(System.String,Magnum.Channels.UntypedChannel)">
      <summary>
            Creates a FileSystemEventProducer
            </summary>
      <param name="directory">The directory to watch</param>
      <param name="channel">The channel where events should be sent</param>
    </member>
    <member name="M:Magnum.FileSystem.FileSystemEventProducer.#ctor(System.String,Magnum.Channels.UntypedChannel,System.Boolean)">
      <summary>
            Creates a FileSystemEventProducer
            </summary>
      <param name="directory">The directory to watch</param>
      <param name="channel">The channel where events should be sent</param>
      <param name="checkSubDirectory">Indicates if subdirectories will be included</param>
    </member>
    <member name="M:Magnum.FileSystem.PollingFileSystemEventProducer.#ctor(System.String,Magnum.Channels.UntypedChannel,Magnum.Fibers.Scheduler,Magnum.Fibers.Fiber,System.TimeSpan)">
      <summary>
            Creates a PollingFileSystemEventProducer
            </summary>
      <param name="directory">The directory to watch</param>
      <param name="channel">The channel where events should be sent</param>
      <param name="scheduler">Event scheduler</param>
      <param name="fiber">Fiber to schedule on</param>
      <param name="checkInterval">The maximal time between events or polls on a given file</param>
    </member>
    <member name="M:Magnum.FileSystem.PollingFileSystemEventProducer.#ctor(System.String,Magnum.Channels.UntypedChannel,Magnum.Fibers.Scheduler,Magnum.Fibers.Fiber,System.TimeSpan,System.Boolean)">
      <summary>
            Creates a PollingFileSystemEventProducer
            </summary>
      <param name="directory">The directory to watch</param>
      <param name="channel">The channel where events should be sent</param>
      <param name="scheduler">Event scheduler</param>
      <param name="fiber">Fiber to schedule on</param>
      <param name="checkInterval">The maximal time between events or polls on a given file</param>
      <param name="checkSubDirectory">Indicates if subdirectorys will be checked or ignored</param>
    </member>
    <member name="T:Magnum.Logging.LogWriter">
      <summary>
            These are only provided in the action syntax since it can be inefficient to generate
            the format string if the log level is not set to a level that will allow the output
            to be generated.
            </summary>
    </member>
    <member name="T:Magnum.Logging.Internal.LogMessageLogger">
      <summary>
            Abstract base class which provides most logging method
            overloads for an <see cref="T:Magnum.Logging.ILogger" /> implementation.
            </summary>
    </member>
    <member name="T:Magnum.Serialization.Serializer">
      <summary>
            Serializers convert objects to some type of string output
            </summary>
    </member>
    <member name="M:Magnum.Serialization.Serializer.Serialize``1(``0,System.IO.TextWriter)">
      <summary>
            Serialize an object to the specified TextWriter
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="obj">
      </param>
      <param name="writer">
      </param>
    </member>
    <member name="M:Magnum.Serialization.Serializer.Serialize``1(``0)">
      <summary>
            Serialize an object and return the string representing the object data
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Serialization.Serializer.Deserialize``1(System.String)">
      <summary>
            Deserialize an object from a string
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="text">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Serialization.Serializer.Deserialize``1(System.IO.TextReader)">
      <summary>
            Deserialize an object from a TextReader
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="reader">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Reflection.SafeProperty">
      <summary>
            Use to safely set a property on an object, including the expansion of any lists as necessary
            and creation of reference properties. May not be suitable to all situations, but works great
            for deserializing data into an empty object graph.
            </summary>
    </member>
    <member name="M:Magnum.ILocalContext.Store``1(``0)">
      <summary>
            Stores the value using a <see cref="T:Magnum.Context.TypedKey`1" /> for the key
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="value">
      </param>
    </member>
    <member name="T:Magnum.LocalContext">
      <summary>
            Supports the storage of context information through the life of a thread
            </summary>
    </member>
    <member name="P:Magnum.LocalContext.Current">
      <summary>
            Gets the current data
            </summary>
      <value>The data.</value>
    </member>
    <member name="P:Magnum.LocalContext.RunningInWeb">
      <summary>
            Gets a value indicating whether running in the web context
            </summary>
      <value>
        <c>true</c> if [running in web]; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Magnum.Metrics.IMonitor">
      <summary>
            Standard interface supported by all monitors
            </summary>
    </member>
    <member name="P:Magnum.Metrics.IMonitor.OwnerType">
      <summary>
            The type that owns this monitor
            </summary>
    </member>
    <member name="P:Magnum.Metrics.IMonitor.Name">
      <summary>
            The name of the monitor
            </summary>
    </member>
    <member name="T:Magnum.Pipeline.InterceptionBinder">
      <summary>
            Inserts a segment into the pipeline as an inline filter
            </summary>
    </member>
    <member name="T:Magnum.Pipeline.ISubscriptionScope">
      <summary>
            Provides an interface for adding consumers and interceptors to the pipeline
            </summary>
    </member>
    <member name="M:Magnum.Pipeline.ISubscriptionScope.Subscribe``1(Magnum.Pipeline.MessageConsumer{``0})">
      <summary>
            Subscribes the message consumer to the pipeline. Can accept any method that matches the delegate
            syntax, including anonymous/lambda methods
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="consumer">The method that will consume the message</param>
    </member>
    <member name="M:Magnum.Pipeline.ISubscriptionScope.Subscribe``1(``0)">
      <summary>
            Subscribes an instance of a class to the pipeline. Consumer interfaces that are implemented by the 
            object will be wired up to the pipeline with the appropriate message type
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="consumer">
      </param>
    </member>
    <member name="M:Magnum.Pipeline.ISubscriptionScope.Subscribe``1(System.Func{``0})">
      <summary>
            Subscribes a type to the pipeline. When a message is delivered to the pipeline, the getConsumer function
            is called to get an instance of the consumer to which the message is delivered.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="getConsumer">
      </param>
    </member>
    <member name="M:Magnum.Pipeline.ISubscriptionScope.Subscribe``1(System.TimeSpan,Magnum.Pipeline.MessageConsumer{System.Collections.Generic.IList{``0}})">
      <summary>
            Subscribes a type to the pipeline. When messages are delivered to the pipeline, they are collected
            until the interval timer expires and delivered as a single list to the consumer.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="interval">
      </param>
      <param name="consumer">
      </param>
    </member>
    <member name="M:Magnum.Pipeline.ISubscriptionScope.Intercept``1(System.Action{Magnum.Pipeline.IInterceptorConfigurator{``0}})">
      <summary>
            Registers an interceptor on the pipeline, allowing actions to be performed before and after messages
            are delivered on the pipeline.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="configureAction">The block containing the configuration calls for the interceptor</param>
    </member>
    <member name="T:Magnum.Pipeline.Roles.ISubscriberEvent">
      <summary>
            A marker interface to define the role of the message (nod to Udi)
            </summary>
    </member>
    <member name="T:Magnum.Pipeline.Pipe">
      <summary>
            A pipeline is used for the delivery of messages (which are really just objects of any type)
            </summary>
    </member>
    <member name="M:Magnum.Pipeline.Pipe.Send``1(``0)">
      <summary>
            Sends a message through the pipe
            </summary>
      <typeparam name="T">Captures the generic type of the message</typeparam>
      <param name="message">The message to send</param>
    </member>
    <member name="M:Magnum.Pipeline.Pipe.Accept``1(``0)">
      <summary>
            Returns an enumeration of consumers that are interested in the message
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="message">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Magnum.Pipeline.Pipe.SegmentType">
      <summary>
            The type of this pipeline node
            </summary>
    </member>
    <member name="P:Magnum.Pipeline.Pipe.MessageType">
      <summary>
            The type accepted by this segment
            </summary>
    </member>
    <member name="T:Magnum.Collections.Empty`1">
      <summary>
            Used to provide empty collections for generic types
            </summary>
      <typeparam name="T">Type of elements in the collection</typeparam>
    </member>
    <member name="T:Magnum.Serialization.TypeSerializerCacheImpl">
      <summary>
              Wraps the cache for TypeSerializer implementations
            </summary>
    </member>
    <member name="T:Magnum.Serialization.TypeSerializerLoader">
      <summary>
              Scans the assembly for implementations of the TypeSerializer interface for 
              the built-in types
            </summary>
    </member>
    <member name="T:Magnum.Servers.ConnectionContext">
      <summary>
            Abstracts a connection from the underlying transport implementation
            </summary>
    </member>
    <member name="M:Magnum.Servers.ConnectionContext.Complete">
      <summary>
            Completes the response for this connection
            </summary>
    </member>
    <member name="M:Magnum.Servers.ConnectionContext.SetResponseFilter(System.Func{System.IO.Stream,System.IO.Stream})">
      <summary>
            Wraps the response stream (for compression, encryption, etc.)
            </summary>
      <param name="responseFilter">A method to apply a filter to the connection</param>
    </member>
    <member name="P:Magnum.Servers.ConnectionContext.Request">
      <summary>
            The request submitted for the connection
            </summary>
    </member>
    <member name="P:Magnum.Servers.ConnectionContext.Response">
      <summary>
            The response for the connection
            </summary>
    </member>
    <member name="P:Magnum.Servers.ConnectionContext.User">
      <summary>
            The user context under which the connection was established
            </summary>
    </member>
    <member name="P:Magnum.Servers.ConnectionContext.Server">
      <summary>
            The server context
            </summary>
    </member>
    <member name="T:Magnum.Servers.PatternMatchConnectionHandler">
      <summary>
            A connection handler returns an appropriate channel to handle the connection
            based on a URI mapping and a set of accepted verbs
            </summary>
    </member>
    <member name="M:Magnum.Servers.ExtensionsToConnectionContext.WriteObject(Magnum.Servers.ConnectionContext,System.Object)">
      <summary>
            Writes the object as a JSON response if the request is an Ajax request, otherwise the
            response is wrapped in an HTML text area for displaying to the user.
            </summary>
      <param name="obj">
      </param>
    </member>
    <member name="M:Magnum.Servers.ExtensionsToConnectionContext.SetStatusToBadRequest(Magnum.Servers.ConnectionContext)">
      <summary>
            400 - Bad Request
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="M:Magnum.Servers.ExtensionsToConnectionContext.SetStatusToUnauthorized(Magnum.Servers.ConnectionContext)">
      <summary>
            401 - Not Authorized
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="T:Magnum.Servers.Internal.BadRequestConnectionHandler">
      <summary>
            Handles a connection inside of a channel, allowing handlers to be injected
            along the channel network to handle things like authentication and ultimately
            routing
            </summary>
    </member>
    <member name="T:Magnum.Servers.Internal.HttpConnectionChannelProvider">
      <summary>
            Returns a channel to process the request, mapping the request Uri to the
            channel implementation that support the specified URI.
            </summary>
    </member>
    <member name="T:Magnum.Servers.RequestContext">
      <summary>
            Wraps a request, including the Url, Headers, and any QueryString parameters
            </summary>
    </member>
    <member name="P:Magnum.Servers.RequestContext.Headers">
      <summary>
            The headers submitted as part of the request
            </summary>
    </member>
    <member name="P:Magnum.Servers.RequestContext.InputStream">
      <summary>
            The input stream to read the request contents
            </summary>
    </member>
    <member name="P:Magnum.Servers.RequestContext.QueryString">
      <summary>
            The query string arguments that were included with the request
            </summary>
    </member>
    <member name="P:Magnum.Servers.RequestContext.HttpMethod">
      <summary>
            The method (GET,PUT,etc.)
            </summary>
    </member>
    <member name="P:Magnum.Servers.RequestContext.Url">
      <summary>
            The URL specified for the request
            </summary>
    </member>
    <member name="P:Magnum.Servers.RequestContext.RawUrl">
      <summary>
            The raw URL specified
            </summary>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.RaiseEvent(Magnum.StateMachine.Event)">
      <summary>
            Send an event within the current state
            </summary>
      <param name="raised">The event to raise</param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.RaiseEvent``1(Magnum.StateMachine.Event,``0)">
      <summary>
            Send an event within the current state passing the data associated with the event
            </summary>
      <typeparam name="TData">The type of data, must match the data type expected by the event</typeparam>
      <param name="raised">The event to raise</param>
      <param name="value">The data to associate with the event</param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.Define(System.Action)">
      <summary>
            This must be called from the static constructor to define the states, events, and transitions
            
            This is performed as an expression because the base static class needs to perform setup
            before actually defining the state machine and derived classes don't call static base class 
            constructors
            </summary>
      <param name="definition">An expression to invoke to setup the state machine</param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.SetCompletedState(Magnum.StateMachine.State)">
      <summary>
            Sets the state to use for a completed state machine. By default, the state named "Completed" is used.
            </summary>
      <param name="completedState">
      </param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.SetInitialState(Magnum.StateMachine.State)">
      <summary>
            Sets the state to use for a newly created state machine. By default, the state named "Initial" is used.
            </summary>
      <param name="initialState">
      </param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.When(Magnum.StateMachine.Event)">
      <summary>
            Defines an actions to take when an event is raised within a state
            </summary>
      <param name="raised">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.When``1(Magnum.StateMachine.Event{``0})">
      <summary>
            Starts the definition of actions to take when an event occurs
            </summary>
      <param name="raised">The event that would be raised</param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.InCaseOf``1">
      <summary>
            Defines an action to take if an exception occurs while the event is being handled
            </summary>
      <typeparam name="TException">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.Initially(Magnum.StateMachine.StateEventAction{`0}[])">
      <summary>
            Opens the definition of the event actions for the initial state (shortcut for During(Initial))
            </summary>
      <param name="actions">
      </param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.During(Magnum.StateMachine.State,Magnum.StateMachine.StateEventAction{`0}[])">
      <summary>
            Opens the definition of the event actions for the specified state
            </summary>
      <param name="inputState">
      </param>
      <param name="actions">
      </param>
    </member>
    <member name="M:Magnum.StateMachine.StateMachine`1.Anytime(Magnum.StateMachine.StateEventAction{`0}[])">
      <summary>
            Starts the definition of actions to take when events occur during any state
            </summary>
      <param name="actions">
      </param>
    </member>
    <member name="P:Magnum.StateMachine.StateMachine`1.CurrentState">
      <summary>
            Returns the current state of the StateMachine
            </summary>
    </member>
    <member name="T:Magnum.Servers.HttpServer">
      <summary>
            An HttpServer that can be used to asynchronously process HTTP/HTTPS requests from
            within the application.
            </summary>
    </member>
    <member name="T:Magnum.Servers.SocketServer">
      <summary>
            SocketServer listens on the specified address and dispatches connections
            as they arrive to separate connection objects with their own fibers
            </summary>
    </member>
    <member name="T:Magnum.Servers.ValueProviders.ConnectionContextValueProvider">
      <summary>
              Maps access to the RequestContext for model binding
            </summary>
    </member>
    <member name="T:Magnum.StateMachine.Event">
      <summary>
            A basic event
            </summary>
    </member>
    <member name="T:Magnum.StateMachine.BasicEvent`1">
      <summary>
            A basic event that is raised without any additional data
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.StateMachine.BasicEventAction`1.Complete">
      <summary>
            Shortcut for TransitionTo(Completed)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.StateMachine.ChannelConfiguration.CacheChannelProvider`2">
      <summary>
            Gets an instance of a class from the InstanceProvider and returns the channel
            from that class
            </summary>
      <typeparam name="TChannel">The channel type</typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="T:Magnum.Channels.InstanceChannelPolicy`2">
      <summary>
            Defines the instance policy for a regarding a particular event
            </summary>
      <typeparam name="T">The state machine type</typeparam>
      <typeparam name="TChannel">The channel type</typeparam>
    </member>
    <member name="M:Magnum.Channels.InstanceChannelPolicy`2.CanCreateInstance(`1,`0@)">
      <summary>
            Returns true if the message can create a new instance
            </summary>
      <param name="message">The message received</param>
      <param name="instance">The instance created</param>
      <returns>True if the new instance could be created</returns>
    </member>
    <member name="M:Magnum.Channels.InstanceChannelPolicy`2.IsHandledByExistingInstance(`1)">
      <summary>
            Checks if the message can be handled by an existing instance
            </summary>
      <param name="message">The message received</param>
      <returns>True if the message should be delivered to the instance, otherwise false</returns>
    </member>
    <member name="M:Magnum.Channels.InstanceChannelPolicy`2.WasNotHandled(`1)">
      <summary>
            Called when a message was not handled by an instance
            </summary>
      <param name="message">The message that was not handled</param>
    </member>
    <member name="M:Magnum.Channels.InstanceChannelPolicy`2.CanUnloadInstance(`0)">
      <summary>
            Checks if an instance can be unloaded
            </summary>
      <param name="instance">The instance to check</param>
      <returns>True if the instance can be unloaded from memory</returns>
    </member>
    <member name="M:Magnum.Channels.InstanceChannelPolicy`2.CanRemoveInstance(`0)">
      <summary>
            Checks if an instance can be removed/destroyed
            </summary>
      <param name="instance">The instance to check</param>
      <returns>True if the instance can be removed from storage</returns>
    </member>
    <member name="T:Magnum.StateMachine.EventCombiner`1">
      <summary>
            A combined event is raised automatically after all of the combined events have been raised
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Magnum.StateMachine.Event`1">
      <summary>
            An event with associated data
            </summary>
      <typeparam name="V">
      </typeparam>
    </member>
    <member name="T:Magnum.StateMachine.DataEvent`2">
      <summary>
            An event that has a typed data structure associated with it
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="V">
      </typeparam>
    </member>
    <member name="M:Magnum.StateMachine.DataEventAction`2.Complete">
      <summary>
            Shortcut for TransitionTo(Completed)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.StateMachine.ExceptionAction`2.Complete">
      <summary>
            Shortcut for TransitionTo(Completed)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Data.IRepositoryFactory">
      <summary>
            Supports the creation of repository instances that should be disposed once they are used
            </summary>
    </member>
    <member name="M:Magnum.Data.IRepositoryFactory.GetRepository">
      <summary>
            Returns an untyped repository that can be used for any class stored in the database
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Data.IRepositoryFactory.GetRepository``1">
      <summary>
            Returns a typed repository that can be used and queried (using LINQ)
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Range`1">
      <summary>
            Represents a range of enumerable items
            </summary>
      <typeparam name="T">The type of range</typeparam>
    </member>
    <member name="M:Magnum.Range`1.#ctor(`0,`0,System.Boolean,System.Boolean)">
      <summary>
            Initializes a new Range
            </summary>
      <param name="lowerBound">The lower bound of the range</param>
      <param name="upperBound">The upper bound of the range</param>
      <param name="includeLowerBound">If the lower bound should be included</param>
      <param name="includeUpperBound">If the upper bound should be included</param>
    </member>
    <member name="M:Magnum.Range`1.#ctor(`0,`0,System.Boolean,System.Boolean,System.Collections.Generic.IComparer{`0})">
      <summary>
            Initializes a new Range
            </summary>
      <param name="lowerBound">The lower bound of the range</param>
      <param name="upperBound">The upper bound of the range</param>
      <param name="includeLowerBound">If the lower bound should be included</param>
      <param name="includeUpperBound">If the upper bound should be included</param>
      <param name="comparer">The comparison to use for the range elements</param>
    </member>
    <member name="M:Magnum.Range`1.Contains(`0)">
      <summary>
            Determines if the value specified is contained within the range
            </summary>
      <param name="value">The value to check</param>
      <returns>Returns true if the value is contained within the range, otherwise false</returns>
    </member>
    <member name="M:Magnum.Range`1.Forward(System.Func{`0,`0})">
      <summary>
            Returns a forward enumerator for the range
            </summary>
      <param name="step">A function used to step through the range</param>
      <returns>An enumerator for the range</returns>
    </member>
    <member name="P:Magnum.Range`1.LowerBound">
      <summary>
            The lower bound of the range
            </summary>
    </member>
    <member name="P:Magnum.Range`1.UpperBound">
      <summary>
            The upper bound of the range
            </summary>
    </member>
    <member name="P:Magnum.Range`1.Comparer">
      <summary>
            The comparison used for the elements in the range
            </summary>
    </member>
    <member name="P:Magnum.Range`1.IncludeLowerBound">
      <summary>
            If the lower bound is included in the range
            </summary>
    </member>
    <member name="P:Magnum.Range`1.IncludeUpperBound">
      <summary>
            If the upper bound is included in the range
            </summary>
    </member>
    <member name="M:Magnum.RangeBuilder`1.Through(`0)">
      <summary>
            Specifies the upper bound for the range
            </summary>
      <param name="upperBound">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Data.IRepository">
      <summary>
            A repository generalization
            </summary>
    </member>
    <member name="M:Magnum.Data.IRepository.Get``1(System.Object)">
      <summary>
            Returns the entity for the Id specified.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="id">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Data.IRepository.List``1">
      <summary>
            Returns a list of objects
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Data.IRepository.Save``1(``0)">
      <summary>
            Saves an object
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="item">
      </param>
    </member>
    <member name="M:Magnum.Data.IRepository.Update``1(``0)">
      <summary>
            Updates an existing object
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="item">
      </param>
    </member>
    <member name="M:Magnum.Data.IRepository.Delete``1(``0)">
      <summary>
            Deletes an object from the repository
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="item">
      </param>
    </member>
    <member name="M:Magnum.Data.IRepository.FindBy``1">
      <summary>
            Finds an object using linq
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Data.IRepository`1">
      <summary>
            A repository generalization
            </summary>
    </member>
    <member name="M:Magnum.Data.IRepository`1.Save(`0)">
      <summary>
            Saves an object
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="item">
      </param>
    </member>
    <member name="M:Magnum.Data.IRepository`1.Update(`0)">
      <summary>
            Updates an existing item
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:Magnum.Data.IRepository`1.Delete(`0)">
      <summary>
            Deletes an object from the repository
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="item">
      </param>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Weeks(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of weeks
            </summary>
      <param name="value">The number of weeks</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Days(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of days
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Hours(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of hours
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Minutes(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of minutes
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Seconds(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of seconds
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Milliseconds(System.Int32)">
      <summary>
            Creates a TimeSpan for the specified number of milliseconds
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Extensions.ExtensionsToTimeSpan.Repeat(System.TimeSpan,System.Int32)">
      <summary>
            Returns an enumeration of the specified TimeSpan with the specified number of elements
            </summary>
      <param name="value">The TimeSpan to repeat</param>
      <param name="times">The number of times to repeat the TimeSpan</param>
      <returns>An enumeration of TimeSpan</returns>
    </member>
    <member name="T:Magnum.StateMachine.ChannelConfiguration.StateMachineEventInspectorResult`2">
      <summary>
            Describes an event, received by a state machine, and the in which that event is valid
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="P:Magnum.StateMachine.ChannelConfiguration.StateMachineEventInspectorResult`2.Event">
      <summary>
            The event received by the state machine
            </summary>
    </member>
    <member name="P:Magnum.StateMachine.ChannelConfiguration.StateMachineEventInspectorResult`2.AcceptingStates">
      <summary>
            The states in which the event can be delivered to the state machine
            </summary>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.Execute(System.Collections.Generic.IEnumerator{System.Int32})">
      <summary>
            Executes a method containing yields, but waits for said method to complete
            </summary>
      <param name="enumerator">The method to execute</param>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.BeginExecute(System.Collections.Generic.IEnumerator{System.Int32},System.AsyncCallback,System.Object)">
      <summary>
            Asynchronously executes a method containing yields
            </summary>
      <param name="enumerator">The method to execute</param>
      <param name="callback">The asynchronous method to call back</param>
      <param name="state">A state object passed to the asynchronous callback</param>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.EndExecute(System.IAsyncResult)">
      <summary>
            Completes the execution of an asynchronous methods
            </summary>
      <param name="asyncResult">
      </param>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.Cancel">
      <summary>
            Cancel the execution of an asynchronous method
            </summary>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.End">
      <summary>
            Returns a callback for the BeginXXX method being yielded
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Magnum.Threading.IAsyncExecutor.Result">
      <summary>
            Returns the next async result in the queue of completed asynchronous methods
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Magnum.Threading.AsyncExecutor">
      <summary>
            Attempts to provide a method of running asynchronous methods (the BeginXXX/EndXXX style)
            in a linear manner avoiding all the propogation of those methods up the call stack
            
            Slightly influence by Jeffrey Richter's PowerThreading library
            http://wintellect.com/PowerThreading.aspx
            
            </summary>
    </member>
    <member name="T:Magnum.Threading.ILockedObject`1">
      <summary>
            Interface to a locked object of type T
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Magnum.Threading.ILockedObject`1.ReadUnlocked(System.Action{`0})">
      <summary>
            Access the contained object without any locking
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="M:Magnum.Threading.ILockedObject`1.ReadLock(System.Action{`0})">
      <summary>
            Access the contained object within a read lock
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="M:Magnum.Threading.ILockedObject`1.ReadLock(System.TimeSpan,System.Action{`0})">
      <summary>
            Access the contained object within a read lock if possible before the timeout expires
            </summary>
      <param name="timeout">The time to wait for a lock before returning false</param>
      <param name="action">
      </param>
      <returns>True if the lock was obtained and the action called, otherwise false</returns>
    </member>
    <member name="M:Magnum.Threading.ILockedObject`1.UpgradeableReadLock(System.Action{`0})">
      <summary>
            Access the contained object within an upgradeable read lock
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="M:Magnum.Threading.ILockedObject`1.WriteLock(System.Func{`0,`0})">
      <summary>
            Access the contained object within a write lock
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="T:Magnum.Threading.ReaderWriterLockedObject`1">
      <summary>
            Contains an object within a ReaderWriterLockContext
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Magnum.ValueProviders.ValueProviderDecorator">
      <summary>
            Makes wrapping another value provider easy, including logging of values as they are utilized
            </summary>
    </member>
    <member name="M:Magnum.ValueProviders.CommandLineValueProvider.#ctor">
      <summary>
            Uses the default command-line for the process
            </summary>
    </member>
    <member name="T:Magnum.ValueProviders.FileValueProvider">
      <summary>
            Wraps the reading of a file containing value configuration, passing the appropriate context
            provider that is initialized from the stream.
            </summary>
    </member>
    <member name="T:Magnum.ValueProviders.MultipleValueProvider">
      <summary>
              Requests a value from an ordered list of value providers
            </summary>
    </member>
    <member name="T:System.Diagnostics.Contracts.Contract">
      <summary>
            A stub version of .NET 4.0 contracts.
            </summary>
    </member>
    <member name="T:System.Environment2">
      <summary>
            A dummy class that implements GetResourceString. Environment.GetResourceString(string) is an internal
            method in mscorlib.dll.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.IThreadPoolWorkItem">
      <summary>
            An interface similar to the one added in .NET 4.0.
            </summary>
    </member>
    <member name="T:System.Threading.Monitor2">
      <summary>
            .NET 4.0 Monitor class supports new overloads that return a boolean value
            representing whether the lock was successfully taken or not. The return value
            is meant to be accurate even in the presence of thread aborts.
            
            Monitor2 implements these methods as simple wrappers over the .NET 3.5 methods,
            but without making the guarantees related to thread aborts.
            </summary>
    </member>
    <member name="T:System.Collections.Generic.Mscorlib_DictionaryDebugView`2">
      <summary>
            This internal class from mscorlib.dll is used by ConcurrentDictionary.
            </summary>
    </member>
    <member name="T:System.OperationCanceledException2">
      <summary>
            OperationCanceledException is changing from .NET 3.5 to .NET 4.0. To make Parallel Extensions work,
            we include the new version as OperationCanceledException2.
            </summary>
    </member>
    <member name="T:System.Threading.Platform">
      <summary>
            A convenience class for common platform-related logic.
            </summary>
    </member>
    <member name="P:System.Threading.Platform.ProcessorCount">
      <summary>
            Gets the number of available processors available to this process on the current machine.
            </summary>
    </member>
    <member name="T:System.SecuritySafeCriticalAttribute">
      <summary>
            A dummy replacement for the .NET 4.0 SecuritySafeCriticalAttribute. The dummy attribute makes the
            code compile, but we are likely losing the ability to be called from a partial trust environment.
            </summary>
    </member>
    <member name="T:System.Threading.StackCrawlMark2">
      <summary>
            A dummy replacement for the .NET internal class StackCrawlMark.
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2">
      <summary>
            Represents a thread-safe collection of keys and values.
            </summary>
      <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
      <remarks>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.Node">
      <summary>
            A node in a singly-linked list representing a particular hash table bucket.
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.DictionaryEnumerator">
      <summary>
            A private class to represent enumeration over the dictionary that implements the 
            IDictionaryEnumerator interface.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
            class that is empty, has the default concurrency level, has the default initial capacity, and
            uses the default comparer for the key type.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
            class that is empty, has the specified concurrency level and capacity, and uses the default
            comparer for the key type.
            </summary>
      <param name="concurrencyLevel">The estimated number of threads that will update the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</param>
      <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
            can contain.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="concurrencyLevel" /> is
            less than 1.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="capacity" /> is less than
            0.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
            class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}" />, has the default concurrency
            level, has the default initial capacity, and uses the default comparer for the key type.
            </summary>
      <param name="collection">The <see cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}" /> whose elements are copied to
            the new
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collection" /> contains one or more
            duplicate keys.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
            class that is empty, has the specified concurrency level and capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}" />.
            </summary>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}" />
            implementation to use when comparing keys.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> is a null reference
            (Nothing in Visual Basic).</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
            class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable" />, has the default concurrency level, has the default
            initial capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}" />.
            </summary>
      <param name="collection">The <see cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}" /> whose elements are copied to
            the new
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}" />
            implementation to use when comparing keys.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is a null reference
            (Nothing in Visual Basic). -or-
            <paramref name="comparer" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 
            class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable" />, 
            has the specified concurrency level, has the specified initial capacity, and uses the specified 
            <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}" />.
            </summary>
      <param name="concurrencyLevel">The estimated number of threads that will update the 
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</param>
      <param name="collection">The <see cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}" /> whose elements are copied to the new 
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}" /> implementation to use 
            when comparing keys.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is a null reference (Nothing in Visual Basic).
            -or-
            <paramref name="comparer" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="concurrencyLevel" /> is less than 1.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collection" /> contains one or more duplicate keys.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
            class that is empty, has the specified concurrency level, has the specified initial capacity, and
            uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}" />.
            </summary>
      <param name="concurrencyLevel">The estimated number of threads that will update the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</param>
      <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
            can contain.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}" />
            implementation to use when comparing keys.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="concurrencyLevel" /> is less than 1. -or-
            <paramref name="capacity" /> is less than 0.
            </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> is a null reference
            (Nothing in Visual Basic).</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
      <summary>
            Attempts to add the specified key and value to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.
            </summary>
      <param name="key">The key of the element to add.</param>
      <param name="value">The value of the element to add. The value can be a null reference (Nothing
            in Visual Basic) for reference types.</param>
      <returns>true if the key/value pair was added to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
            successfully; otherwise, false.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.OverflowException">The <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
            contains too many elements.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)">
      <summary>
            Determines whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contains the specified
            key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</param>
      <returns>true if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contains an element with
            the specified key; otherwise, false.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is a null reference
            (Nothing in Visual Basic).</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
      <summary>
            Attempts to remove and return the the value with the specified key from the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.
            </summary>
      <param name="key">The key of the element to remove and return.</param>
      <param name="value">When this method returns, <paramref name="value" /> contains the object removed from the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> or the default value of <typeparamref name="TValue" />
            if the operation failed.</param>
      <returns>true if an object was removed successfully; otherwise, false.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is a null reference
            (Nothing in Visual Basic).</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemoveInternal(`0,`1@,System.Boolean,`1)">
      <summary>
            Removes the specified key from the dictionary if it exists and returns its associated value.
            If matchValue flag is set, the key will be removed only if is associated with a particular
            value.
            </summary>
      <param name="key">The key to search for and remove if it exists.</param>
      <param name="value">The variable into which the removed value, if found, is stored.</param>
      <param name="matchValue">Whether removal of the key is conditional on its value.</param>
      <param name="oldValue">The conditional value to compare against if <paramref name="matchValue" /> is true</param>
      <returns>
      </returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
      <summary>
            Attempts to get the value associated with the specified key from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.
            </summary>
      <param name="key">The key of the value to get.</param>
      <param name="value">When this method returns, <paramref name="value" /> contains the object from
            the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> with the spedified key or the default value of
            <typeparamref name="TValue" />, if the operation failed.</param>
      <returns>true if the key was found in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />;
            otherwise, false.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is a null reference
            (Nothing in Visual Basic).</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
      <summary>
            Compares the existing value for the specified key with a specified value, and if theyre equal,
            updates the key with a third value.
            </summary>
      <param name="key">The key whose value is compared with <paramref name="comparisonValue" /> and
            possibly replaced.</param>
      <param name="newValue">The value that replaces the value of the element with <paramref name="key" /> if the comparison results in equality.</param>
      <param name="comparisonValue">The value that is compared to the value of the element with
            <paramref name="key" />.</param>
      <returns>true if the value with <paramref name="key" /> was equal to <paramref name="comparisonValue" /> and replaced with <paramref name="newValue" />; otherwise,
            false.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is a null
            reference.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.Clear">
      <summary>
            Removes all keys and values from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray">
      <summary>
            Copies the key and value pairs stored in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> to a
            new array.
            </summary>
      <returns>A new array containing a snapshot of key and value pairs copied from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToPairs(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <summary>
            Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.
            
            Important: the caller must hold all locks in m_locks before calling CopyToPairs.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToEntries(System.Collections.DictionaryEntry[],System.Int32)">
      <summary>
            Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.
            
            Important: the caller must hold all locks in m_locks before calling CopyToEntries.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToObjects(System.Object[],System.Int32)">
      <summary>
            Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.
            
            Important: the caller must hold all locks in m_locks before calling CopyToObjects.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator">
      <summary>Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</summary>
      <returns>An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</returns>
      <remarks>
            The enumerator returned from the dictionary is safe to use concurrently with
            reads and writes to the dictionary, however it does not represent a moment-in-time snapshot
            of the dictionary.  The contents exposed through the enumerator may contain modifications
            made to the dictionary after <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator" /> was called.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAddInternal(`0,`1,System.Boolean,System.Boolean,`1@)">
      <summary>
            Shared internal implementation for inserts and updates.
            If key exists, we always return false; and if updateIfExists == true we force update with value;
            If key doesn't exist, we always add value and return true;
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
      <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 
            if the key does not already exist.
            </summary>
      <param name="key">The key of the element to add.</param>
      <param name="valueFactory">The function used to generate a value for the key</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
      <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
      <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 
            if the key does not already exist.
            </summary>
      <param name="key">The key of the element to add.</param>
      <param name="value">the value to be added, if the key does not already exist</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
      <returns>The value for the key.  This will be either the existing value for the key if the 
            key is already in the dictionary, or the new value if the key was not in the dictionary.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
      <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already 
            exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key 
            already exists.
            </summary>
      <param name="key">The key to be added or whose value should be updated</param>
      <param name="addValueFactory">The function used to generate a value for an absent key</param>
      <param name="updateValueFactory">The function used to generate a new value for an existing key
            based on the key's existing value</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addValueFactory" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="updateValueFactory" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
      <returns>The new value for the key.  This will be either be the result of addValueFactory (if the key was 
            absent) or the result of updateValueFactory (if the key was present).</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
      <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already 
            exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key 
            already exists.
            </summary>
      <param name="key">The key to be added or whose value should be updated</param>
      <param name="addValue">The value to be added for an absent key</param>
      <param name="updateValueFactory">The function used to generate a new value for an existing key based on 
            the key's existing value</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="updateValueFactory" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
      <returns>The new value for the key.  This will be either be the result of addValueFactory (if the key was 
            absent) or the result of updateValueFactory (if the key was present).</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GrowTable(System.Collections.Concurrent.ConcurrentDictionary{`0,`1}.Node[])">
      <summary>
            Replaces the internal table with a larger one. To prevent multiple threads from resizing the
            table as a result of races, the table of buckets that was deemed too small is passed in as
            an argument to GrowTable(). GrowTable() obtains a lock, and then checks whether the bucket
            table has been replaced in the meantime or not.
            </summary>
      <param name="buckets">Reference to the bucket table that was deemed too small.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetBucketAndLockNo(System.Int32,System.Int32@,System.Int32@,System.Int32)">
      <summary>
            Computes the bucket and lock number for a particular key. 
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AcquireAllLocks(System.Int32@)">
      <summary>
            Acquires all locks for this hash table, and increments locksAcquired by the number
            of locks that were successfully acquired. The locks are acquired in an increasing
            order.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AcquireLocks(System.Int32,System.Int32,System.Int32@)">
      <summary>
            Acquires a contiguous range of locks for this hash table, and increments locksAcquired
            by the number of locks that were successfully acquired. The locks are acquired in an
            increasing order.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ReleaseLocks(System.Int32,System.Int32)">
      <summary>
            Releases a contiguous range of locks.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetKeys">
      <summary>
            Gets a collection containing the keys in the dictionary.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetValues">
      <summary>
            Gets a collection containing the values in the dictionary.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.Assert(System.Boolean)">
      <summary>
            A helper method for asserts.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetResource(System.String)">
      <summary>
            A helper function to obtain the string for a particular resource key.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.OnSerializing(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Get the data array to be serialized
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Construct the dictionary from a previously seiralized one
            </summary>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
      <summary>
            Gets or sets the value associated with the specified key.
            </summary>
      <param name="key">The key of the value to get or set.</param>
      <value>The value associated with the specified key. If the specified key is not found, a get
            operation throws a
            <see cref="T:Sytem.Collections.Generic.KeyNotFoundException" />, and a set operation creates a new
            element with the specified key.</value>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and
            <paramref name="key" />
            does not exist in the collection.</exception>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count">
      <summary>
            Gets the number of key/value pairs contained in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.
            </summary>
      <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
      <value>The number of key/value paris contained in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</value>
      <remarks>Count has snapshot semantics and represents the number of items in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
            at the moment when Count was accessed.</remarks>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty">
      <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> is empty.
            </summary>
      <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> is empty; otherwise,
            false.</value>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys">
      <summary>
            Gets a collection containing the keys in the <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}" />.
            </summary>
      <value>An <see cref="T:System.Collections.Generic.ICollection{TKey}" /> containing the keys in the
            <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}" />.</value>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values">
      <summary>
            Gets a collection containing the values in the <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}" />.
            </summary>
      <value>An <see cref="T:System.Collections.Generic.ICollection{TValue}" /> containing the values in
            the
            <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}" />.</value>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.DefaultConcurrencyLevel">
      <summary>
            The number of concurrent writes for which to optimize by default.
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.IProducerConsumerCollection`1">
      <summary>
            Defines methods to manipulate thread-safe collections intended for producer/consumer usage.
            </summary>
      <typeparam name="T">Specifies the type of elements in the collection.</typeparam>
      <remarks>
            All implementations of this interface must enable all members of this interface
            to be used concurrently from multiple threads.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> to
            an
            <see cref="T:System.Array" />, starting at a specified index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of
            the elements copied from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.
            The array must have zero-based indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying
            begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is a null reference (Nothing in
            Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than
            zero.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> is equal to or greater than the
            length of the <paramref name="array" />
            -or- The number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> is greater than the
            available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.
            </exception>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)">
      <summary>
            Attempts to add an object to the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.
            </summary>
      <param name="item">The object to add to the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</param>
      <returns>true if the object was added successfully; otherwise, false.</returns>
      <exception cref="T:System.ArgumentException">The <paramref name="item" /> was invalid for this collection.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)">
      <summary>
            Attempts to remove and return an object from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.
            </summary>
      <param name="item">
            When this method returns, if the object was removed and returned successfully, <paramref name="item" /> contains the removed object. If no object was available to be removed, the value is
            unspecified.
            </param>
      <returns>true if an object was removed and returned successfully; otherwise, false.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray">
      <summary>
            Copies the elements contained in the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> to a new array.
            </summary>
      <returns>A new array containing the elements copied from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentQueue`1">
      <summary>
            Represents a thread-safe first-in, first-out collection of objects.
            </summary>
      <typeparam name="T">Specifies the type of elements in the queue.</typeparam>
      <remarks>
            All public  and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentQueue`1.Segment">
      <summary>
            private class for ConcurrentQueue. 
            a queue is a linked list of small arrays, each node is called a segment.
            A segment contains an array, a pointer to the next segment, and m_low, m_high indices recording
            the first and last valid elements of the array.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Segment.#ctor(System.Int64)">
      <summary>
            Create and initialize a segment with the specified index.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Segment.UnsafeGrow">
      <summary>
            Create a new segment and append to the current one
            Does not update the m_tail pointer
            exclusively called by ConcurrentQueue.InitializedFromCollection
            InitializeFromCollection is responsible to guaratee that there is no index overflow,
            and there is no contention
            </summary>
      <returns>the reference to the new Segment</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Segment.ToList(System.Int32,System.Int32)">
      <summary>
            Convert part or all of the current segment into a List
            </summary>
      <param name="start">the start position</param>
      <param name="end">the end position</param>
      <returns>the result list </returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Segment.Next">
      <summary>
            return the next segment
            </summary>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Segment.IsEmpty">
      <summary>
            return true if the current segment is empty (doesn't have any element available to dequeue, 
            false otherwise
            </summary>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Segment.Low">
      <summary>
            return the position of the head of the current segment
            </summary>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Segment.High">
      <summary>
            return the logical position of the tail of the current segment      
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> class.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.InitializeFromCollection(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Initializes the contents of the queue from an existing collection.
            </summary>
      <param name="collection">A collection from which to copy elements.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />
            class that contains elements copied from the specified collection
            </summary>
      <param name="collection">The collection whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collection" /> argument is
            null.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.OnSerializing(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Get the data array to be serialized
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Construct the queue from a previously seiralized one
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.ToArray">
      <summary>
            Copies the elements stored in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> to a new array.
            </summary>
      <returns>A new array containing a snapshot of elements copied from the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.ToList">
      <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> elements to a new <see cref="T:System.Collections.Generic.List{T}" />.
            </summary>
      <returns>A new <see cref="T:System.Collections.Generic.List{T}" /> containing a snapshot of
            elements copied from the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetHeadTailPositions(System.Collections.Concurrent.ConcurrentQueue{`0}.Segment@,System.Collections.Concurrent.ConcurrentQueue{`0}.Segment@,System.Int32@,System.Int32@)">
      <summary>
            Store the position of the current head and tail positions.
            </summary>
      <param name="head">return the head segment</param>
      <param name="tail">return the tail segment</param>
      <param name="headLow">return the head offset</param>
      <param name="tailHigh">return the tail offset</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> elements to an existing one-dimensional <see cref="T:System.Array">Array</see>, starting at the specified array index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />. The <see cref="T:System.Array">Array</see> must have zero-based
            indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying
            begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is a null reference (Nothing in
            Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than
            zero.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> is equal to or greater than the
            length of the <paramref name="array" />
            -or- The number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> is greater than the
            available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.
            </exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.
            </summary>
      <returns>An enumerator for the contents of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</returns>
      <remarks>
            The enumeration represents a moment-in-time snapshot of the contents
            of the queue.  It does not reflect any updates to the collection after 
            <see cref="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator" /> was called.  The enumerator is safe to use
            concurrently with reads from and writes to the queue.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Enqueue(`0)">
      <summary>
            Adds an object to the end of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.
            </summary>
      <param name="item">The object to add to the end of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />. The value can be a null reference
            (Nothing in Visual Basic) for reference types.
            </param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryDequeue(`0@)">
      <summary>
            Attempts to remove and return the object at the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.
            </summary>
      <param name="result">
            When this method returns, if the operation was successful, <paramref name="result" /> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
      <returns>true if an element was removed and returned from the beggining of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />
            succesfully; otherwise, false.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryPeek(`0@)">
      <summary>
            Attempts to return an object from the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />
            without removing it.
            </summary>
      <param name="result">When this method returns, <paramref name="result" /> contains an object from
            the beginning of the <see cref="T:System.Collections.Concurrent.ConccurrentQueue{T}" /> or an
            unspecified value if the operation failed.</param>
      <returns>true if and object was returned successfully; otherwise, false.</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty">
      <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> is empty.
            </summary>
      <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> is empty; otherwise, false.</value>
      <remarks>
            For determining whether the collection contains any items, use of this property is recommended
            rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.Count" /> property and comparing it
            to 0.  However, as this collection is intended to be accessed concurrently, it may be the case
            that another thread will modify the collection after <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty" /> returns, thus invalidating
            the result.
            </remarks>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.
            </summary>
      <value>The number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</value>
      <remarks>
            For determining whether the collection contains any items, use of the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty" />
            property is recommended rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.Count" />
            property and comparing it to 0.
            </remarks>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentStack`1">
      <summary>
            Represents a thread-safe last-in, first-out collection of objects.
            </summary>
      <typeparam name="T">Specifies the type of elements in the stack.</typeparam>
      <remarks>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentStack`1.Node">
      <summary>
            A simple (internal) node type used to store elements of concurrent stacks and queues.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />
            class.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />
            class that contains elements copied from the specified collection
            </summary>
      <param name="collection">The collection whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collection" /> argument is
            null.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.InitializeFromCollection(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Initializes the contents of the stack from an existing collection.
            </summary>
      <param name="collection">A collection from which to copy elements.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.OnSerializing(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Get the data array to be serialized
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Construct the stack from a previously seiralized one
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Clear">
      <summary>
            Removes all objects from the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> elements to an existing one-dimensional <see cref="T:System.Array" />, starting at the specified array index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of
            the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />. The <see cref="T:System.Array" /> must have zero-based
            indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying
            begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is a null reference (Nothing in
            Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than
            zero.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> is equal to or greater than the
            length of the <paramref name="array" />
            -or- The number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> is greater than the
            available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.
            </exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)">
      <summary>
            Inserts an object at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.
            </summary>
      <param name="item">The object to push onto the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />. The value can be
            a null reference (Nothing in Visual Basic) for reference types.
            </param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[])">
      <summary>
            Inserts multiple objects at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> atomically.
            </summary>
      <param name="items">The objects to push onto the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <remarks>
            When adding multiple items to the stack, using PushRange is a more efficient
            mechanism than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)" /> one item at a time.  Additionally, PushRange
            guarantees that all of the elements will be added atomically, meaning that no other threads will
            be able to inject elements between the elements being pushed.  Items at lower indices in
            the <paramref name="items" /> array will be pushed before items at higher indices.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[],System.Int32,System.Int32)">
      <summary>
            Inserts multiple objects at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> atomically.
            </summary>
      <param name="items">The objects to push onto the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <param name="startIndex">The zero-based offset in <paramref name="items" /> at which to begin
            inserting elements onto the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <param name="count">The number of elements to be inserted onto the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="startIndex" /> or <paramref name="count" /> is negative. Or <paramref name="startIndex" /> is greater than or equal to the length 
            of <paramref name="items" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="startIndex" /> + <paramref name="count" /> is
            greater than the length of <paramref name="items" />.</exception>
      <remarks>
            When adding multiple items to the stack, using PushRange is a more efficient
            mechanism than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)" /> one item at a time. Additionally, PushRange
            guarantees that all of the elements will be added atomically, meaning that no other threads will
            be able to inject elements between the elements being pushed. Items at lower indices in the
            <paramref name="items" /> array will be pushed before items at higher indices.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushCore(System.Collections.Concurrent.ConcurrentStack{`0}.Node,System.Collections.Concurrent.ConcurrentStack{`0}.Node)">
      <summary>
            Push one or many nodes into the stack, if head and tails are equal then push one node to the stack other wise push the list between head
            and tail to the stack
            </summary>
      <param name="head">The head pointer to the new list</param>
      <param name="tail">The tail pointer to the new list</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ValidatePushPopRangeInput(`0[],System.Int32,System.Int32)">
      <summary>
            Local helper function to validate the Pop Push range methods input
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPeek(`0@)">
      <summary>
            Attempts to return an object from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />
            without removing it.
            </summary>
      <param name="result">When this method returns, <paramref name="result" /> contains an object from
            the top of the <see cref="T:System.Collections.Concurrent.ConccurrentStack{T}" /> or an
            unspecified value if the operation failed.</param>
      <returns>true if and object was returned successfully; otherwise, false.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)">
      <summary>
            Attempts to pop and return the object at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.
            </summary>
      <param name="result">
            When this method returns, if the operation was successful, <paramref name="result" /> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
      <returns>true if an element was removed and returned from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />
            succesfully; otherwise, false.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[])">
      <summary>
            Attempts to pop and return multiple objects from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />
            atomically.
            </summary>
      <param name="items">
            The <see cref="T:System.Array" /> to which objects popped from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> will be added.
            </param>
      <returns>The number of objects successfully popped from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> and inserted in
            <paramref name="items" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> is a null argument (Nothing
            in Visual Basic).</exception>
      <remarks>
            When popping multiple items, if there is little contention on the stack, using
            TryPopRange can be more efficient than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)" />
            once per item to be removed.  Nodes fill the <paramref name="items" />
            with the first node to be popped at the startIndex, the second node to be popped
            at startIndex + 1, and so on.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[],System.Int32,System.Int32)">
      <summary>
            Attempts to pop and return multiple objects from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />
            atomically.
            </summary>
      <param name="items">
            The <see cref="T:System.Array" /> to which objects popped from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> will be added.
            </param>
      <param name="startIndex">The zero-based offset in <paramref name="items" /> at which to begin
            inserting elements from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
      <param name="count">The number of elements to be popped from top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> and inserted into <paramref name="items" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> is a null reference
            (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="startIndex" /> or <paramref name="count" /> is negative. Or <paramref name="startIndex" /> is greater than or equal to the length 
            of <paramref name="items" />.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="startIndex" /> + <paramref name="count" /> is
            greater than the length of <paramref name="items" />.</exception>
      <remarks>
            When popping multiple items, if there is little contention on the stack, using
            TryPopRange can be more efficient than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)" />
            once per item to be removed.  Nodes fill the <paramref name="items" />
            with the first node to be popped at the startIndex, the second node to be popped
            at startIndex + 1, and so on.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopCore(`0@)">
      <summary>
            Local helper function to Pop an item from the stack, slow path
            </summary>
      <param name="result">The popped item</param>
      <returns>True if succeeded, false otherwise</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopCore(System.Int32,System.Collections.Concurrent.ConcurrentStack{`0}.Node@)">
      <summary>
            Slow path helper for TryPop. This method assumes an initial attempt to pop an element
            has already occurred and failed, so it begins spinning right away.
            </summary>
      <param name="count">The number of items to pop.</param>
      <param name="poppedHead">
            When this method returns, if the pop succeeded, contains the removed object. If no object was
            available to be removed, the value is unspecified. This parameter is passed uninitialized.
            </param>
      <returns>True if an element was removed and returned; otherwise, false.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.CopyRemovedItems(System.Collections.Concurrent.ConcurrentStack{`0}.Node,`0[],System.Int32,System.Int32)">
      <summary>
            Local helper function to copy the poped elements into a given collection
            </summary>
      <param name="head">The head of the list to be copied</param>
      <param name="collection">The collection to place the popped items in</param>
      <param name="startIndex">the beginning of index of where to place the popped items</param>
      <param name="nodesCount">The number of nodes.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ToArray">
      <summary>
            Copies the items stored in the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> to a new array.
            </summary>
      <returns>A new array containing a snapshot of elements copied from the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ToList">
      <summary>
            Returns an array containing a snapshot of the list's contents, using
            the target list node as the head of a region in the list.
            </summary>
      <returns>An array of the list's contents.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.
            </summary>
      <returns>An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</returns>
      <remarks>
            The enumeration represents a moment-in-time snapshot of the contents
            of the stack.  It does not reflect any updates to the collection after 
            <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator" /> was called.  The enumerator is safe to use
            concurrently with reads from and writes to the stack.
            </remarks>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty">
      <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> is empty.
            </summary>
      <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> is empty; otherwise, false.</value>
      <remarks>
            For determining whether the collection contains any items, use of this property is recommended
            rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.Count" /> property and comparing it
            to 0.  However, as this collection is intended to be accessed concurrently, it may be the case
            that another thread will modify the collection after <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty" /> returns, thus invalidating
            the result.
            </remarks>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.
            </summary>
      <value>The number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</value>
      <remarks>
            For determining whether the collection contains any items, use of the <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty" />
            property is recommended rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.Count" />
            property and comparing it to 0.
            </remarks>
    </member>
    <member name="T:System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1">
      <summary>
            A debugger view of the IProducerConsumerCollection that makes it simple to browse the
            collection's contents at a point in time.
            </summary>
      <typeparam name="T">The type of elements stored within.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
      <summary>
            Constructs a new debugger view object for the provided collection object.
            </summary>
      <param name="collection">A collection to browse in the debugger.</param>
    </member>
    <member name="P:System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1.Items">
      <summary>
            Returns a snapshot of the underlying collection's elements.
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner`1">
      <summary>
            Represents a particular manner of splitting a data source into multiple partitions.
            </summary>
      <typeparam name="TSource">Type of the elements in the collection.</typeparam>
      <remarks>
        <para>
            Inheritors of <see cref="T:System.Collections.Concurrent.Partitioner`1" /> must adhere to the following rules:
            <ol><li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> should throw a
            <see cref="T:System.ArgumentOutOfRangeException" /> if the requested partition count is less than or
            equal to zero.</li><li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> should always return a number of enumerables equal to the requested
            partition count. If the partitioner runs out of data and cannot create as many partitions as 
            requested, an empty enumerator should be returned for each of the remaining partitions. If this rule
            is not followed, consumers of the implementation may throw a <see cref="T:System.InvalidOperationException" />.</li><li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> and <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions" />
            should never return null. If null is returned, a consumer of the implementation may throw a
            <see cref="T:System.InvalidOperationException" />.</li><li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> and <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions" /> should always return
            partitions that can fully and uniquely enumerate the input data source. All of the data and only the
            data contained in the input source should be enumerated, with no duplication that was not already in
            the input, unless specifically required by the particular partitioner's design. If this is not
            followed, the output ordering may be scrambled.</li></ol></para>
      </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)">
      <summary>
            Partitions the underlying collection into the given number of partitions.
            </summary>
      <param name="partitionCount">The number of partitions to create.</param>
      <returns>A list containing <paramref name="partitionCount" /> enumerators.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions">
      <summary>
            Creates an object that can partition the underlying collection into a variable number of
            partitions.
            </summary>
      <remarks>
        <para>
            The returned object implements the <see cref="T:System.Collections.Generic.IEnumerable{TSource}" /> interface. Calling <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">GetEnumerator</see> on the
            object creates another partition over the sequence.
            </para>
        <para>
            The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions" /> method is only supported if the <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />
            property returns true.
            </para>
      </remarks>
      <returns>An object that can create partitions over the underlying data source.</returns>
      <exception cref="T:System.NotSupportedException">Dynamic partitioning is not supported by this
            partitioner.</exception>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions">
      <summary>
            Gets whether additional partitions can be created dynamically.
            </summary>
      <returns>
            true if the <see cref="T:System.Collections.Concurrent.Partitioner`1" /> can create partitions dynamically as they are
            requested; false if the <see cref="T:System.Collections.Concurrent.Partitioner`1" /> can only allocate
            partitions statically.
            </returns>
      <remarks>
        <para>
            If a derived class does not override and implement <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions" />,
            <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> should return false. The value of <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> should not vary over the lifetime of this instance.
            </para>
      </remarks>
    </member>
    <member name="T:System.Collections.Concurrent.OrderablePartitioner`1">
      <summary>
            Represents a particular manner of splitting an orderable data source into multiple partitions.
            </summary>
      <typeparam name="TSource">Type of the elements in the collection.</typeparam>
      <remarks>
        <para>
            Each element in each partition has an integer index associated with it, which determines the relative
            order of that element against elements in other partitions.
            </para>
        <para>
            Inheritors of <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> must adhere to the following rules:
            <ol><li>All indices must be unique, such that there may not be duplicate indices. If all indices are not
            unique, the output ordering may be scrambled.</li><li>All indices must be non-negative. If any indices are negative, consumers of the implementation
            may throw exceptions.</li><li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)" /> and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)" /> should throw a
            <see cref="T:System.ArgumentOutOfRangeException" /> if the requested partition count is less than or
            equal to zero.</li><li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)" /> and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)" /> should always return a number
            of enumerables equal to the requested partition count. If the partitioner runs out of data and cannot
            create as many partitions as requested, an empty enumerator should be returned for each of the
            remaining partitions. If this rule is not followed, consumers of the implementation may throw a <see cref="T:System.InvalidOperationException" />.</li><li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)" />, <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)" />,
            <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions" />, and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions" />
            should never return null. If null is returned, a consumer of the implementation may throw a
            <see cref="T:System.InvalidOperationException" />.</li><li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)" />, <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)" />,
            <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions" />, and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions" />
            should always return partitions that can fully and uniquely enumerate the input data source. All of
            the data and only the data contained in the input source should be enumerated, with no duplication
            that was not already in the input, unless specifically required by the particular partitioner's
            design. If this is not followed, the output ordering may be scrambled.</li><li>If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition" /> returns true, each partition must return elements
            with increasing key indices.</li><li>If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions" /> returns true, all the keys in partition numbered N
            must be larger than all the keys in partition numbered N-1.</li><li>If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> returns true, all indices must be monotonically increasing from
            0, though not necessarily within a single partition.</li></ol></para>
      </remarks>
    </member>
    <member name="T:System.Collections.Concurrent.OrderablePartitioner`1.EnumerableDropIndices">
      <summary>
            Converts an enumerable over key-value pairs to an enumerable over values.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.#ctor(System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> class with the
            specified constraints on the index keys.
            </summary>
      <param name="keysOrderedInEachPartition">
            Indicates whether the elements in each partition are yielded in the order of
            increasing keys.
            </param>
      <param name="keysOrderedAcrossPartitions">
            Indicates whether elements in an earlier partition always come before
            elements in a later partition. If true, each element in partition 0 has a smaller order key than
            any element in partition 1, each element in partition 1 has a smaller order key than any element
            in partition 2, and so on.
            </param>
      <param name="keysNormalized">
            Indicates whether keys are normalized. If true, all order keys are distinct
            integers in the range [0 .. numberOfElements-1]. If false, order keys must still be dictinct, but
            only their relative order is considered, not their absolute values.
            </param>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)">
      <summary>
            Partitions the underlying collection into the specified number of orderable partitions.
            </summary>
      <remarks>
            Each partition is represented as an enumerator over key-value pairs.
            The value of the pair is the element itself, and the key is an integer which determines
            the relative ordering of this element against other elements in the data source.
            </remarks>
      <param name="partitionCount">The number of partitions to create.</param>
      <returns>A list containing <paramref name="partitionCount" /> enumerators.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions">
      <summary>
            Creates an object that can partition the underlying collection into a variable number of
            partitions.
            </summary>
      <remarks>
        <para>
            The returned object implements the <see cref="T:System.Collections.Generic.IEnumerable{TSource}" /> interface. Calling <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">GetEnumerator</see> on the
            object creates another partition over the sequence.
            </para>
        <para>
            Each partition is represented as an enumerator over key-value pairs. The value in the pair is the element
            itself, and the key is an integer which determines the relative ordering of this element against
            other elements.
            </para>
        <para>
            The <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions" /> method is only supported if the <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions">SupportsDynamicPartitions</see>
            property returns true.
            </para>
      </remarks>
      <returns>An object that can create partitions over the underlying data source.</returns>
      <exception cref="T:System.NotSupportedException">Dynamic partitioning is not supported by this
            partitioner.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)">
      <summary>
            Partitions the underlying collection into the given number of ordered partitions.
            </summary>
      <remarks>
            The default implementation provides the same behavior as <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)" /> except
            that the returned set of partitions does not provide the keys for the elements.
            </remarks>
      <param name="partitionCount">The number of partitions to create.</param>
      <returns>A list containing <paramref name="partitionCount" /> enumerators.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions">
      <summary>
            Creates an object that can partition the underlying collection into a variable number of
            partitions.
            </summary>
      <remarks>
        <para>
            The returned object implements the <see cref="T:System.Collections.Generic.IEnumerable{TSource}" /> interface. Calling <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">GetEnumerator</see> on the
            object creates another partition over the sequence.
            </para>
        <para>
            The default implementation provides the same behavior as <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions" /> except
            that the returned set of partitions does not provide the keys for the elements.
            </para>
        <para>
            The <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions" /> method is only supported if the <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />
            property returns true.
            </para>
      </remarks>
      <returns>An object that can create partitions over the underlying data source.</returns>
      <exception cref="T:System.NotSupportedException">Dynamic partitioning is not supported by this
            partitioner.</exception>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition">
      <summary>
            Gets whether elements in each partition are yielded in the order of increasing keys.
            </summary>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions">
      <summary>
            Gets whether elements in an earlier partition always come before elements in a later partition.
            </summary>
      <remarks>
            If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions" /> returns true, each element in partition 0 has a
            smaller order key than any element in partition 1, each element in partition 1 has a smaller
            order key than any element in partition 2, and so on.
            </remarks>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized">
      <summary>
            Gets whether order keys are normalized.
            </summary>
      <remarks>
            If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> returns true, all order keys are distinct integers in the range
            [0 .. numberOfElements-1]. If the property returns false, order keys must still be dictinct, but
            only their relative order is considered, not their absolute values.
            </remarks>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner">
      <summary>
            Provides common partitioning strategies for arrays, lists, and enumerables.
            </summary>
      <remarks>
        <para>
            The static methods on <see cref="T:System.Collections.Concurrent.Partitioner" /> are all thread-safe and may be used concurrently
            from multiple threads. However, while a created partitioner is in use, the underlying data source
            should not be modified, whether from the same thread that's using a partitioner or from a separate
            thread.
            </para>
      </remarks>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2">
      <summary>
            DynamicPartitionEnumerator_Abstract defines the enumerator for each partition for the dynamic load-balance
            partitioning algorithm. 
            - Partition is an enumerator of KeyValuePairs, each corresponding to an item in the data source: 
              the key is the index in the source collection; the value is the item itself.
            - a set of such partitions share a reader over data source. The type of the reader is specified by
              TSourceReader. 
            - each partition requests a contiguous chunk of elements at a time from the source data. The chunk 
              size is initially 1, and doubles every time until it reaches the maximum chunk size. 
              The implementation for GrabNextChunk() method has two versions: one for data source of IndexRange 
              types (IList and the array), one for data source of IEnumerable.
            - The method "Reset" is not supported for any partitioning algorithm.
            - The implementation for MoveNext() method is same for all dynanmic partitioners, so we provide it
              in this abstract class.
            </summary>
      <typeparam name="TSource">Type of the elements in the data source</typeparam>
      <typeparam name="TSourceReader">Type of the reader on the data source</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.GrabNextChunk(System.Int32)">
      <summary>
            Abstract method to request a contiguous chunk of elements from the source collection
            </summary>
      <param name="requestedChunkSize">specified number of elements requested</param>
      <returns>
            true if we successfully reserved at least one element (up to #=requestedChunkSize) 
            false if all elements in the source collection have been reserved.
            </returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.Dispose">
      <summary>
            Dispose is abstract, and depends on the type of the source data:
            - For source data type IList and Array, the type of the shared reader is just the dataitself.
              We don't do anything in Dispose method for IList and Array. 
            - For source data type IEnumerable, the type of the shared reader is an enumerator we created.
              Thus we need to dispose this shared reader enumerator, when there is no more active partitions
              left.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.Reset">
      <summary>
            Reset on partitions is not supported
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.MoveNext">
      <summary>
            Moves to the next element if any.
            Try current chunk first, if the current chunk do not have any elements left, then we 
            attempt to grab a chunk from the source collection.
            </summary>
      <returns>
            true if successfully moving to the next position;
            false otherwise, if and only if there is no more elements left in the current chunk 
            AND the source collection is exhausted. 
            </returns>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.HasNoElementsLeft">
      <summary>
            Abstract property, returns whether or not the shared reader has already read the last 
            element of the source data 
            </summary>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.Current">
      <summary>
            Get the current element in the current partition. Property required by IEnumerator interface
            This property is abstract because the implementation is different depending on the type
            of the source data: IList, Array or IEnumerable
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1">
      <summary>
            Inherits from DynamicPartitioners
            Provides customized implementation of GetOrderableDynamicPartitions_Factory method, to return an instance
            of EnumerableOfPartitionsForIEnumerator defined internally
            </summary>
      <typeparam name="TSource">Type of elements in the source data</typeparam>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerable">
      <summary>
            Provides customized implementation for source data of IEnumerable
            Different from the counterpart for IList/Array, this enumerable maintains several additional fields
            shared by the partitions it owns, including a boolean "m_hasNoElementsLef", a shared lock, and a 
            shared count "m_activePartitionCount"
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerator">
      <summary>
            Inherits from DynamicPartitionEnumerator_Abstract directly
            Provides customized implementation for: GrabNextChunk, HasNoElementsLeft, Current, Dispose
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerator.GrabNextChunk(System.Int32)">
      <summary>
            Reserves a contiguous range of elements from source data
            </summary>
      <param name="requestedChunkSize">specified number of elements requested</param>
      <returns>
            true if we successfully reserved at least one element (up to #=requestedChunkSize) 
            false if all elements in the source collection have been reserved.
            </returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerator.Dispose">
      <summary>
            If the current partition is to be disposed, we decrement the number of active partitions
            for the shared reader. 
            If the number of active partitions becomes 0, we need to dispose the shared reader we created
            </summary>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerator.HasNoElementsLeft">
      <summary>
            Returns whether or not the shared reader has already read the last 
            element of the source data 
            </summary>
      <remarks>
            We cannot call m_sharedReader.MoveNext(), to see if it hits the last element
            or not, because we can't undo MoveNext(). Thus we need to maintain a shared 
            boolean value m_hasNoElementsLeft across all partitions
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.GetOrderablePartitions(System.Int32)">
      <summary>
            Overrides OrderablePartitioner.GetOrderablePartitions.
            Partitions the underlying collection into the given number of orderable partitions.
            </summary>
      <param name="partitionCount">number of partitions requested</param>
      <returns>A list containing <paramref name="partitionCount" /> enumerators.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.GetOrderableDynamicPartitions">
      <summary>
            Overrides OrderablePartitioner.GetOrderableDyanmicPartitions
            </summary>
      <returns>a enumerable collection of orderable partitions</returns>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.SupportsDynamicPartitions">
      <summary>
            Whether additional partitions can be created dynamically.
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2">
      <summary>
            Dynamic load-balance partitioner. This class is abstract and to be derived from by 
            the customized partitioner classes for IList, Array, and IEnumerable
            </summary>
      <typeparam name="TSource">Type of the elements in the source data</typeparam>
      <typeparam name="TCollection"> Type of the source data collection</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.#ctor(`1)">
      <summary>
            Constructs a new orderable partitioner 
            </summary>
      <param name="data">source data collection</param>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.GetOrderableDynamicPartitions_Factory(`1)">
      <summary>
            Partition the source data and create an enumerable over the resulting partitions. 
            </summary>
      <param name="data">the source data collection</param>
      <returns>an enumerable of partitions of </returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.GetOrderablePartitions(System.Int32)">
      <summary>
            Overrides OrderablePartitioner.GetOrderablePartitions.
            Partitions the underlying collection into the given number of orderable partitions.
            </summary>
      <param name="partitionCount">number of partitions requested</param>
      <returns>A list containing <paramref name="partitionCount" /> enumerators.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.GetOrderableDynamicPartitions">
      <summary>
            Overrides OrderablePartitioner.GetOrderableDyanmicPartitions
            </summary>
      <returns>a enumerable collection of orderable partitions</returns>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.SupportsDynamicPartitions">
      <summary>
            Whether additional partitions can be created dynamically.
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2">
      <summary>
            Defines dynamic partition for source data of IList and Array. 
            This class inherits DynamicPartitionEnumerator_Abstract
              - implements GrabNextChunk, HasNoElementsLeft, and Dispose methods for IList and Array
              - Current property still remains abstract, implementation is different for IList and Array
              - introduces another abstract method SourceCount, which returns the number of elements in
                the source data. Implementation differs for IList and Array
            </summary>
      <typeparam name="TSource">Type of the elements in the data source</typeparam>
      <typeparam name="TSourceReader">Type of the reader on the source data</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.GrabNextChunk(System.Int32)">
      <summary>
            Reserves a contiguous range of elements from source data
            </summary>
      <param name="requestedChunkSize">specified number of elements requested</param>
      <returns>
            true if we successfully reserved at least one element (up to #=requestedChunkSize) 
            false if all elements in the source collection have been reserved.
            </returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.Dispose">
      <summary>
            For source data type IList and Array, the type of the shared reader is just the data itself.
            We don't do anything in Dispose method for IList and Array. 
            </summary>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.SourceCount">
      <summary>
            Get the number of elements from the source reader.
            It calls IList.Count or Array.Length
            </summary>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.HasNoElementsLeft">
      <summary>
            Returns whether or not the shared reader has already read the last 
            element of the source data 
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1">
      <summary>
            Inherits from DynamicPartitioners
            Provides customized implementation of GetOrderableDynamicPartitions_Factory method, to return an instance
            of EnumerableOfPartitionsForIList defined internally
            </summary>
      <typeparam name="TSource">Type of elements in the source data</typeparam>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1.InternalPartitionEnumerable">
      <summary>
            Inherits from PartitionList_Abstract 
            Provides customized implementation for source data of IList
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1.InternalPartitionEnumerator">
      <summary>
            Inherits from DynamicPartitionEnumeratorForIndexRange_Abstract
            Provides customized implementation of SourceCount property and Current property for IList
            </summary>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1.InternalPartitionEnumerator.Current">
      <summary>
            return a KeyValuePair of the current element and its key 
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForArray`1">
      <summary>
            Inherits from DynamicPartitioners
            Provides customized implementation of GetOrderableDynamicPartitions_Factory method, to return an instance
            of EnumerableOfPartitionsForArray defined internally
            </summary>
      <typeparam name="TSource">Type of elements in the source data</typeparam>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForArray`1.InternalPartitionEnumerable">
      <summary>
            Inherits from PartitionList_Abstract 
            Provides customized implementation for source data of Array
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForArray`1.InternalPartitionEnumerator">
      <summary>
            Inherits from DynamicPartitionEnumeratorForIndexRange_Abstract
            Provides customized implementation of SourceCount property and Current property for Array
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2">
      <summary>
            Static partitioning over IList. 
            - dynamic and load-balance
            - Keys are ordered within each partition
            - Keys are ordered across partitions
            - Keys are normalized
            - Number of partitions is fixed once specified, and the elements of the source data are 
            distributed to each partition as evenly as possible. 
            </summary>
      <typeparam name="TSource">type of the elements</typeparam>
      <typeparam name="TCollection">Type of the source data collection</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2.CreatePartition(System.Int32,System.Int32)">
      <summary>
            Abstract method to create a partition that covers a range over source data, 
            starting from "startIndex", ending at "endIndex"
            </summary>
      <param name="startIndex">start index of the current partition on the source data</param>
      <param name="endIndex">end index of the current partition on the source data</param>
      <returns>a partition enumerator over the specified range</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2.GetOrderablePartitions(System.Int32)">
      <summary>
            Overrides OrderablePartitioner.GetOrderablePartitions
            Return a list of partitions, each of which enumerate a fixed part of the source data
            The elements of the source data are distributed to each partition as evenly as possible. 
            Specifically, if the total number of elements is N, and number of partitions is x, and N = a*x +b, 
            where a is the quotient, and b is the remainder. Then the first b partitions each has a + 1 elements,
            and the last x-b partitions each has a elements.
            For example, if N=10, x =3, then 
               partition 0 ranges [0,3],
               partition 1 ranges [4,6],
               partition 2 ranges [7,9].
            This also takes care of the situation of (x&gt;N), the last x-N partitions are empty enumerators. 
            An empty enumerator is indicated by 
                 (m_startIndex == list.Count &amp;&amp; m_endIndex == list.Count -1)
            </summary>
      <param name="partitionCount">specified number of partitions</param>
      <returns>a list of partitions</returns>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2.SourceCount">
      <summary>
            Abstract method to return the number of elements in the source data
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1">
      <summary>
            Static Partition for IList/Array.
            This class implements all methods required by IEnumerator interface, except for the Current property.
            Current Property is different for IList and Array. Arrays calls 'ldelem' instructions for faster element 
            retrieval.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.#ctor(System.Int32,System.Int32)">
      <summary>
            Constructs an instance of StaticIndexRangePartition
            </summary>
      <param name="startIndex">the start index in the source collection for the current partition </param>
      <param name="endIndex">the end index in the source collection for the current partition</param>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.Dispose">
      <summary>
            We don't dispose the source for IList and array
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.MoveNext">
      <summary>
            Moves to the next item
            Before the first MoveNext is called: m_offset == m_startIndex-1;
            </summary>
      <returns>true if successful, false if there is no item left</returns>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.Current">
      <summary>
            Current Property is different for IList and Array. Arrays calls 'ldelem' instructions for faster 
            element retrieval.
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionerForIList`1">
      <summary>
            Inherits from StaticIndexRangePartitioner
            Provides customized implementation of SourceCount and CreatePartition
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionForIList`1">
      <summary>
            Inherits from StaticIndexRangePartition
            Provides customized implementation of Current property
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionerForArray`1">
      <summary>
            Inherits from StaticIndexRangePartitioner
            Provides customized implementation of SourceCount and CreatePartition for Array
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionForArray`1">
      <summary>
            Inherits from StaticIndexRangePartitioner
            Provides customized implementation of SourceCount and CreatePartition
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner.Shared`1">
      <summary>
            A very simple primitive that allows us to share a value across multiple threads.
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IList{``0},System.Boolean)">
      <summary>
            Creates an orderable partitioner from an <see cref="T:System.Collections.Generic.IList`1" />
            instance.
            </summary>
      <typeparam name="TSource">Type of the elements in source list.</typeparam>
      <param name="list">The list to be partitioned.</param>
      <param name="loadBalance">
            A Boolean value that indicates whether the created partitioner should dynamically
            load balance between partitions rather than statically partition.
            </param>
      <returns>
            An orderable partitioner based on the input list.
            </returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(``0[],System.Boolean)">
      <summary>
            Creates an orderable partitioner from a <see cref="T:System.Array" /> instance.
            </summary>
      <typeparam name="TSource">Type of the elements in source array.</typeparam>
      <param name="array">The array to be partitioned.</param>
      <param name="loadBalance">
            A Boolean value that indicates whether the created partitioner should dynamically load balance
            between partitions rather than statically partition.
            </param>
      <returns>
            An orderable partitioner based on the input array.
            </returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates an orderable partitioner from a <see cref="T:System.Collections.Generic.IEnumerable`1" /> instance.
            </summary>
      <typeparam name="TSource">Type of the elements in source enumerable.</typeparam>
      <param name="source">The enumerable to be partitioned.</param>
      <returns>
            An orderable partitioner based on the input array.
            </returns>
      <remarks>
            The ordering used in the created partitioner is determined by the natural order of the elements 
            as retrieved from the source enumerable.
            </remarks>
    </member>
    <member name="T:System.AggregateException">
      <summary>Represents one or more errors that occur during application execution.</summary>
      <remarks>
        <see cref="T:System.AggregateException" /> is used to consolidate multiple failures into a single, throwable
            exception object.
            </remarks>
    </member>
    <member name="M:System.AggregateException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException" /> class.
            </summary>
    </member>
    <member name="M:System.AggregateException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException" /> class with
            a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:System.AggregateException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException" /> class with a specified error
            message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="innerException" /> argument
            is null.</exception>
    </member>
    <member name="M:System.AggregateException.#ctor(System.Collections.Generic.IEnumerable{System.Exception})">
      <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException" /> class with
            references to the inner exceptions that are the cause of this exception.
            </summary>
      <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions" /> argument
            is null.</exception>
      <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions" /> is
            null.</exception>
    </member>
    <member name="M:System.AggregateException.#ctor(System.Exception[])">
      <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException" /> class with
            references to the inner exceptions that are the cause of this exception.
            </summary>
      <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions" /> argument
            is null.</exception>
      <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions" /> is
            null.</exception>
    </member>
    <member name="M:System.AggregateException.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Exception})">
      <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException" /> class with a specified error
            message and references to the inner exceptions that are the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions" /> argument
            is null.</exception>
      <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions" /> is
            null.</exception>
    </member>
    <member name="M:System.AggregateException.#ctor(System.String,System.Exception[])">
      <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException" /> class with a specified error
            message and references to the inner exceptions that are the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions" /> argument
            is null.</exception>
      <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions" /> is
            null.</exception>
    </member>
    <member name="M:System.AggregateException.#ctor(System.String,System.Collections.Generic.IList{System.Exception})">
      <summary>
            Allocates a new aggregate exception with the specified message and list of inner exceptions.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions" /> argument
            is null.</exception>
      <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions" /> is
            null.</exception>
    </member>
    <member name="M:System.AggregateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds
            the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that
            contains contextual information about the source or destination. </param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> argument is null.</exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The exception could not be deserialized correctly.</exception>
    </member>
    <member name="M:System.AggregateException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about
            the exception.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds
            the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that
            contains contextual information about the source or destination. </param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> argument is null.</exception>
    </member>
    <member name="M:System.AggregateException.GetBaseException">
      <summary>
            Returns the <see cref="T:System.AggregateException" /> that is the root cause of this exception.
            </summary>
    </member>
    <member name="M:System.AggregateException.Handle(System.Func{System.Exception,System.Boolean})">
      <summary>
            Invokes a handler on each <see cref="T:System.Exception" /> contained by this <see cref="T:System.AggregateException" />.
            </summary>
      <param name="predicate">The predicate to execute for each exception. The predicate accepts as an
            argument the <see cref="T:System.Exception" /> to be processed and returns a Boolean to indicate
            whether the exception was handled.</param>
      <remarks>
            Each invocation of the <paramref name="predicate" /> returns true or false to indicate whether the
            <see cref="T:System.Exception" /> was handled. After all invocations, if any exceptions went
            unhandled, all unhandled exceptions will be put into a new <see cref="T:System.AggregateException" />
            which will be thrown. Otherwise, the <see cref="M:System.AggregateException.Handle(System.Func{System.Exception,System.Boolean})" /> method simply returns. If any
            invocations of the <paramref name="predicate" /> throws an exception, it will halt the processing
            of any more exceptions and immediately propagate the thrown exception as-is.
            </remarks>
      <exception cref="T:System.AggregateException">An exception contained by this <see cref="T:System.AggregateException" /> was not handled.</exception>
      <exception cref="T:System.ArgumentNullException">The <paramref name="predicate" /> argument is
            null.</exception>
    </member>
    <member name="M:System.AggregateException.Flatten">
      <summary>
            Flattens an <see cref="T:System.AggregateException" /> instances into a single, new instance.
            </summary>
      <returns>A new, flattened <see cref="T:System.AggregateException" />.</returns>
      <remarks>
            If any inner exceptions are themselves instances of
            <see cref="T:System.AggregateException" />, this method will recursively flatten all of them. The
            inner exceptions returned in the new <see cref="T:System.AggregateException" />
            will be the union of all of the the inner exceptions from exception tree rooted at the provided
            <see cref="T:System.AggregateException" /> instance.
            </remarks>
    </member>
    <member name="M:System.AggregateException.ToString">
      <summary>
            Creates and returns a string representation of the current <see cref="T:System.AggregateException" />.
            </summary>
      <returns>A string representation of the current exception.</returns>
    </member>
    <member name="P:System.AggregateException.InnerExceptions">
      <summary>
            Gets a read-only collection of the <see cref="T:System.Exception" /> instances that caused the
            current exception.
            </summary>
    </member>
    <member name="T:System.Func_`6">
      <summary>
            Encapsulates a method that has five parameters and returns a value of the type specified by the TResult parameter.
            </summary>
    </member>
    <member name="T:System.Threading.CancellationToken">
      <summary>
            Propogates notification that operations should be canceled.
            </summary>
      <remarks>
        <para>
            A <see cref="T:System.Threading.CancellationToken" /> may be created directly in an unchangeable canceled or non-canceled state
            using the CancellationToken's constructors. However, to have a CancellationToken that can change 
            from a non-canceled to a canceled state, 
            <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> must be used.
            CancellationTokenSource exposes the associated CancellationToken that may be canceled by the source through its 
            <see cref="P:System.Threading.CancellationTokenSource.Token">Token</see> property. 
            </para>
        <para>
            Once canceled, a token may not transition to a non-canceled state, and a token whose 
            <see cref="P:System.Threading.CancellationToken.CanBeCanceled" /> is false will never change to one that can be canceled.
            </para>
        <para>
            All members of this struct are thread-safe and may be used concurrently from multiple threads.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.CancellationToken.#ctor(System.Threading.CancellationTokenSource)">
      <summary>
            Internal constructor only a CancellationTokenSource should create a CancellationToken
            </summary>
    </member>
    <member name="M:System.Threading.CancellationToken.#ctor(System.Boolean)">
      <summary>
            Initializes the <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            </summary>
      <param name="canceled">
            The canceled state for the token.
            </param>
      <remarks>
            Tokens created with this constructor will remain in the canceled state specified
            by the <paramref name="canceled" /> parameter.  If <paramref name="canceled" /> is false,
            both <see cref="P:System.Threading.CancellationToken.CanBeCanceled" /> and <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> will be false.
            If <paramref name="canceled" /> is true,
            both <see cref="P:System.Threading.CancellationToken.CanBeCanceled" /> and <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> will be true. 
            </remarks>
    </member>
    <member name="M:System.Threading.CancellationToken.Register(System.Action)">
      <summary>
            Registers a delegate that will be called when this <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.
            </summary>
      <remarks>
        <para>
            If this token is already in the canceled state, the
            delegate will be run immediately and synchronously. Any exception the delegate generates will be
            propogated out of this method call.
            </para>
        <para>
            The current <see cref="T:System.Threading.ExecutionContext">ExecutionContext</see>, if one exists, will be captured
            along with the delegate and will be used when executing it.
            </para>
      </remarks>
      <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
      <returns>The <see cref="T:System.Threading.CancellationTokenRegistration" /> instance that can 
            be used to deregister the callback.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="callback" /> is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The associated <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
    </member>
    <member name="M:System.Threading.CancellationToken.Register(System.Action,System.Boolean)">
      <summary>
            Registers a delegate that will be called when this 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.
            </summary>
      <remarks>
        <para>
            If this token is already in the canceled state, the
            delegate will be run immediately and synchronously. Any exception the delegate generates will be
            propogated out of this method call.
            </para>
        <para>
            The current <see cref="T:System.Threading.ExecutionContext">ExecutionContext</see>, if one exists, will be captured
            along with the delegate and will be used when executing it.
            </para>
      </remarks>
      <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
      <param name="useSynchronizationContext">A Boolean value that indicates whether to capture
            the current <see cref="T:System.Threading.SynchronizationContext">SynchronizationContext</see> and use it
            when invoking the <paramref name="callback" />.</param>
      <returns>The <see cref="T:System.Threading.CancellationTokenRegistration" /> instance that can 
            be used to deregister the callback.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="callback" /> is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The associated <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
    </member>
    <member name="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)">
      <summary>
            Registers a delegate that will be called when this 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.
            </summary>
      <remarks>
        <para>
            If this token is already in the canceled state, the
            delegate will be run immediately and synchronously. Any exception the delegate generates will be
            propogated out of this method call.
            </para>
        <para>
            The current <see cref="T:System.Threading.ExecutionContext">ExecutionContext</see>, if one exists, will be captured
            along with the delegate and will be used when executing it.
            </para>
      </remarks>
      <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
      <param name="state">The state to pass to the <paramref name="callback" /> when the delegate is invoked.  This may be null.</param>
      <returns>The <see cref="T:System.Threading.CancellationTokenRegistration" /> instance that can 
            be used to deregister the callback.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="callback" /> is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The associated <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
    </member>
    <member name="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object,System.Boolean)">
      <summary>
            Registers a delegate that will be called when this 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.
            </summary>
      <remarks>
        <para>
            If this token is already in the canceled state, the
            delegate will be run immediately and synchronously. Any exception the delegate generates will be
            propogated out of this method call.
            </para>
        <para>
            The current <see cref="T:System.Threading.ExecutionContext">ExecutionContext</see>, if one exists, 
            will be captured along with the delegate and will be used when executing it.
            </para>
      </remarks>
      <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
      <param name="state">The state to pass to the <paramref name="callback" /> when the delegate is invoked.  This may be null.</param>
      <param name="useSynchronizationContext">A Boolean value that indicates whether to capture
            the current <see cref="T:System.Threading.SynchronizationContext">SynchronizationContext</see> and use it
            when invoking the <paramref name="callback" />.</param>
      <returns>The <see cref="T:System.Threading.CancellationTokenRegistration" /> instance that can 
            be used to deregister the callback.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="callback" /> is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The associated <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
    </member>
    <member name="M:System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)">
      <summary>
            Determines whether the current <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instance is equal to the 
            specified token.
            </summary>
      <param name="other">The other <see cref="T:System.Threading.CancellationToken">CancellationToken</see> to which to compare this
            instance.</param>
      <returns>True if the instances are equal; otherwise, false. Two tokens are equal if they are associated
            with the same <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> or if they were both constructed 
            from public CancellationToken constructors and their <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> values are equal.</returns>
    </member>
    <member name="M:System.Threading.CancellationToken.Equals(System.Object)">
      <summary>
            Determines whether the current <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instance is equal to the 
            specified <see cref="T:System.Object" />.
            </summary>
      <param name="other">The other object to which to compare this instance.</param>
      <returns>True if <paramref name="other" /> is a <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            and if the two instances are equal; otherwise, false. Two tokens are equal if they are associated
            with the same <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> or if they were both constructed 
            from public CancellationToken constructors and their <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> values are equal.</returns>
      <exception cref="T:System.ObjectDisposedException">An associated <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
    </member>
    <member name="M:System.Threading.CancellationToken.GetHashCode">
      <summary>
            Serves as a hash function for a <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            </summary>
      <returns>A hash code for the current <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instance.</returns>
    </member>
    <member name="M:System.Threading.CancellationToken.op_Equality(System.Threading.CancellationToken,System.Threading.CancellationToken)">
      <summary>
            Determines whether two <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instances are equal.
            </summary>
      <param name="left">The first instance.</param>
      <param name="right">The second instance.</param>
      <returns>True if the instances are equal; otherwise, false.</returns>
      <exception cref="T:System.ObjectDisposedException">An associated <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
    </member>
    <member name="M:System.Threading.CancellationToken.op_Inequality(System.Threading.CancellationToken,System.Threading.CancellationToken)">
      <summary>
            Determines whether two <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instances are not equal.
            </summary>
      <param name="left">The first instance.</param>
      <param name="right">The second instance.</param>
      <returns>True if the instances are not equal; otherwise, false.</returns>
      <exception cref="T:System.ObjectDisposedException">An associated <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
    </member>
    <member name="M:System.Threading.CancellationToken.ThrowIfCancellationRequested">
      <summary>
            Throws a <see cref="T:System.OperationCanceledException">OperationCanceledException</see> if
            this token has had cancellation requested.
            </summary>
      <remarks>
            This method provides functionality equivalent to:
            <code>
            if (token.IsCancellationRequested) 
               throw new OperationCanceledException(token);
            </code></remarks>
      <exception cref="T:System.OperationCanceledException">The token has had cancellation requested.</exception>
      <exception cref="T:System.ObjectDisposedException">The associated <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
    </member>
    <member name="P:System.Threading.CancellationToken.None">
      <summary>
            Returns an empty CancellationToken value.
            </summary>
      <remarks>
            The <see cref="T:System.Threading.CancellationToken" /> value returned by this property will be non-cancelable by default.
            </remarks>
    </member>
    <member name="P:System.Threading.CancellationToken.IsCancellationRequested">
      <summary>
            Gets whether cancellation has been requested for this token.
            </summary>
      <value>Whether cancellation has been requested for this token.</value>
      <remarks>
        <para>
            This property indicates whether cancellation has been requested for this token, 
            either through the token initially being construted in a canceled state, or through
            calling <see cref="M:System.Threading.CancellationTokenSource.Cancel">Cancel</see> 
            on the token's associated <see cref="T:System.Threading.CancellationTokenSource" />.
            </para>
        <para>
            If this property is true, it only guarantees that cancellation has been requested.  
            It does not guarantee that every registered handler
            has finished executing, nor that cancellation requests have finished propagating
            to all registered handlers.  Additional synchronization may be required,
            particularly in situations where related objects are being canceled concurrently.
            </para>
      </remarks>
    </member>
    <member name="P:System.Threading.CancellationToken.CanBeCanceled">
      <summary>
            Gets whether this token is capable of being in the canceled state.
            </summary>
      <remarks>
            If CanBeCanceled returns false, it is guaranteed that the token will never transition
            into a canceled state, meaning that <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> will never
            return true.
            </remarks>
    </member>
    <member name="P:System.Threading.CancellationToken.WaitHandle">
      <summary>
            Gets a <see cref="T:System.Threading.WaitHandle" /> that is signaled when the token is canceled.</summary>
      <remarks>
            Accessing this property causes a <see cref="T:System.Threading.WaitHandle">WaitHandle</see>
            to be instantiated.  It is preferable to only use this property when necessary, and to then
            dispose the associated <see cref="T:System.Threading.CancellationTokenSource" /> instance at the earliest opportunity (disposing
            the source will dispose of this allocated handle).  The handle should not be closed or disposed directly.
            </remarks>
      <exception cref="T:System.ObjectDisposedException">The associated <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
    </member>
    <member name="T:System.Threading.CancellationTokenRegistration">
      <summary>
            Represents a callback delegate that has been registered with a <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            </summary>
      <remarks>
            To unregister a callback, dispose the corresponding Registration instance.
            </remarks>
    </member>
    <member name="M:System.Threading.CancellationTokenRegistration.TryDeregister">
      <summary>
            Attempts to deregister the item. If it's already being run, this may fail.
            Entails a full memory fence.
            </summary>
      <returns>True if the callback was found and deregistered, false otherwise.</returns>
    </member>
    <member name="M:System.Threading.CancellationTokenRegistration.Dispose">
      <summary>
            Disposes of the registration and unregisters the target callback from the associated 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            If the target callback is currently executing this method will wait until it completes, except
            in the degenerate cases where a callback method deregisters itself.
            </summary>
    </member>
    <member name="M:System.Threading.CancellationTokenRegistration.op_Equality(System.Threading.CancellationTokenRegistration,System.Threading.CancellationTokenRegistration)">
      <summary>
            Determines whether two <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see>
            instances are equal.
            </summary>
      <param name="left">The first instance.</param>
      <param name="right">The second instance.</param>
      <returns>True if the instances are equal; otherwise, false.</returns>
    </member>
    <member name="M:System.Threading.CancellationTokenRegistration.op_Inequality(System.Threading.CancellationTokenRegistration,System.Threading.CancellationTokenRegistration)">
      <summary>
            Determines whether two <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> instances are not equal.
            </summary>
      <param name="left">The first instance.</param>
      <param name="right">The second instance.</param>
      <returns>True if the instances are not equal; otherwise, false.</returns>
    </member>
    <member name="M:System.Threading.CancellationTokenRegistration.Equals(System.Object)">
      <summary>
            Determines whether the current <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> instance is equal to the 
            specified <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The other object to which to compare this instance.</param>
      <returns>True, if both this and <paramref name="obj" /> are equal. False, otherwise.
            Two <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> instances are equal if
            they both refer to the output of a single call to the same Register method of a 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see>. 
            </returns>
    </member>
    <member name="M:System.Threading.CancellationTokenRegistration.Equals(System.Threading.CancellationTokenRegistration)">
      <summary>
            Determines whether the current <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instance is equal to the 
            specified <see cref="T:System.Object" />.
            </summary>
      <param name="other">The other <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> to which to compare this instance.</param>
      <returns>True, if both this and <paramref name="other" /> are equal. False, otherwise.
            Two <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> instances are equal if
            they both refer to the output of a single call to the same Register method of a 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see>. 
            </returns>
    </member>
    <member name="M:System.Threading.CancellationTokenRegistration.GetHashCode">
      <summary>
            Serves as a hash function for a <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration.</see>.
            </summary>
      <returns>A hash code for the current <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> instance.</returns>
    </member>
    <member name="T:System.Threading.CancellationTokenSource">
      <summary>
            Signals to a <see cref="T:System.Threading.CancellationToken" /> that it should be canceled.
            </summary>
      <remarks>
        <para>
          <see cref="T:System.Threading.CancellationTokenSource" /> is used to instantiate a <see cref="T:System.Threading.CancellationToken" />
            (via the source's <see cref="P:System.Threading.CancellationTokenSource.Token">Token</see> property)
            that can be handed to operations that wish to be notified of cancellation or that can be used to
            register asynchronous operations for cancellation. That token may have cancellation requested by
            calling to the source's <see cref="M:System.Threading.CancellationTokenSource.Cancel">Cancel</see>
            method.
            </para>
        <para>
            All members of this class, except <see cref="M:System.Threading.CancellationTokenSource.Dispose">Dispose</see>, are thread-safe and may be used
            concurrently from multiple threads.
            </para>
      </remarks>
    </member>
    <member name="F:System.Threading.CancellationTokenSource.m_threadIDExecutingCallbacks">
            The ID of the thread currently executing the main body of CTS.Cancel()
            this helps us to know if a call to ctr.Dispose() is running 'within' a cancellation callback.
            This is updated as we move between the main thread calling cts.Cancel() and any syncContexts that are used to 
            actually run the callbacks.
        </member>
    <member name="M:System.Threading.CancellationTokenSource.#ctor">
      <summary>
            Initializes the <see cref="T:System.Threading.CancellationTokenSource" />.
            </summary>
    </member>
    <member name="M:System.Threading.CancellationTokenSource.Cancel">
      <summary>
            Communicates a request for cancellation.
            </summary>
      <remarks>
        <para>
            The associated <see cref="T:System.Threading.CancellationToken" /> will be
            notified of the cancellation and will transition to a state where 
            <see cref="P:System.Threading.CancellationToken.IsCancellationRequested">IsCancellationRequested</see> returns true. 
            Any callbacks or cancelable operations
            registered with the <see cref="T:System.Threading.CancellationToken" />  will be executed.
            </para>
        <para>
            Cancelable operations and callbacks registered with the token should not throw exceptions.
            However, this overload of Cancel will aggregate any exceptions thrown into a <see cref="T:System.AggregateException" />,
            such that one callback throwing an exception will not prevent other registered callbacks from being executed.
            </para>
        <para>
            The <see cref="T:System.Threading.ExecutionContext" /> that was captured when each callback was registered
            will be reestablished when the callback is invoked.
            </para>
      </remarks>
      <exception cref="T:System.AggregateException">An aggregate exception containing all the exceptions thrown
            by the registered callbacks on the associated <see cref="T:System.Threading.CancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException">This <see cref="T:System.Threading.CancellationTokenSource" /> has been disposed.</exception>
    </member>
    <member name="M:System.Threading.CancellationTokenSource.Cancel(System.Boolean)">
      <summary>
            Communicates a request for cancellation.
            </summary>
      <remarks>
        <para>
            The associated <see cref="T:System.Threading.CancellationToken" /> will be
            notified of the cancellation and will transition to a state where 
            <see cref="P:System.Threading.CancellationToken.IsCancellationRequested">IsCancellationRequested</see> returns true. 
            Any callbacks or cancelable operations
            registered with the <see cref="T:System.Threading.CancellationToken" />  will be executed.
            </para>
        <para>
            Cancelable operations and callbacks registered with the token should not throw exceptions. 
            If <paramref name="throwOnFirstException" /> is true, an exception will immediately propagate out of the
            call to Cancel, preventing the remaining callbacks and cancelable operations from being processed.
            If <paramref name="throwOnFirstException" /> is false, this overload will aggregate any 
            exceptions thrown into a <see cref="T:System.AggregateException" />,
            such that one callback throwing an exception will not prevent other registered callbacks from being executed.
            </para>
        <para>
            The <see cref="T:System.Threading.ExecutionContext" /> that was captured when each callback was registered
            will be reestablished when the callback is invoked.
            </para>
      </remarks>
      <param name="throwOnFirstException">Specifies whether exceptions should immediately propagate.</param>
      <exception cref="T:System.AggregateException">An aggregate exception containing all the exceptions thrown
            by the registered callbacks on the associated <see cref="T:System.Threading.CancellationToken" />.</exception>
      <exception cref="T:System.ObjectDisposedException">This <see cref="T:System.Threading.CancellationTokenSource" /> has been disposed.</exception>
    </member>
    <member name="M:System.Threading.CancellationTokenSource.Dispose">
      <summary>
            Releases the resources used by this <see cref="T:System.Threading.CancellationTokenSource" />.
            </summary>
      <remarks>
            This method is not thread-safe for any other concurrent calls.
            </remarks>
    </member>
    <member name="M:System.Threading.CancellationTokenSource.ThrowIfDisposed">
      <summary>
            Throws an exception if the source has been disposed.
            </summary>
    </member>
    <member name="M:System.Threading.CancellationTokenSource.InternalGetStaticSource(System.Boolean)">
      <summary>
            InternalGetStaticSource()
            </summary>
      <param name="set">Whether the source should be set.</param>
      <returns>A static source to be shared among multiple tokens.</returns>
    </member>
    <member name="M:System.Threading.CancellationTokenSource.InternalRegister(System.Action{System.Object},System.Object,System.Threading.SynchronizationContext,System.Threading.ExecutionContext)">
      <summary>
            Registers a callback object. If cancellation has already occurred, the
            callback will have been run by the time this method returns.
            </summary>
    </member>
    <member name="M:System.Threading.CancellationTokenSource.NotifyCancellation(System.Boolean)">
      <summary>
      </summary>
    </member>
    <member name="M:System.Threading.CancellationTokenSource.ExecuteCallbackHandlers(System.Boolean)">
      <summary>
            Invoke the Canceled event.
            </summary>
      <remarks>
            The handlers are invoked synchronously in LIFO order.
            </remarks>
    </member>
    <member name="M:System.Threading.CancellationTokenSource.CreateLinkedTokenSource(System.Threading.CancellationToken,System.Threading.CancellationToken)">
      <summary>
            Creates a <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> that will be in the canceled state
            when any of the source tokens are in the canceled state.
            </summary>
      <param name="token1">The first <see cref="T:System.Threading.CancellationToken">CancellationToken</see> to observe.</param>
      <param name="token2">The second <see cref="T:System.Threading.CancellationToken">CancellationToken</see> to observe.</param>
      <returns>A <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> that is linked 
            to the source tokens.</returns>
      <exception cref="T:System.ObjectDisposedException">A <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with
            one of the source tokens has been disposed.</exception>
    </member>
    <member name="M:System.Threading.CancellationTokenSource.CreateLinkedTokenSource(System.Threading.CancellationToken[])">
      <summary>
            Creates a <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> that will be in the canceled state
            when any of the source tokens are in the canceled state.
            </summary>
      <param name="tokens">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instances to observe.</param>
      <returns>A <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> that is linked 
            to the source tokens.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tokens" /> is null.</exception>
      <exception cref="T:System.ObjectDisposedException">A <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with
            one of the source tokens has been disposed.</exception>
    </member>
    <member name="P:System.Threading.CancellationTokenSource.IsCancellationRequested">
      <summary>
            Gets whether cancellation has been requested for this <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see>.
            </summary>
      <value>Whether cancellation has been requested for this <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see>.</value>
      <remarks>
        <para>
            This property indicates whether cancellation has been requested for this token source, such as
            due to a call to its
            <see cref="M:System.Threading.CancellationTokenSource.Cancel">Cancel</see> method.
            </para>
        <para>
            If this property returns true, it only guarantees that cancellation has been requested. It does not
            guarantee that every handler registered with the corresponding token has finished executing, nor
            that cancellation requests have finished propagating to all registered handlers. Additional
            synchronization may be required, particularly in situations where related objects are being
            canceled concurrently.
            </para>
      </remarks>
    </member>
    <member name="P:System.Threading.CancellationTokenSource.IsCancellationCompleted">
      <summary>
            A simple helper to determine whether cancellation has finished.
            </summary>
    </member>
    <member name="P:System.Threading.CancellationTokenSource.IsDisposed">
      <summary>
            A simple helper to determine whether disposal has occured.
            </summary>
    </member>
    <member name="P:System.Threading.CancellationTokenSource.ThreadIDExecutingCallbacks">
      <summary>
            The ID of the thread that is running callbacks.
            </summary>
    </member>
    <member name="P:System.Threading.CancellationTokenSource.Token">
      <summary>
            Gets the <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            associated with this <see cref="T:System.Threading.CancellationTokenSource" />.
            </summary>
      <value>The <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            associated with this <see cref="T:System.Threading.CancellationTokenSource" />.</value>
      <exception cref="T:System.ObjectDisposedException">The token source has been
            disposed.</exception>
    </member>
    <member name="P:System.Threading.CancellationTokenSource.CanBeCanceled">
      <summary>
      </summary>
    </member>
    <member name="P:System.Threading.CancellationTokenSource.WaitHandle">
      <summary>
      </summary>
    </member>
    <member name="P:System.Threading.CancellationTokenSource.ExecutingCallback">
      <summary>
            The currently executing callback
            </summary>
    </member>
    <member name="T:System.Threading.CancellationCallbackInfo">
      <summary>
            A helper class for collating the various bits of information required to execute 
            cancellation callbacks.
            </summary>
    </member>
    <member name="M:System.Threading.CancellationCallbackInfo.ExecuteCallback">
      <summary>
            InternalExecuteCallbackSynchronously_GeneralPath
            This will be called on the target synchronization context, however, we still need to restore the required execution context
            </summary>
    </member>
    <member name="T:System.Threading.SparselyPopulatedArray`1">
      <summary>
            A sparsely populated array.  Elements can be sparse and some null, but this allows for
            lock-free additions and growth, and also for constant time removal (by nulling out).
            </summary>
      <typeparam name="T">The kind of elements contained within.</typeparam>
    </member>
    <member name="M:System.Threading.SparselyPopulatedArray`1.#ctor(System.Int32)">
      <summary>
            Allocates a new array with the given initial size.
            </summary>
      <param name="initialSize">How many array slots to pre-allocate.</param>
    </member>
    <member name="M:System.Threading.SparselyPopulatedArray`1.Add(`0)">
      <summary>
            Adds an element in the first available slot, beginning the search from the tail-to-head.
            If no slots are available, the array is grown.  The method doesn't return until successful.
            </summary>
      <param name="element">The element to add.</param>
      <returns>Information about where the add happened, to enable O(1) deregistration.</returns>
    </member>
    <member name="P:System.Threading.SparselyPopulatedArray`1.Head">
      <summary>
            The head of the doubly linked list.
            </summary>
    </member>
    <member name="P:System.Threading.SparselyPopulatedArray`1.Tail">
      <summary>
            The tail of the doubly linked list.
            </summary>
    </member>
    <member name="T:System.Threading.SparselyPopulatedArrayAddInfo`1">
      <summary>
            A struct to hold a link to the exact spot in an array an element was inserted, enabling
            constant time removal later on.
            </summary>
    </member>
    <member name="T:System.Threading.SparselyPopulatedArrayFragment`1">
      <summary>
            A fragment of a sparsely populated array, doubly linked.
            </summary>
      <typeparam name="T">The kind of elements contained within.</typeparam>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary>
            Represents a synchronization primitive that is signaled when its count reaches zero.
            </summary>
      <remarks>
            All public and protected members of <see cref="T:System.Threading.CountdownEvent" /> are thread-safe and may be used
            concurrently from multiple threads, with the exception of Dispose, which
            must only be used when all other operations on the <see cref="T:System.Threading.CountdownEvent" /> have
            completed, and Reset, which should only be used when no other threads are
            accessing the event.
            </remarks>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of <see cref="T:System.Threading.CountdownEvent" /> class with the
            specified count.
            </summary>
      <param name="initialCount">The number of signals required to set the <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> is less
            than 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary>
            Releases all resources used by the current instance of <see cref="T:System.Threading.CountdownEvent" />.
            </summary>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.CountdownEvent" />, <see cref="M:System.Threading.CountdownEvent.Dispose" /> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary>
            When overridden in a derived class, releases the unmanaged resources used by the
            <see cref="T:System.Threading.CountdownEvent" />, and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources; false to release
            only unmanaged resources.</param>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.CountdownEvent" />, <see cref="M:System.Threading.CountdownEvent.Dispose" /> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary>
            Registers a signal with the <see cref="T:System.Threading.CountdownEvent" />, decrementing its
            count.
            </summary>
      <returns>true if the signal caused the count to reach zero and the event was set; otherwise,
            false.</returns>
      <exception cref="T:System.InvalidOperationException">The current instance is already set.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary>
            Registers multiple signals with the <see cref="T:System.Threading.CountdownEvent" />,
            decrementing its count by the specified amount.
            </summary>
      <param name="signalCount">The number of signals to register.</param>
      <returns>true if the signals caused the count to reach zero and the event was set; otherwise,
            false.</returns>
      <exception cref="T:System.InvalidOperationException">
            The current instance is already set. -or- Or <paramref name="signalCount" /> is greater than <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> is less
            than 1.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary>
            Increments the <see cref="T:System.Threading.CountdownEvent" />'s current count by one.
            </summary>
      <exception cref="T:System.InvalidOperationException">The current instance is already
            set.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> is equal to <see cref="T:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">
            The current instance has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary>
            Attempts to increment the <see cref="T:System.Threading.CountdownEvent" />'s current count by one.
            </summary>
      <returns>true if the increment succeeded; otherwise, false. If <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> is
            already at zero. this will return false.</returns>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> is equal to <see cref="T:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary>
            Increments the <see cref="T:System.Threading.CountdownEvent" />'s current count by a specified
            value.
            </summary>
      <param name="signalCount">The value by which to increase <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> is less than
            0.</exception>
      <exception cref="T:System.InvalidOperationException">The current instance is already
            set.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> is equal to <see cref="T:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary>
            Attempts to increment the <see cref="T:System.Threading.CountdownEvent" />'s current count by a
            specified value.
            </summary>
      <param name="signalCount">The value by which to increase <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <returns>true if the increment succeeded; otherwise, false. If <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> is
            already at zero this will return false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> is less
            than 0.</exception>
      <exception cref="T:System.InvalidOperationException">The current instance is already
            set.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> is equal to <see cref="T:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary>
            Resets the <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> to the value of <see cref="P:System.Threading.CountdownEvent.InitialCount" />.
            </summary>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.CountdownEvent" />, Reset is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed..</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary>
            Resets the <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> to a specified value.
            </summary>
      <param name="count">The number of signals required to set the <see cref="T:System.Threading.CountdownEvent" />.</param>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.CountdownEvent" />, Reset is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is
            less than 0.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has alread been disposed.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary>
            Blocks the current thread until the <see cref="T:System.Threading.CountdownEvent" /> is set.
            </summary>
      <remarks>
            The caller of this method blocks indefinitely until the current instance is set. The caller will
            return immediately if the event is currently in a set state.
            </remarks>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary>
            Blocks the current thread until the <see cref="T:System.Threading.CountdownEvent" /> is set, while
            observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
      <remarks>
            The caller of this method blocks indefinitely until the current instance is set. The caller will
            return immediately if the event is currently in a set state.  If the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> being observed
            is canceled during the wait operation, an <see cref="T:System.OperationCanceledException" />
            will be thrown.
            </remarks>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> has been
            canceled.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary>
            Blocks the current thread until the <see cref="T:System.Threading.CountdownEvent" /> is set, using a
            <see cref="T:System.TimeSpan" /> to measure the time interval.
            </summary>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of
            milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to
            wait indefinitely.</param>
      <returns>true if the <see cref="T:System.Threading.CountdownEvent" /> was set; otherwise,
            false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
            Blocks the current thread until the <see cref="T:System.Threading.CountdownEvent" /> is set, using
            a <see cref="T:System.TimeSpan" /> to measure the time interval, while observing a
            <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of
            milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to
            wait indefinitely.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
      <returns>true if the <see cref="T:System.Threading.CountdownEvent" /> was set; otherwise,
            false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> has
            been canceled.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary>
            Blocks the current thread until the <see cref="T:System.Threading.CountdownEvent" /> is set, using a
            32-bit signed integer to measure the time interval.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to wait indefinitely.</param>
      <returns>true if the <see cref="T:System.Threading.CountdownEvent" /> was set; otherwise,
            false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>
            Blocks the current thread until the <see cref="T:System.Threading.CountdownEvent" /> is set, using a
            32-bit signed integer to measure the time interval, while observing a
            <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to wait indefinitely.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
      <returns>true if the <see cref="T:System.Threading.CountdownEvent" /> was set; otherwise,
            false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> has
            been canceled.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.ThrowIfDisposed">
      <summary>
            Throws an exception if the latch has been disposed.
            </summary>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary>
            Gets the number of remaining signals required to set the event.
            </summary>
      <value>
            The number of remaining signals required to set the event.
            </value>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary>
            Gets the numbers of signals initially required to set the event.
            </summary>
      <value>
            The number of signals initially required to set the event.
            </value>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary>
            Determines whether the event is set.
            </summary>
      <value>true if the event is set; otherwise, false.</value>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary>
            Gets a <see cref="T:System.Threading.WaitHandle" /> that is used to wait for the event to be set. 
            </summary>
      <value>A <see cref="T:System.Threading.WaitHandle" /> that is used to wait for the event to be set.</value>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
      <remarks>
        <see cref="P:System.Threading.CountdownEvent.WaitHandle" /> should only be used if it's needed for integration with code bases
            that rely on having a WaitHandle.  If all that's needed is to wait for the <see cref="T:System.Threading.CountdownEvent" />
            to be set, the <see cref="M:System.Threading.CountdownEvent.Wait" /> method should be preferred.
            </remarks>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary>
            Provides a slimmed down version of <see cref="T:System.Threading.ManualResetEvent" />.
            </summary>
      <remarks>
            All public and protected members of <see cref="T:System.Threading.ManualResetEventSlim" /> are thread-safe and may be used
            concurrently from multiple threads, with the exception of Dispose, which
            must only be used when all other operations on the <see cref="T:System.Threading.ManualResetEventSlim" /> have
            completed, and Reset, which should only be used when no other threads are
            accessing the event.
            </remarks>
    </member>
    <member name="F:System.Threading.ManualResetEventSlim.s_cancellationTokenCallback">
      <summary>
            Private helper method to wake up waiters when a cancellationToken gets canceled.
            </summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.ManualResetEventSlim" />
            class with an initial state of nonsignaled.
            </summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.ManualResetEventSlim" />
            class with a Boolen value indicating whether to set the intial state to signaled.
            </summary>
      <param name="initialState">true to set the initial state signaled; false to set the initial state
            to nonsignaled.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.ManualResetEventSlim" />
            class with a Boolen value indicating whether to set the intial state to signaled and a specified
            spin count.
            </summary>
      <param name="initialState">true to set the initial state to signaled; false to set the initial state
            to nonsignaled.</param>
      <param name="spinCount">The number of spin waits that will occur before falling back to a true
            wait.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="spinCount" /> is less than
            0 or greater than the maximum allowed value.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Initialize(System.Boolean,System.Int32)">
      <summary>
            Initializes the internal state of the event.
            </summary>
      <param name="initialState">Whether the event is set initially or not.</param>
      <param name="spinCount">The spin count that decides when the event will block.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.EnsureLockObjectCreated">
      <summary>
            Helper to ensure the lock object is created before first use.
            </summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.LazyInitializeEvent">
      <summary>
            This method lazily initializes the event object. It uses CAS to guarantee that
            many threads racing to call this at once don't result in more than one event
            being stored and used. The event will be signaled or unsignaled depending on
            the state of the thin-event itself, with synchronization taken into account.
            </summary>
      <returns>True if a new event was created and stored, false otherwise.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary>
            Sets the state of the event to signaled, which allows one or more threads waiting on the event to
            proceed.
            </summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set(System.Boolean)">
      <summary>
            Private helper to actually perform the Set.
            </summary>
      <param name="duringCancellation">Indicates whether we are calling Set() during cancellation.</param>
      <exception cref="T:System.OperationCanceledException">The object has been canceled.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary>
            Sets the state of the event to nonsignaled, which causes threads to block.
            </summary>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ManualResetEventSlim" />, <see cref="M:System.Threading.ManualResetEventSlim.Reset" /> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim" /> is set.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
      <remarks>
            The caller of this method blocks indefinitely until the current instance is set. The caller will
            return immediately if the event is currently in a set state.
            </remarks>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim" /> receives a signal,
            while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
      <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
      <exception cref="T:System.OperationCanceledExcepton">
        <paramref name="cancellationToken" /> was
            canceled.</exception>
      <remarks>
            The caller of this method blocks indefinitely until the current instance is set. The caller will
            return immediately if the event is currently in a set state.
            </remarks>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim" /> is set, using a
            <see cref="T:System.TimeSpan" /> to measure the time interval.
            </summary>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <returns>true if the <see cref="T:System.Threading.ManualResetEventSlim" /> was set; otherwise,
            false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim" /> is set, using a
            <see cref="T:System.TimeSpan" /> to measure the time interval, while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
      <returns>true if the <see cref="T:System.Threading.ManualResetEventSlim" /> was set; otherwise,
            false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.Threading.OperationCanceledException">
        <paramref name="cancellationToken" /> was canceled.</exception>
      <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim" /> is set, using a
            32-bit signed integer to measure the time interval.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to wait indefinitely.</param>
      <returns>true if the <see cref="T:System.Threading.ManualResetEventSlim" /> was set; otherwise,
            false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim" /> is set, using a
            32-bit signed integer to measure the time interval, while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to wait indefinitely.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
      <returns>true if the <see cref="T:System.Threading.ManualResetEventSlim" /> was set; otherwise,
            false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
      <exception cref="T:System.Threading.OperationCanceledException">
        <paramref name="cancellationToken" /> was canceled.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary>
            Releases all resources used by the current instance of <see cref="T:System.Threading.ManualResetEventSlim" />.
            </summary>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ManualResetEventSlim" />, <see cref="M:System.Threading.ManualResetEventSlim.Dispose" /> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary>
            When overridden in a derived class, releases the unmanaged resources used by the 
            <see cref="T:System.Threading.ManualResetEventSlim" />, and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources;
            false to release only unmanaged resources.</param>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ManualResetEventSlim" />, <see cref="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)" /> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.ThrowIfDisposed">
      <summary>
            Throw ObjectDisposedException if the MRES is disposed
            </summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.UpdateStateAtomically(System.Int32,System.Int32)">
      <summary>
            Private helper method for updating parts of a bit-string state value.
            Mainly called from the IsSet and Waiters properties setters
            </summary>
      <remarks>
            Note: the parameter types must be int as CompareExchange cannot take a Uint
            </remarks>
      <param name="newBits">The new value</param>
      <param name="updateBitsMask">The mask used to set the bits</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.ExtractStatePortionAndShiftRight(System.Int32,System.Int32,System.Int32)">
      <summary>
            Private helper method - performs Mask and shift, particular helpful to extract a field from a packed word.
            eg ExtractStatePortionAndShiftRight(0x12345678, 0xFF000000, 24) =&gt; 0x12, ie extracting the top 8-bits as a simple integer 
            
            ?? is there a common place to put this rather than being private to MRES?
            </summary>
      <param name="state">
      </param>
      <param name="mask">
      </param>
      <param name="rightBitShiftCount">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.ExtractStatePortion(System.Int32,System.Int32)">
      <summary>
            Performs a Mask operation, but does not perform the shift.
            This is acceptable for boolean values for which the shift is unnecessary
            eg (val &amp; Mask) != 0 is an appropriate way to extract a boolean rather than using
            ((val &amp; Mask) &gt;&gt; shiftAmount) == 1
            
            ?? is there a common place to put this rather than being private to MRES?
            </summary>
      <param name="state">
      </param>
      <param name="mask">
      </param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.UpdateTimeOut(System.Int64,System.Int32)">
      <summary>
            Helper function to measure and update the wait time
            </summary>
      <param name="startTimeTicks"> The first time (in Ticks) observed when the wait started.</param>
      <param name="originalWaitMillisecondsTimeout">The orginal wait timeoutout in milliseconds.</param>
      <returns>The new wait time in milliseconds, -1 if the time expired, -2 if overflow in counters
            has occurred.</returns>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary>
            Gets the underlying <see cref="T:System.Threading.WaitHandle" /> object for this <see cref="T:System.Threading.ManualResetEventSlim" />.
            </summary>
      <value>The underlying <see cref="T:System.Threading.WaitHandle" /> event object fore this <see cref="T:System.Threading.ManualResetEventSlim" />.</value>
      <remarks>
            Accessing this property forces initialization of an underlying event object if one hasn't
            already been created.  To simply wait on this <see cref="T:System.Threading.ManualResetEventSlim" />, 
            the public Wait methods should be preferred.
            </remarks>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary>
            Gets whether the event is set.
            </summary>
      <value>true if the event has is set; otherwise, false.</value>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary>
            Gets the number of spin waits that will be occur before falling back to a true wait.
            </summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.Waiters">
      <summary>
            How many threads are waiting.
            </summary>
    </member>
    <member name="T:System.Lazy`1">
      <summary>
            Provides support for lazy initialization.
            </summary>
      <typeparam name="T">Specifies the type of element being laziliy initialized.</typeparam>
      <remarks>
        <para>
            By default, all public and protected members of <see cref="T:System.Lazy`1" /> are thread-safe and may be used
            concurrently from multiple threads.  These thread-safety guarantees may be removed optionally and per instance
            using parameters to the type's constructors.
            </para>
      </remarks>
    </member>
    <member name="T:System.Lazy`1.Boxed">
      <summary>
            wrapper class to box the initialized value, this is mainly created to avoid boxing/unboxing the value each time the value is called in case T is 
            a value type
            </summary>
    </member>
    <member name="T:System.Lazy`1.LazyInternalExceptionHolder">
      <summary>
            Wrapper class to wrap the excpetion thrown by the value factory
            </summary>
    </member>
    <member name="M:System.Lazy`1.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}" /> class that 
            uses <typeparamref name="T" />'s default constructor for lazy initialization.
            </summary>
      <remarks>
            An instance created with this constructor may be used concurrently from multiple threads.
            </remarks>
    </member>
    <member name="M:System.Lazy`1.#ctor(System.Func{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}" /> class that uses a
            specified initialization function.
            </summary>
      <param name="valueFactory">
            The <see cref="T:System.Func{T}" /> invoked to produce the lazily-initialized value when it is
            needed.
            </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> is a null
            reference (Nothing in Visual Basic).</exception>
      <remarks>
            An instance created with this constructor may be used concurrently from multiple threads.
            </remarks>
    </member>
    <member name="M:System.Lazy`1.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}" />
            class that uses <typeparamref name="T" />'s default constructor and a specified thread-safety mode.
            </summary>
      <param name="isThreadSafe">true if this instance should be usable by multiple threads concurrently; false if the instance will only be used by one thread at a time.
            </param>
    </member>
    <member name="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}" />
            class that uses <typeparamref name="T" />'s default constructor and a specified thread-safety mode.
            </summary>
      <param name="mode">The lazy thread-safety mode mode</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="mode" /> mode contains an invalid valuee</exception>
    </member>
    <member name="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}" /> class
            that uses a specified initialization function and a specified thread-safety mode.
            </summary>
      <param name="valueFactory">
            The <see cref="T:System.Func{T}" /> invoked to produce the lazily-initialized value when it is needed.
            </param>
      <param name="isThreadSafe">true if this instance should be usable by multiple threads concurrently; false if the instance will only be used by one thread at a time.
            </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> is
            a null reference (Nothing in Visual Basic).</exception>
    </member>
    <member name="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}" /> class
            that uses a specified initialization function and a specified thread-safety mode.
            </summary>
      <param name="valueFactory">
            The <see cref="T:System.Func{T}" /> invoked to produce the lazily-initialized value when it is needed.
            </param>
      <param name="mode">The lazy thread-safety mode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> is
            a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="mode" /> mode contains an invalid value.</exception>
    </member>
    <member name="M:System.Lazy`1.GetObjectFromMode(System.Threading.LazyThreadSafetyMode)">
      <summary>
            Static helper function that returns an object based on the given mode. it also throws an exception if the mode is invalid
            </summary>
    </member>
    <member name="M:System.Lazy`1.OnSerializing(System.Runtime.Serialization.StreamingContext)">
      <summary>Forces initialization during serialization.</summary>
      <param name="context">The StreamingContext for the serialization operation.</param>
    </member>
    <member name="M:System.Lazy`1.ToString">
      <summary>Creates and returns a string representation of this instance.</summary>
      <returns>The result of calling <see cref="M:System.Object.ToString" /> on the <see cref="P:System.Lazy`1.Value" />.</returns>
      <exception cref="T:System.NullReferenceException">
            The <see cref="P:System.Lazy`1.Value" /> is null.
            </exception>
    </member>
    <member name="M:System.Lazy`1.LazyInitValue">
      <summary>
            local helper method to initialize the value 
            </summary>
      <returns>The inititialized T value</returns>
    </member>
    <member name="M:System.Lazy`1.CreateValue">
      <summary>Creates an instance of T using m_valueFactory in case its not null or use reflection to create a new T()</summary>
      <returns>An instance of Boxed.</returns>
    </member>
    <member name="P:System.Lazy`1.ValueForDebugDisplay">
      <summary>Gets the value of the Lazy&lt;T&gt; for debugging display purposes.</summary>
    </member>
    <member name="P:System.Lazy`1.Mode">
      <summary>
            Gets a value indicating whether this instance may be used concurrently from multiple threads.
            </summary>
    </member>
    <member name="P:System.Lazy`1.IsValueFaulted">
      <summary>
            Gets whether the value creation is faulted or not
            </summary>
    </member>
    <member name="P:System.Lazy`1.IsValueCreated">
      <summary>Gets a value indicating whether the <see cref="T:System.Lazy{T}" /> has been initialized.
            </summary>
      <value>true if the <see cref="T:System.Lazy{T}" /> instance has been initialized;
            otherwise, false.</value>
      <remarks>
            The initialization of a <see cref="T:System.Lazy{T}" /> instance may result in either
            a value being produced or an exception being thrown.  If an exception goes unhandled during initialization, 
            <see cref="P:System.Lazy`1.IsValueCreated" /> will return false.
            </remarks>
    </member>
    <member name="T:System.System_LazyDebugView`1">
      <summary>A debugger view of the Lazy&lt;T&gt; to surface additional debugging properties and 
            to ensure that the Lazy&lt;T&gt; does not become initialized if it was not already.</summary>
    </member>
    <member name="M:System.System_LazyDebugView`1.#ctor(System.Lazy{`0})">
      <summary>Constructs a new debugger view object for the provided Lazy object.</summary>
      <param name="lazy">A Lazy object to browse in the debugger.</param>
    </member>
    <member name="P:System.System_LazyDebugView`1.IsValueCreated">
      <summary>Returns whether the Lazy object is initialized or not.</summary>
    </member>
    <member name="P:System.System_LazyDebugView`1.Value">
      <summary>Returns the value of the Lazy object.</summary>
    </member>
    <member name="P:System.System_LazyDebugView`1.Mode">
      <summary>Returns the execution mode of the Lazy object</summary>
    </member>
    <member name="P:System.System_LazyDebugView`1.IsValueFaulted">
      <summary>Returns the execution mode of the Lazy object</summary>
    </member>
    <member name="T:System.Threading.LazyThreadSafetyMode">
      <summary>
            Specifies how a <see cref="T:System.Threading.Lazy{T}" /> instance should synchronize access among multiple threads.
            </summary>
    </member>
    <member name="F:System.Threading.LazyThreadSafetyMode.None">
      <summary>
            This mode makes no guarantees around the thread-safety of the <see cref="T:System.Threading.Lazy{T}" /> instance.  If used from multiple threads, the behavior of the <see cref="T:System.Threading.Lazy{T}" /> is undefined.
            This mode should be used when a <see cref="T:System.Threading.Lazy{T}" /> is guaranteed to never be initialized from more than one thread simultaneously and high performance is crucial. 
            If valueFactory throws an exception when the <see cref="T:System.Threading.Lazy{T}" /> is initialized, the exception will be cached and returned on subsequent accesses to Value. Also, if valueFactory recursively
            accesses Value on this <see cref="T:System.Threading.Lazy{T}" /> instance, a <see cref="T:System.InvalidOperationException" /> will be thrown.
            </summary>
    </member>
    <member name="F:System.Threading.LazyThreadSafetyMode.PublicationOnly">
      <summary>
            When multiple threads attempt to simultaneously initialize a <see cref="T:System.Threading.Lazy{T}" /> instance, this mode allows each thread to execute the
            valueFactory but only the first thread to complete initialization will be allowed to set the final value of the  <see cref="T:System.Threading.Lazy{T}" />.
            Once initialized successfully, any future calls to Value will return the cached result.  If valueFactory throws an exception on any thread, that exception will be
            propagated out of Value. If any thread executes valueFactory without throwing an exception and, therefore, successfully sets the value, that value will be returned on
            subsequent accesses to Value from any thread.  If no thread succeeds in setting the value, IsValueCreated will remain false and subsequent accesses to Value will result in
            the valueFactory delegate re-executing.  Also, if valueFactory recursively accesses Value on this  <see cref="T:System.Threading.Lazy{T}" /> instance, an exception will NOT be thrown.
            </summary>
    </member>
    <member name="F:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication">
      <summary>
            This mode uses locks to ensure that only a single thread can initialize a <see cref="T:System.Threading.Lazy{T}" /> instance in a thread-safe manner.  In general,
            taken if this mode is used in conjunction with a <see cref="T:System.Threading.Lazy{T}" /> valueFactory delegate that uses locks internally, a deadlock can occur if not
            handled carefully.  If valueFactory throws an exception when the<see cref="T:System.Threading.Lazy{T}" /> is initialized, the exception will be cached and returned on
            subsequent accesses to Value. Also, if valueFactory recursively accesses Value on this <see cref="T:System.Threading.Lazy{T}" /> instance, a  <see cref="T:System.InvalidOperationException" /> will be thrown.
            </summary>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary>
            Provides lazy initialization routines.
            </summary>
      <remarks>
            These routines avoid needing to allocate a dedicated, lazy-initialization instance, instead using
            references to ensure targets have been initialized as they are accessed.
            </remarks>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary>
            Initializes a target reference type with the type's default constructor if the target has not
            already been initialized.
            </summary>
      <typeparam name="T">The refence type of the reference to be initialized.</typeparam>
      <param name="target">A reference of type <typeparamref name="T" /> to initialize if it has not
            already been initialized.</param>
      <returns>The initialized reference of type <typeparamref name="T" />.</returns>
      <exception cref="T:System.MissingMemberException">Type <typeparamref name="T" /> does not have a default
            constructor.</exception>
      <exception cref="T:System.MemberAccessException">
            Permissions to access the constructor of type <typeparamref name="T" /> were missing.
            </exception>
      <remarks>
        <para>
            This method may only be used on reference types. To ensure initialization of value
            types, see other overloads of EnsureInitialized.
            </para>
        <para>
            This method may be used concurrently by multiple threads to initialize <paramref name="target" />.  
            In the event that multiple threads access this method concurrently, multiple instances of <typeparamref name="T" />
            may be created, but only one will be stored into <paramref name="target" />. In such an occurrence, this method will not dispose of the
            objects that were not stored.  If such objects must be disposed, it is up to the caller to determine 
            if an object was not used and to then dispose of the object appropriately.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary>
            Initializes a target reference type using the specified function if it has not already been
            initialized.
            </summary>
      <typeparam name="T">The reference type of the reference to be initialized.</typeparam>
      <param name="target">The reference of type <typeparamref name="T" /> to initialize if it has not
            already been initialized.</param>
      <param name="valueFactory">The <see cref="T:System.Func{T}" /> invoked to initialize the
            reference.</param>
      <returns>The initialized reference of type <typeparamref name="T" />.</returns>
      <exception cref="T:System.MissingMemberException">Type <typeparamref name="T" /> does not have a
            default constructor.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="valueFactory" /> returned
            null.</exception>
      <remarks>
        <para>
            This method may only be used on reference types, and <paramref name="valueFactory" /> may
            not return a null reference (Nothing in Visual Basic). To ensure initialization of value types or
            to allow null reference types, see other overloads of EnsureInitialized.
            </para>
        <para>
            This method may be used concurrently by multiple threads to initialize <paramref name="target" />.  
            In the event that multiple threads access this method concurrently, multiple instances of <typeparamref name="T" />
            may be created, but only one will be stored into <paramref name="target" />. In such an occurrence, this method will not dispose of the
            objects that were not stored.  If such objects must be disposed, it is up to the caller to determine 
            if an object was not used and to then dispose of the object appropriately.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitializedCore``1(``0@,System.Func{``0})">
      <summary>
            Initialize the target using the given delegate (slow path).
            </summary>
      <typeparam name="T">The reference type of the reference to be initialized.</typeparam>
      <param name="target">The variable that need to be initialized</param>
      <param name="valueFactory">The delegate that will be executed to initialize the target</param>
      <returns>The initialized variable</returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary>
            Initializes a target reference or value type with its default constructor if it has not already
            been initialized.
            </summary>
      <typeparam name="T">The type of the reference to be initialized.</typeparam>
      <param name="target">A reference or value of type <typeparamref name="T" /> to initialize if it
            has not already been initialized.</param>
      <param name="initialized">A reference to a boolean that determines whether the target has already
            been initialized.</param>
      <param name="syncLock">A reference to an object used as the mutually exclusive lock for initializing
            <paramref name="target" />.</param>
      <returns>The initialized value of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary>
            Initializes a target reference or value type with a specified function if it has not already been
            initialized.
            </summary>
      <typeparam name="T">The type of the reference to be initialized.</typeparam>
      <param name="target">A reference or value of type <typeparamref name="T" /> to initialize if it
            has not already been initialized.</param>
      <param name="initialized">A reference to a boolean that determines whether the target has already
            been initialized.</param>
      <param name="syncLock">A reference to an object used as the mutually exclusive lock for initializing
            <paramref name="target" />.</param>
      <param name="valueFactory">The <see cref="T:System.Func{T}" /> invoked to initialize the
            reference or value.</param>
      <returns>The initialized value of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitializedCore``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary>
            Ensure the target is initialized and return the value (slow path). This overload permits nulls
            and also works for value type targets. Uses the supplied function to create the value.
            </summary>
      <typeparam name="T">The type of target.</typeparam>
      <param name="target">A reference to the target to be initialized.</param>
      <param name="initialized">A reference to a location tracking whether the target has been initialized.</param>
      <param name="syncLock">A reference to a location containing a mutual exclusive lock.</param>
      <param name="valueFactory">
            The <see cref="T:System.Func{T}" /> to invoke in order to produce the lazily-initialized value.
            </param>
      <returns>The initialized object.</returns>
    </member>
    <member name="T:System.Threading.ThreadLocalGlobalCounter">
      <summary>
            A seprate non generic class that contains a global counter for fast path instances for all Ts that has been created, and adds an upper limit for all instances
            that uses the fast path, if this limit has been reached, all new instances will use the slow path
            </summary>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary>
            Provides thread-local storage of data.
            </summary>
      <typeparam name="T">Specifies the type of data stored per-thread.</typeparam>
      <remarks>
        <para>
            With the exception of <see cref="M:System.Threading.ThreadLocal`1.Dispose" />, all public and protected members of 
            <see cref="T:System.Threading.ThreadLocal`1" /> are thread-safe and may be used
            concurrently from multiple threads.
            </para>
      </remarks>
    </member>
    <member name="T:System.Threading.ThreadLocal`1.HolderBase">
      <summary>
            The base abstract class for the holder
            </summary>
    </member>
    <member name="T:System.Threading.ThreadLocal`1.TLSHolder">
      <summary>
            The TLS holder representation
            </summary>
    </member>
    <member name="T:System.Threading.ThreadLocal`1.GenericHolder`3">
      <summary>
            The generic holder representation
            </summary>
      <typeparam name="U">Dummy param</typeparam>
      <typeparam name="V">Dummy param</typeparam>
      <typeparam name="W">Dummy param</typeparam>
    </member>
    <member name="T:System.Threading.ThreadLocal`1.Boxed">
      <summary>
            wrapper to the actual value
            </summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1" /> instance.
            </summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1" /> instance with the
            specified <paramref name="valueFactory" /> function.
            </summary>
      <param name="valueFactory">
            The <see cref="T:System.Func{T}" /> invoked to produce a lazily-initialized value when 
            an attempt is made to retrieve <see cref="P:System.Threading.ThreadLocal`1.Value" /> without it having been previously initialized.
            </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal{T}" /> instance.
            </summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal{T}" /> instance.
            </summary>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ThreadLocal{T}" />, this method is not thread-safe.
            </remarks>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal{T}" /> instance.
            </summary>
      <param name="disposing">
            A Boolean value that indicates whether this method is being called due to a call to <see cref="M:System.Threading.ThreadLocal`1.Dispose" />.
            </param>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ThreadLocal{T}" />, this method is not thread-safe.
            </remarks>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.FindNextTypeIndex">
      <summary>
            Tries to get a unique index for the current instance of type T, it first tries to get it from the pool if it is not empty, otherwise it
            increments the global counter if it is still below the maximum, otherwise it fails and returns -1
            </summary>
      <returns>True if there is an index available, false otherwise</returns>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.GetTypesFromIndex">
      <summary>
            Gets an array of types that will be used as generic parameters for the GenericHolder class
            </summary>
      <returns>The types array</returns>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary>Creates and returns a string representation of this instance for the current thread.</summary>
      <returns>The result of calling <see cref="M:System.Object.ToString" /> on the <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
      <exception cref="T:System.NullReferenceException">
            The <see cref="P:System.Threading.ThreadLocal`1.Value" /> for the current thread is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
            The initialization function referenced <see cref="P:System.Threading.ThreadLocal`1.Value" /> in an improper manner.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1" /> instance has been disposed.
            </exception>
      <remarks>
            Calling this method forces initialization for the current thread, as is the
            case with accessing <see cref="P:System.Threading.ThreadLocal`1.Value" /> directly.
            </remarks>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.CreateValue">
      <summary>
            Private helper function to lazily create the value using the calueSelector if specified in the constructor or the default parameterless constructor
            </summary>
      <returns>Returns the boxed object</returns>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary>
            Gets or sets the value of this instance for the current thread.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The initialization function referenced <see cref="P:System.Threading.ThreadLocal`1.Value" /> in an improper manner.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1" /> instance has been disposed.
            </exception>
      <remarks>
            If this instance was not previously initialized for the current thread,
            accessing <see cref="P:System.Threading.ThreadLocal`1.Value" /> will attempt to initialize it. If an initialization function was 
            supplied during the construction, that initialization will happen by invoking the function 
            to retrieve the initial value for <see cref="P:System.Threading.ThreadLocal`1.Value" />.  Otherwise, the default value of 
            <typeparamref name="T" /> will be used.
            </remarks>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary>
            Gets whether <see cref="P:System.Threading.ThreadLocal`1.Value" /> is initialized on the current thread.
            </summary>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1" /> instance has been disposed.
            </exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.ValueForDebugDisplay">
      <summary>Gets the value of the ThreadLocal&lt;T&gt; for debugging display purposes. It takes care of getting
            the value for the current thread in the ThreadLocal mode.</summary>
    </member>
    <member name="T:System.Threading.SystemThreading_ThreadLocalDebugView`1">
      <summary>A debugger view of the ThreadLocal&lt;T&gt; to surface additional debugging properties and 
            to ensure that the ThreadLocal&lt;T&gt; does not become initialized if it was not already.</summary>
    </member>
    <member name="M:System.Threading.SystemThreading_ThreadLocalDebugView`1.#ctor(System.Threading.ThreadLocal{`0})">
      <summary>Constructs a new debugger view object for the provided ThreadLocal object.</summary>
      <param name="tlocal">A ThreadLocal object to browse in the debugger.</param>
    </member>
    <member name="P:System.Threading.SystemThreading_ThreadLocalDebugView`1.IsValueCreated">
      <summary>Returns whether the ThreadLocal object is initialized or not.</summary>
    </member>
    <member name="P:System.Threading.SystemThreading_ThreadLocalDebugView`1.Value">
      <summary>Returns the value of the ThreadLocal object.</summary>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary>
            Limits the number of threads that can access a resource or pool of resources concurrently.
            </summary>
      <remarks>
        <para>
            The <see cref="T:System.Threading.SemaphoreSlim" /> provides a lightweight semaphore class that doesn't
            use Windows kernel semaphores.
            </para>
        <para>
            All public and protected members of <see cref="T:System.Threading.SemaphoreSlim" /> are thread-safe and may be used
            concurrently from multiple threads, with the exception of Dispose, which
            must only be used when all other operations on the <see cref="T:System.Threading.SemaphoreSlim" /> have
            completed.
            </para>
      </remarks>
    </member>
    <member name="F:System.Threading.SemaphoreSlim.s_cancellationTokenCanceledEventHandler">
      <summary>
            Private helper method to wake up waiters when a cancellationToken gets canceled.
            </summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SemaphoreSlim" /> class, specifying
            the initial number of requests that can be granted concurrently.
            </summary>
      <param name="initialCount">The initial number of requests for the semaphore that can be granted
            concurrently.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" />
            is less than 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SemaphoreSlim" /> class, specifying
            the initial and maximum number of requests that can be granted concurrently.
            </summary>
      <param name="initialCount">The initial number of requests for the semaphore that can be granted
            concurrently.</param>
      <param name="maxCount">The maximum number of requests for the semaphore that can be granted
            concurrently.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" />
            is less than 0. -or-
            <paramref name="initialCount" /> is greater than <paramref name="maxCount" />. -or-
            <paramref name="maxCount" /> is less than 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />.
            </summary>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />, while observing a
            <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> token to
            observe.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> was
            canceled.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />, using a <see cref="T:System.TimeSpan" /> to measure the time interval.
            </summary>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim" />;
            otherwise, false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />, using a <see cref="T:System.TimeSpan" /> to measure the time interval, while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
      <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim" />;
            otherwise, false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> was canceled.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />, using a 32-bit
            signed integer to measure the time interval.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to wait indefinitely.</param>
      <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim" />;
            otherwise, false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />,
            using a 32-bit signed integer to measure the time interval, 
            while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to
            wait indefinitely.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to observe.</param>
      <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim" />; otherwise, false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a negative number other than -1,
            which represents an infinite time-out.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> was canceled.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(System.Int32,System.Int64,System.Threading.CancellationToken)">
      <summary>
            Local helper function, waits on the monitor until the monitor recieves signal or the
            timeout is expired
            </summary>
      <param name="millisecondsTimeout">The maximum timeout</param>
      <param name="startTimeTicks">The start ticks to calculate the elapsed time</param>
      <param name="cancellationToken">The CancellationToken to observe.</param>
      <returns>true if the monitor recieved a signal, false if the timeout expired</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary>
            Exits the <see cref="T:System.Threading.SemaphoreSlim" /> once.
            </summary>
      <returns>The previous count of the <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary>
            Exits the <see cref="T:System.Threading.SemaphoreSlim" /> a specified number of times.
            </summary>
      <param name="releaseCount">The number of times to exit the semaphore.</param>
      <returns>The previous count of the <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="releaseCount" /> is less
            than 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">The <see cref="T:System.Threading.SemaphoreSlim" /> has
            already reached its maximum size.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary>
            Releases all resources used by the current instance of <see cref="T:System.Threading.SemaphoreSlim" />.
            </summary>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.SemaphoreSlim" />, <see cref="M:System.Threading.SemaphoreSlim.Dispose" /> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary>
            When overridden in a derived class, releases the unmanaged resources used by the 
            <see cref="T:System.Threading.ManualResetEventSlim" />, and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources;
            false to release only unmanaged resources.</param>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.SemaphoreSlim" />, <see cref="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)" /> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.UpdateTimeOut(System.Int64,System.Int32)">
      <summary>
            Helper function to measure and update the wait time
            </summary>
      <param name="startTimeTicks"> The first time (in Ticks) observed when the wait started</param>
      <param name="originalWaitMillisecondsTimeout">The orginal wait timeoutout in milliseconds</param>
      <returns>The new wait time in milliseconds, -1 if the time expired</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.CheckDispose">
      <summary>
            Checks the dispose status by checking the lock object, if it is null means that object
            has been disposed and throw ObjectDisposedException
            </summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.GetResourceString(System.String)">
      <summary>
            local helper function to retrieve the exception string message from the resource file
            </summary>
      <param name="str">The key string</param>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary>
            Gets the current count of the <see cref="T:System.Threading.SemaphoreSlim" />.
            </summary>
      <value>The current count of the <see cref="T:System.Threading.SemaphoreSlim" />.</value>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary>
            Returns a <see cref="T:System.Threading.WaitHandle" /> that can be used to wait on the semaphore.
            </summary>
      <value>A <see cref="T:System.Threading.WaitHandle" /> that can be used to wait on the
            semaphore.</value>
      <remarks>
            A successful wait on the <see cref="P:System.Threading.SemaphoreSlim.AvailableWaitHandle" /> does not imply a successful wait on
            the <see cref="T:System.Threading.SemaphoreSlim" /> itself, nor does it decrement the semaphore's
            count. <see cref="P:System.Threading.SemaphoreSlim.AvailableWaitHandle" /> exists to allow a thread to block waiting on multiple
            semaphores, but such a wait should be followed by a true wait on the target semaphore.
            </remarks>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.SemaphoreSlim" /> has been disposed.</exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary>
            Provides support for spin-based waiting.
            </summary>
      <remarks>
        <para>
          <see cref="T:System.Threading.SpinWait" /> encapsulates common spinning logic. On single-processor machines, yields are
            always used instead of busy waits, and on computers with Intel processors employing Hyper-Threading
            technology, it helps to prevent hardware thread starvation. SpinWait encapsulates a good mixture of
            spinning and true yielding.
            </para>
        <para>
          <see cref="T:System.Threading.SpinWait" /> is a value type, which means that low-level code can utilize SpinWait without
            fear of unnecessary allocation overheads. SpinWait is not generally useful for ordinary applications.
            In most cases, you should use the synchronization classes provided by the .NET Framework, such as
            <see cref="T:System.Threading.Monitor" />. For most purposes where spin waiting is required, however,
            the <see cref="T:System.Threading.SpinWait" /> type should be preferred over the <see cref="M:System.Threading.Thread.SpinWait(System.Int32)" /> method.
            </para>
        <para>
            While SpinWait is designed to be used in concurrent applications, it is not designed to be
            used from multiple threads concurrently.  SpinWait's members are not thread-safe.  If multiple
            threads must spin, each should use its own instance of SpinWait.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary>
            Performs a single spin.
            </summary>
      <remarks>
            This is typically called in a loop, and may change in behavior based on the number of times a
            <see cref="M:System.Threading.SpinWait.SpinOnce" /> has been called thus far on this instance.
            </remarks>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary>
            Resets the spin counter.
            </summary>
      <remarks>
            This makes <see cref="M:System.Threading.SpinWait.SpinOnce" /> and <see cref="P:System.Threading.SpinWait.NextSpinWillYield" /> behave as though no calls
            to <see cref="M:System.Threading.SpinWait.SpinOnce" /> had been issued on this instance. If a <see cref="T:System.Threading.SpinWait" /> instance
            is reused many times, it may be useful to reset it to avoid yielding too soon.
            </remarks>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary>
            Spins until the specified condition is satisfied.
            </summary>
      <param name="condition">A delegate to be executed over and over until it returns true.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="condition" /> argument is null.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
      <param name="condition">A delegate to be executed over and over until it returns true.</param>
      <param name="timeout">
            A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, 
            or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
      <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="condition" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
      <param name="condition">A delegate to be executed over and over until it returns true.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="condition" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary>
            Gets the number of times <see cref="M:System.Threading.SpinWait.SpinOnce" /> has been called on this instance.
            </summary>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary>
            Gets whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce" /> will yield the processor, triggering a
            forced context switch.
            </summary>
      <value>Whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce" /> will yield the processor, triggering a
            forced context switch.</value>
      <remarks>
            On a single-CPU machine, <see cref="M:System.Threading.SpinWait.SpinOnce" /> always yields the processor. On machines with
            multiple CPUs, <see cref="M:System.Threading.SpinWait.SpinOnce" /> may yield after an unspecified number of calls.
            </remarks>
    </member>
    <member name="T:System.Threading.PlatformHelper">
      <summary>
            A helper class to get the number of preocessors, it updates the numbers of processors every sampling interval
            </summary>
    </member>
    <member name="P:System.Threading.PlatformHelper.ProcessorCount">
      <summary>
            Gets the number of available processors
            </summary>
    </member>
    <member name="P:System.Threading.PlatformHelper.IsSingleProcessor">
      <summary>
            Gets whether the current machine has only a single processor.
            </summary>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary>
            Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop
            repeatedly checking until the lock becomes available.
            </summary>
      <remarks>
        <para>
            Spin locks can be used for leaf-level locks where the object allocation implied by using a <see cref="T:System.Threading.Monitor" />, in size or due to garbage collection pressure, is overly
            expensive. Avoiding blocking is another reason that a spin lock can be useful, however if you expect
            any significant amount of blocking, you are probably best not using spin locks due to excessive
            spinning. Spinning can be beneficial when locks are fine grained and large in number (for example, a
            lock per node in a linked list) as well as when lock hold times are always extremely short. In
            general, while holding a spin lock, one should avoid blocking, calling anything that itself may
            block, holding more than one spin lock at once, making dynamically dispatched calls (interface and
            virtuals), making statically dispatched calls into any code one doesn't own, or allocating memory.
            </para>
        <para>
          <see cref="T:System.Threading.SpinLock" /> should only be used when it's been determined that doing so will improve an
            application's performance. It's also important to note that <see cref="T:System.Threading.SpinLock" /> is a value type,
            for performance reasons. As such, one must be very careful not to accidentally copy a SpinLock
            instance, as the two instances (the original and the copy) would then be completely independent of
            one another, which would likely lead to erroneous behavior of the application. If a SpinLock instance
            must be passed around, it should be passed by reference rather than by value.
            </para>
        <para>
            Do not store <see cref="T:System.Threading.SpinLock" /> instances in readonly fields.
            </para>
        <para>
            All members of <see cref="T:System.Threading.SpinLock" /> are thread-safe and may be used from multiple threads
            concurrently.
            </para>
      </remarks>
    </member>
    <member name="T:System.Threading.SpinLock.SystemThreading_SpinLockDebugView">
      <summary>
            Internal class used by debug type proxy attribute to display the owner thread ID 
            </summary>
    </member>
    <member name="M:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.#ctor(System.Threading.SpinLock)">
      <summary>
            SystemThreading_SpinLockDebugView constructor
            </summary>
      <param name="spinLock">The SpinLock to be proxied.</param>
    </member>
    <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.IsHeldByCurrentThread">
      <summary>
            Checks if the lock is held by the current thread or not
            </summary>
    </member>
    <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.OwnerThreadID">
      <summary>
            Gets the current owner thread, zero if it is released
            </summary>
    </member>
    <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.IsHeld">
      <summary>
             Gets whether the lock is currently held by any thread or not.
            </summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SpinLock" />
            structure with the option to track thread IDs to improve debugging.
            </summary>
      <remarks>
            The default constructor for <see cref="T:System.Threading.SpinLock" /> tracks thread ownership.
            </remarks>
      <param name="enableThreadOwnerTracking">Whether to capture and use thread IDs for debugging
            purposes.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SpinLock" />
            structure with the option to track thread IDs to improve debugging.
            </summary>
      <remarks>
            The default constructor for <see cref="T:System.Threading.SpinLock" /> tracks thread ownership.
            </remarks>
      <summary>
            Acquires the lock in a reliable manner, such that even if an exception occurs within the method
            call, <paramref name="lockTaken" /> can be examined reliably to determine whether the lock was
            acquired.
            </summary>
      <remarks>
        <see cref="T:System.Threading.SpinLock" /> is a non-reentrant lock, meaning that if a thread holds the lock, it is
            not allowed to enter the lock again. If thread ownership tracking is enabled (whether it's
            enabled is available through <see cref="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled" />), an exception will be
            thrown when a thread tries to re-enter a lock it already holds. However, if thread ownership
            tracking is disabled, attempting to enter a lock already held will result in deadlock.
            </remarks>
      <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref name="lockTaken" /> must be initialized to false prior to calling this method.</param>
      <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken" /> argument must be initialized to false prior to calling Enter.
            </exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken" /> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
      <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)" />, TryEnter will not block waiting for the lock to be available. If the
            lock is not available when TryEnter is called, it will return immediately without any further
            spinning.
            </remarks>
      <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref name="lockTaken" /> must be initialized to false prior to calling this method.</param>
      <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken" /> argument must be initialized to false prior to calling TryEnter.
            </exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken" /> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
      <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)" />, TryEnter will not block indefinitely waiting for the lock to be
            available. It will block until either the lock is available or until the <paramref name="timeout" />
            has expired.
            </remarks>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref name="lockTaken" /> must be initialized to false prior to calling this method.</param>
      <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken" /> argument must be initialized to false prior to calling TryEnter.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue" /> milliseconds.
            </exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken" /> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
      <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)" />, TryEnter will not block indefinitely waiting for the lock to be
            available. It will block until either the lock is available or until the <paramref name="millisecondsTimeout" /> has expired.
            </remarks>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref name="lockTaken" /> must be initialized to false prior to calling this method.</param>
      <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken" /> argument must be initialized to false prior to calling TryEnter.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is
            a negative number other than -1, which represents an infinite time-out.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.ContinueTryEnter(System.Int32,System.Boolean@)">
      <summary>
            Try acquire the lock with long path, this is usually called after the first path in Enter and
            TryEnter failed The reason for short path is to make it inline in the run time which improves the
            performance. This method assumed that the parameter are validated in Enter ir TryENter method
            </summary>
      <param name="millisecondsTimeout">The timeout milliseconds</param>
      <param name="lockTaken">The lockTaken param</param>
    </member>
    <member name="M:System.Threading.SpinLock.DecrementWaiters">
      <summary>
            decrements the waiters, in case of the timeout is expired
            </summary>
    </member>
    <member name="M:System.Threading.SpinLock.ContinueTryEnterWithThreadTracking(System.Int32,System.Int64,System.Boolean@)">
      <summary>
            ContinueTryEnter for the thread tracking mode enabled
            </summary>
    </member>
    <member name="M:System.Threading.SpinLock.TimeoutExpired(System.Int64,System.Int32)">
      <summary>
            Helper function to validate the timeout
            </summary>
      <param name="startTicks"> The start time in ticks</param>
      <param name="originalWaitTime">The orginal wait time</param>
      <returns>True if expired, false otherwise</returns>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary>
            Releases the lock.
            </summary>
      <remarks>
            The default overload of <see cref="M:System.Threading.SpinLock.Exit" /> provides the same behavior as if calling <see cref="M:System.Threading.SpinLock.Exit(System.Boolean)" /> using true as the argument.
            </remarks>
      <exception cref="T:System.Threading.SynchronizationLockException">
            Thread ownership tracking is enabled, and the current thread is not the owner of this lock.
            </exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary>
            Releases the lock.
            </summary>
      <param name="useMemoryBarrier">
            A Boolean value that indicates whether a memory fence should be issued in order to immediately
            publish the exit operation to other threads.
            </param>
      <remarks>
            Calling <see cref="M:System.Threading.SpinLock.Exit(System.Boolean)" /> with the <paramref name="useMemoryBarrier" /> argument set to
            true will improve the fairness of the lock at the expense of some performance. The default <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)" />
            overload behaves as if specifying true for <paramref name="useMemoryBarrier" />.
            </remarks>
      <exception cref="T:System.Threading.SynchronizationLockException">
            Thread ownership tracking is enabled, and the current thread is not the owner of this lock.
            </exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary>
            Gets whether the lock is currently held by any thread.
            </summary>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary>
            Gets whether the lock is currently held by any thread.
            </summary>
      <summary>
            Gets whether the lock is held by the current thread.
            </summary>
      <remarks>
            If the lock was initialized to track owner threads, this will return whether the lock is acquired
            by the current thread. It is invalid to use this property when the lock was initialized to not
            track thread ownership.
            </remarks>
      <exception cref="T:System.InvalidOperationException">
            Thread ownership tracking is disabled.
            </exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary>Gets whether thread ownership tracking is enabled for this instance.</summary>
    </member>
    <member name="T:System.Threading.Tasks.ParallelOptions">
      <summary>
            Stores options that configure the operation of methods on the 
            <see cref="T:System.Threading.Tasks.Parallel">Parallel</see> class.
            </summary>
      <remarks>
            By default, methods on the Parallel class attempt to utilize all available processors, are non-cancelable, and target
            the default TaskScheduler (TaskScheduler.Default). <see cref="T:System.Threading.Tasks.ParallelOptions" /> enables
            overriding these defaults.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.ParallelOptions.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.ParallelOptions" /> class.
            </summary>
      <remarks>
            This constructor initializes the instance with default values.  <see cref="P:System.Threading.Tasks.ParallelOptions.MaxDegreeOfParallelism" />
            is initialized to -1, signifying that there is no upper bound set on how much parallelism should
            be employed.  <see cref="P:System.Threading.Tasks.ParallelOptions.CancellationToken" /> is initialized to a non-cancelable token,
            and <see cref="P:System.Threading.Tasks.ParallelOptions.TaskScheduler" /> is initialized to the default scheduler (TaskScheduler.Default).  
            All of these defaults may be overwritten using the property set accessors on the instance.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.ParallelOptions.TaskScheduler">
      <summary>
            Gets or sets the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> 
            associated with this <see cref="T:System.Threading.Tasks.ParallelOptions" /> instance. Setting this property to null
            indicates that the current scheduler should be used.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.ParallelOptions.MaxDegreeOfParallelism">
      <summary>
            Gets or sets the maximum degree of parallelism enabled by this ParallelOptions instance.
            </summary>
      <remarks>
            The <see cref="P:System.Threading.Tasks.ParallelOptions.MaxDegreeOfParallelism" /> limits the number of concurrent operations run by <see cref="T:System.Threading.Tasks.Parallel">Parallel</see> method calls that are passed this
            ParallelOptions instance to the set value, if it is positive. If <see cref="P:System.Threading.Tasks.ParallelOptions.MaxDegreeOfParallelism" /> is -1, then there is no limit placed on the number of concurrently
            running operations.
            </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when this <see cref="P:System.Threading.Tasks.ParallelOptions.MaxDegreeOfParallelism" /> is set to 0 or some
            value less than -1.
            </exception>
    </member>
    <member name="P:System.Threading.Tasks.ParallelOptions.CancellationToken">
      <summary>
            Gets or sets the <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            associated with this <see cref="T:System.Threading.Tasks.ParallelOptions" /> instance.
            </summary>
      <remarks>
            Providing a <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            to a <see cref="T:System.Threading.Tasks.Parallel">Parallel</see> method enables the operation to be
            exited early. Code external to the operation may cancel the token, and if the operation observes the
            token being set, it may exit early by throwing an
            <see cref="T:System.OperationCanceledException" />.
            </remarks>
    </member>
    <member name="T:System.Threading.Tasks.Parallel">
      <summary>
            Provides support for parallel loops and regions.
            </summary>
      <remarks>
            The <see cref="T:System.Threading.Tasks.Parallel" /> class provides library-based data parallel replacements
            for common operations such as for loops, for each loops, and execution of a set of statements.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])">
      <summary>
            Executes each of the provided actions, possibly in parallel.
            </summary>
      <param name="actions">An array of <see cref="T:System.Action">Actions</see> to execute.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="actions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="actions" /> array contains a null element.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown when any
            action in the <paramref name="actions" /> array throws an exception.</exception>
      <remarks>
            This method can be used to execute a set of operations, potentially in parallel.   
            No guarantees are made about the order in which the operations execute or whether 
            they execute in parallel.  This method does not return until each of the 
            provided operations has completed, regardless of whether completion 
            occurs due to normal or exceptional termination.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])">
      <summary>
            Executes each of the provided actions, possibly in parallel.
            </summary>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="actions">An array of <see cref="T:System.Action">Actions</see> to execute.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="actions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="actions" /> array contains a null element.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> is set.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown when any 
            action in the <paramref name="actions" /> array throws an exception.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <remarks>
            This method can be used to execute a set of operations, potentially in parallel.   
            No guarantees are made about the order in which the operations execute or whether 
            the they execute in parallel.  This method does not return until each of the 
            provided operations has completed, regardless of whether completion 
            occurs due to normal or exceptional termination.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})">
      <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the iteration count (an Int32) as a parameter.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})">
      <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the iteration count (an Int64) as a parameter.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})">
      <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the iteration count (an Int32) as a parameter.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})">
      <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the iteration count (an Int64) as a parameter.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the following parameters: the iteration count (an Int32), 
            and a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely.
            </para>
        <para>
            Calling <see cref="M:System.Threading.Tasks.ParallelLoopState.Break">ParallelLoopState.Break()</see>
            informs the For operation that iterations after the current one need not 
            execute.  However, all iterations before the current one will still need to be executed if they have not already.
            Therefore, calling Break is similar to using a break operation within a 
            conventional for loop in a language like C#, but it is not a perfect substitute: for example, there is no guarantee that iterations 
            after the current one will definitely not execute.
            </para>
        <para>
            If executing all iterations before the current one is not necessary, 
            <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop">ParallelLoopState.Stop()</see>
            should be preferred to using Break.  Calling Stop informs the For loop that it may abandon all remaining
            iterations, regardless of whether they're for interations above or below the current, 
            since all required work has already been completed.  As with Break, however, there are no guarantees regarding 
            which other iterations will not execute.
            </para>
        <para>
            When a loop is ended prematurely, the <see cref="T:ParallelLoopState" /> that's returned will contain
            relevant information about the loop's completion.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the following parameters: the iteration count (an Int64), 
            and a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the following parameters: the iteration count (an Int32), 
            and a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the following parameters: the iteration count (an Int64), 
            and a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the following parameters: the iteration count (an Int32), 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and some local state that may be shared amongst iterations 
            that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <summary>
            Executes a for loop in which iterations may run in parallel.  Supports 64-bit indices.
            </summary>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the following parameters: the iteration count (an Int64), 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and some local state that may be shared amongst iterations 
            that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the following parameters: the iteration count (an Int32), 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and some local state that may be shared amongst iterations 
            that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <summary>
            Executes a for loop in which iterations may run in parallel.
            </summary>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <paramref name="body" /> delegate is invoked once for each value in the iteration range: 
            [fromInclusive, toExclusive).  It is provided with the following parameters: the iteration count (an Int64), 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and some local state that may be shared amongst iterations 
            that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForWorker``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32},System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Func{``0},System.Action{``0})">
      <summary>
            Performs the major work of the parallel for loop. It assumes that argument validation has already
            been performed by the caller. This function's whole purpose in life is to enable as much reuse of
            common implementation details for the various For overloads we offer. Without it, we'd end up
            with lots of duplicate code. It handles: (1) simple for loops, (2) for loops that depend on
            ParallelState, and (3) for loops with thread local data.
            
            @TODO: at some point in the future, we may want to manually inline the interesting bits into the
            specific overloads above. There is some overhead associated with the extra arguments passed to
            the function, and various if-checks in the code. It is also more difficult to follow what the
            code does as-is because it has to handle the three flavors.
            </summary>
      <typeparam name="TLocal">The type of the local data.</typeparam>
      <param name="fromInclusive">The loop's start index, inclusive.</param>
      <param name="toExclusive">The loop's end index, exclusive.</param>
      <param name="parallelOptions">A ParallelOptions instance.</param>
      <param name="body">The simple loop body.</param>
      <param name="bodyWithState">The loop body for ParallelState overloads.</param>
      <param name="bodyWithLocal">The loop body for thread local state overloads.</param>
      <param name="localInit">A selector function that returns new thread local state.</param>
      <param name="localFinally">A cleanup function to destroy thread local state.</param>
      <remarks>Only one of the body arguments may be supplied (i.e. they are exclusive).</remarks>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> structure.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForWorker64``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64},System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Func{``0},System.Action{``0})">
      <summary>
            Performs the major work of the 64-bit parallel for loop. It assumes that argument validation has already
            been performed by the caller. This function's whole purpose in life is to enable as much reuse of
            common implementation details for the various For overloads we offer. Without it, we'd end up
            with lots of duplicate code. It handles: (1) simple for loops, (2) for loops that depend on
            ParallelState, and (3) for loops with thread local data.
            
            @TODO: at some point in the future, we may want to manually inline the interesting bits into the
            specific overloads above. There is some overhead associated with the extra arguments passed to
            the function, and various if-checks in the code. It is also more difficult to follow what the
            code does as-is because it has to handle the three flavors.
            </summary>
      <typeparam name="TLocal">The type of the local data.</typeparam>
      <param name="fromInclusive">The loop's start index, inclusive.</param>
      <param name="toExclusive">The loop's end index, exclusive.</param>
      <param name="parallelOptions">A ParallelOptions instance.</param>
      <param name="body">The simple loop body.</param>
      <param name="bodyWithState">The loop body for ParallelState overloads.</param>
      <param name="bodyWithLocal">The loop body for thread local state overloads.</param>
      <param name="localInit">A selector function that returns new thread local state.</param>
      <param name="localFinally">A cleanup function to destroy thread local state.</param>
      <remarks>Only one of the body arguments may be supplied (i.e. they are exclusive).</remarks>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> structure.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Executes a for each operation on an <see cref="T:System.Collections.IEnumerable{TSource}" /> 
            in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the data in the source.</typeparam>
      <param name="source">An enumerable data source.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            enumerable.  It is provided with the current element as a parameter.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})">
      <summary>
            Executes a for each operation on an <see cref="T:System.Collections.IEnumerable{TSource}" /> 
            in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the data in the source.</typeparam>
      <param name="source">An enumerable data source.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            enumerable.  It is provided with the current element as a parameter.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            Executes a for each operation on an <see cref="T:System.Collections.IEnumerable{TSource}" /> 
            in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the data in the source.</typeparam>
      <param name="source">An enumerable data source.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            enumerable.  It is provided with the following parameters: the current element, 
            and a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            Executes a for each operation on an <see cref="T:System.Collections.IEnumerable{TSource}" /> 
            in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the data in the source.</typeparam>
      <param name="source">An enumerable data source.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            enumerable.  It is provided with the following parameters: the current element, 
            and a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})">
      <summary>
            Executes a for each operation on an <see cref="T:System.Collections.IEnumerable{TSource}" /> 
            in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the data in the source.</typeparam>
      <param name="source">An enumerable data source.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            enumerable.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and the current element's index (an Int64).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})">
      <summary>
            Executes a for each operation on an <see cref="T:System.Collections.IEnumerable{TSource}" /> 
            in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the data in the source.</typeparam>
      <param name="source">An enumerable data source.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            enumerable.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and the current element's index (an Int64).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})">
      <summary>
            Executes a for each operation on an <see cref="T:System.Collections.IEnumerable{TSource}" /> 
            in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the data in the source.</typeparam>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="source">An enumerable data source.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            enumerable.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and some local state that may be shared amongst iterations 
            that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})">
      <summary>
            Executes a for each operation on an <see cref="T:System.Collections.IEnumerable{TSource}" /> 
            in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the data in the source.</typeparam>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="source">An enumerable data source.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            enumerable.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and some local state that may be shared amongst iterations 
            that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})">
      <summary>
            Executes a for each operation on an <see cref="T:System.Collections.IEnumerable{TSource}" /> 
            in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the data in the source.</typeparam>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="source">An enumerable data source.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            enumerable.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, the current element's index (an Int64), and some local 
            state that may be shared amongst iterations that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})">
      <summary>
            Executes a for each operation on an <see cref="T:System.Collections.IEnumerable{TSource}" /> 
            in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the data in the source.</typeparam>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="source">An enumerable data source.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            enumerable.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, the current element's index (an Int64), and some local 
            state that may be shared amongst iterations that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEachWorker``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Func{``1},System.Action{``1})">
      <summary>
            Performs the major work of the parallel foreach loop. It assumes that argument validation has
            already been performed by the caller. This function's whole purpose in life is to enable as much
            reuse of common implementation details for the various For overloads we offer. Without it, we'd
            end up with lots of duplicate code. It handles: (1) simple foreach loops, (2) foreach loops that
            depend on ParallelState, and (3) foreach loops that access indices, (4) foreach loops with thread
            local data, and any necessary permutations thereof.
            
            @TODO: at some point in the future, we may want to manually inline the interesting bits into the
            specific overloads above. There is some overhead associated with the extra arguments passed to
            the function, and various if-checks in the code. It is also more difficult to follow what the
            code does as-is because it has to handle the all flavors.
            </summary>
      <typeparam name="TSource">The type of the source data.</typeparam>
      <typeparam name="TLocal">The type of the local data.</typeparam>
      <param name="source">An enumerable data source.</param>
      <param name="parallelOptions">ParallelOptions instance to use with this ForEach-loop</param>
      <param name="body">The simple loop body.</param>
      <param name="bodyWithState">The loop body for ParallelState overloads.</param>
      <param name="bodyWithStateAndIndex">The loop body for ParallelState/indexed overloads.</param>
      <param name="bodyWithStateAndLocal">The loop body for ParallelState/thread local state overloads.</param>
      <param name="bodyWithEverything">The loop body for ParallelState/indexed/thread local state overloads.</param>
      <param name="localInit">A selector function that returns new thread local state.</param>
      <param name="localFinally">A cleanup function to destroy thread local state.</param>
      <remarks>Only one of the bodyXX arguments may be supplied (i.e. they are exclusive).</remarks>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> structure.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEachWorker``2(``0[],System.Threading.Tasks.ParallelOptions,System.Action{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Func{``1},System.Action{``1})">
      <summary>
            A fast path for the more general ForEachWorker method above. This uses ldelem instructions to
            access the individual elements of the array, which will be faster.
            </summary>
      <typeparam name="TSource">The type of the source data.</typeparam>
      <typeparam name="TLocal">The type of the local data.</typeparam>
      <param name="array">An array data source.</param>
      <param name="parallelOptions">The options to use for execution.</param>
      <param name="body">The simple loop body.</param>
      <param name="bodyWithState">The loop body for ParallelState overloads.</param>
      <param name="bodyWithStateAndIndex">The loop body for indexed/ParallelLoopState overloads.</param>
      <param name="bodyWithStateAndLocal">The loop body for local/ParallelLoopState overloads.</param>
      <param name="bodyWithEverything">The loop body for the most generic overload.</param>
      <param name="localInit">A selector function that returns new thread local state.</param>
      <param name="localFinally">A cleanup function to destroy thread local state.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> structure.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEachWorker``2(System.Collections.Generic.IList{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Func{``1},System.Action{``1})">
      <summary>
            A fast path for the more general ForEachWorker method above. This uses IList&lt;T&gt;'s indexer
            capabilities to access the individual elements of the list rather than an enumerator.
            </summary>
      <typeparam name="TSource">The type of the source data.</typeparam>
      <typeparam name="TLocal">The type of the local data.</typeparam>
      <param name="list">A list data source.</param>
      <param name="parallelOptions">The options to use for execution.</param>
      <param name="body">The simple loop body.</param>
      <param name="bodyWithState">The loop body for ParallelState overloads.</param>
      <param name="bodyWithStateAndIndex">The loop body for indexed/ParallelLoopState overloads.</param>
      <param name="bodyWithStateAndLocal">The loop body for local/ParallelLoopState overloads.</param>
      <param name="bodyWithEverything">The loop body for the most generic overload.</param>
      <param name="localInit">A selector function that returns new thread local state.</param>
      <param name="localFinally">A cleanup function to destroy thread local state.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> structure.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})">
      <summary>
            Executes a for each operation on a <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">
            Partitioner</see> in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the elements in <paramref name="source" />.</typeparam>
      <param name="source">The Partitioner that contains the original data source.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            SupportsDynamicPartitions property in the <paramref name="source" /> Partitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when any 
            methods in the <paramref name="source" /> Partitioner return null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner does not return 
            the correct number of partitions.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner returns an IList 
            with at least one null value.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetDynamicPartitions() method in the <paramref name="source" /> Partitioner returns an 
            IEnumerable whose GetEnumerator() method returns null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">Partitioner</see> is used to retrieve 
            the elements to be processed, in place of the original data source.  If the current element's 
            index is desired, the source must be an <see cref="T:System.Collections.Concurrent.OrderablePartitioner">
            OrderablePartitioner</see>.
            </para>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            Partitioner.  It is provided with the current element as a parameter.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            Executes a for each operation on a <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">
            Partitioner</see> in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the elements in <paramref name="source" />.</typeparam>
      <param name="source">The Partitioner that contains the original data source.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            SupportsDynamicPartitions property in the <paramref name="source" /> Partitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when any 
            methods in the <paramref name="source" /> Partitioner return null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner does not return 
            the correct number of partitions.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner returns an IList 
            with at least one null value.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetDynamicPartitions() method in the <paramref name="source" /> Partitioner returns an 
            IEnumerable whose GetEnumerator() method returns null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">Partitioner</see> is used to retrieve 
            the elements to be processed, in place of the original data source.  If the current element's 
            index is desired, the source must be an <see cref="T:System.Collections.Concurrent.OrderablePartitioner">
            OrderablePartitioner</see>.
            </para>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            Partitioner.  It is provided with the following parameters: the current element, 
            and a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})">
      <summary>
            Executes a for each operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner{TSource}">
            OrderablePartitioner</see> in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the elements in <paramref name="source" />.</typeparam>
      <param name="source">The OrderablePartitioner that contains the original data source.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            SupportsDynamicPartitions property in the <paramref name="source" /> OrderablePartitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            KeysNormalized property in the <paramref name="source" /> OrderablePartitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when any 
            methods in the <paramref name="source" /> OrderablePartitioner return null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() or GetOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner do not return the correct number of partitions.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() or GetOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner return an IList with at least one null value.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetDynamicPartitions() or GetDynamicOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner return an IEnumerable whose GetEnumerator() method returns null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">Partitioner</see> is used to retrieve 
            the elements to be processed, in place of the original data source.  If the current element's 
            index is desired, the source must be an <see cref="T:System.Collections.Concurrent.OrderablePartitioner">
            OrderablePartitioner</see>.
            </para>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            Partitioner.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and the current element's index (an Int64).
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})">
      <summary>
            Executes a for each operation on a <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">
            Partitioner</see> in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the elements in <paramref name="source" />.</typeparam>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="source">The Partitioner that contains the original data source.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            SupportsDynamicPartitions property in the <paramref name="source" /> Partitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when any 
            methods in the <paramref name="source" /> Partitioner return null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner does not return 
            the correct number of partitions.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner returns an IList 
            with at least one null value.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetDynamicPartitions() method in the <paramref name="source" /> Partitioner returns an 
            IEnumerable whose GetEnumerator() method returns null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">Partitioner</see> is used to retrieve 
            the elements to be processed, in place of the original data source.  If the current element's 
            index is desired, the source must be an <see cref="T:System.Collections.Concurrent.OrderablePartitioner">
            OrderablePartitioner</see>.
            </para>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            Partitioner.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and some local state that may be shared amongst iterations 
            that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})">
      <summary>
            Executes a for each operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner{TSource}">
            OrderablePartitioner</see> in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the elements in <paramref name="source" />.</typeparam>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="source">The OrderablePartitioner that contains the original data source.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            SupportsDynamicPartitions property in the <paramref name="source" /> OrderablePartitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            KeysNormalized property in the <paramref name="source" /> OrderablePartitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when any 
            methods in the <paramref name="source" /> OrderablePartitioner return null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() or GetOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner do not return the correct number of partitions.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() or GetOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner return an IList with at least one null value.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetDynamicPartitions() or GetDynamicOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner return an IEnumerable whose GetEnumerator() method returns null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">Partitioner</see> is used to retrieve 
            the elements to be processed, in place of the original data source.  If the current element's 
            index is desired, the source must be an <see cref="T:System.Collections.Concurrent.OrderablePartitioner">
            OrderablePartitioner</see>.
            </para>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            Partitioner.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, the current element's index (an Int64), and some local 
            state that may be shared amongst iterations that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})">
      <summary>
            Executes a for each operation on a <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">
            Partitioner</see> in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the elements in <paramref name="source" />.</typeparam>
      <param name="source">The Partitioner that contains the original data source.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            SupportsDynamicPartitions property in the <paramref name="source" /> Partitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when any 
            methods in the <paramref name="source" /> Partitioner return null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner does not return 
            the correct number of partitions.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner returns an IList 
            with at least one null value.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetDynamicPartitions() method in the <paramref name="source" /> Partitioner returns an 
            IEnumerable whose GetEnumerator() method returns null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">Partitioner</see> is used to retrieve 
            the elements to be processed, in place of the original data source.  If the current element's 
            index is desired, the source must be an <see cref="T:System.Collections.Concurrent.OrderablePartitioner">
            OrderablePartitioner</see>.
            </para>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            Partitioner.  It is provided with the current element as a parameter.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            Executes a for each operation on a <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">
            Partitioner</see> in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the elements in <paramref name="source" />.</typeparam>
      <param name="source">The Partitioner that contains the original data source.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            SupportsDynamicPartitions property in the <paramref name="source" /> Partitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when any 
            methods in the <paramref name="source" /> Partitioner return null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner does not return 
            the correct number of partitions.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner returns an IList 
            with at least one null value.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetDynamicPartitions() method in the <paramref name="source" /> Partitioner returns an 
            IEnumerable whose GetEnumerator() method returns null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">Partitioner</see> is used to retrieve 
            the elements to be processed, in place of the original data source.  If the current element's 
            index is desired, the source must be an <see cref="T:System.Collections.Concurrent.OrderablePartitioner">
            OrderablePartitioner</see>.
            </para>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            Partitioner.  It is provided with the following parameters: the current element, 
            and a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})">
      <summary>
            Executes a for each operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner{TSource}">
            OrderablePartitioner</see> in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the elements in <paramref name="source" />.</typeparam>
      <param name="source">The OrderablePartitioner that contains the original data source.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            SupportsDynamicPartitions property in the <paramref name="source" /> OrderablePartitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            KeysNormalized property in the <paramref name="source" /> OrderablePartitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when any 
            methods in the <paramref name="source" /> OrderablePartitioner return null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() or GetOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner do not return the correct number of partitions.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() or GetOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner return an IList with at least one null value.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetDynamicPartitions() or GetDynamicOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner return an IEnumerable whose GetEnumerator() method returns null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">Partitioner</see> is used to retrieve 
            the elements to be processed, in place of the original data source.  If the current element's 
            index is desired, the source must be an <see cref="T:System.Collections.Concurrent.OrderablePartitioner">
            OrderablePartitioner</see>.
            </para>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            Partitioner.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and the current element's index (an Int64).
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})">
      <summary>
            Executes a for each operation on a <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">
            Partitioner</see> in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the elements in <paramref name="source" />.</typeparam>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="source">The Partitioner that contains the original data source.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            SupportsDynamicPartitions property in the <paramref name="source" /> Partitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when any 
            methods in the <paramref name="source" /> Partitioner return null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner does not return 
            the correct number of partitions.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() method in the <paramref name="source" /> Partitioner returns an IList 
            with at least one null value.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetDynamicPartitions() method in the <paramref name="source" /> Partitioner returns an 
            IEnumerable whose GetEnumerator() method returns null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">Partitioner</see> is used to retrieve 
            the elements to be processed, in place of the original data source.  If the current element's 
            index is desired, the source must be an <see cref="T:System.Collections.Concurrent.OrderablePartitioner">
            OrderablePartitioner</see>.
            </para>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            Partitioner.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, and some local state that may be shared amongst iterations 
            that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})">
      <summary>
            Executes a for each operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner{TSource}">
            OrderablePartitioner</see> in which iterations may run in parallel.
            </summary>
      <typeparam name="TSource">The type of the elements in <paramref name="source" />.</typeparam>
      <typeparam name="TLocal">The type of the thread-local data.</typeparam>
      <param name="source">The OrderablePartitioner that contains the original data source.</param>
      <param name="parallelOptions">A <see cref="T:System.Threading.Tasks.ParallelOptions">ParallelOptions</see> 
            instance that configures the behavior of this operation.</param>
      <param name="localInit">The function delegate that returns the initial state of the local data 
            for each thread.</param>
      <param name="body">The delegate that is invoked once per iteration.</param>
      <param name="localFinally">The delegate that performs a final action on the local state of each
            thread.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="parallelOptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="body" /> 
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localInit" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="localFinally" /> argument is null.</exception>
      <exception cref="T:System.OperationCanceledException">The exception that is thrown when the 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the <paramref name="parallelOptions" /> 
            argument is set</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            SupportsDynamicPartitions property in the <paramref name="source" /> OrderablePartitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            KeysNormalized property in the <paramref name="source" /> OrderablePartitioner returns 
            false.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when any 
            methods in the <paramref name="source" /> OrderablePartitioner return null.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() or GetOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner do not return the correct number of partitions.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetPartitions() or GetOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner return an IList with at least one null value.</exception>
      <exception cref="T:System.InvalidOperationException">The exception that is thrown when the 
            GetDynamicPartitions() or GetDynamicOrderablePartitions() methods in the <paramref name="source" /> 
            OrderablePartitioner return an IEnumerable whose GetEnumerator() method returns null.</exception>
      <exception cref="T:System.AggregateException">The exception that is thrown to contain an exception
            thrown from one of the specified delegates.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when the 
            the <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> associated with the 
            the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> in the 
            <paramref name="parallelOptions" /> has been disposed.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult">ParallelLoopResult</see> structure
            that contains information on what portion of the loop completed.</returns>
      <remarks>
        <para>
            The <see cref="T:System.Collections.Concurrent.Partitioner{TSource}">Partitioner</see> is used to retrieve 
            the elements to be processed, in place of the original data source.  If the current element's 
            index is desired, the source must be an <see cref="T:System.Collections.Concurrent.OrderablePartitioner">
            OrderablePartitioner</see>.
            </para>
        <para>
            The <paramref name="body" /> delegate is invoked once for each element in the <paramref name="source" /> 
            Partitioner.  It is provided with the following parameters: the current element, 
            a <see cref="T:System.Threading.Tasks.ParallelLoopState">ParallelLoopState</see> instance that may be 
            used to break out of the loop prematurely, the current element's index (an Int64), and some local 
            state that may be shared amongst iterations that execute on the same thread.
            </para>
        <para>
            The <paramref name="localInit" /> delegate is invoked once for each thread that participates in the loop's 
            execution and returns the initial local state for each of those threads.  These initial states are passed to the first
            <paramref name="body" /> invocations on each thread.  Then, every subsequent body invocation returns a possibly 
            modified state value that is passed to the next body invocation.  Finally, the last body invocation on each thread returns a state value 
            that is passed to the <paramref name="localFinally" /> delegate.  The localFinally delegate is invoked once per thread to perform a final 
            action on each thread's local state.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Parallel.ThrowIfReducableToSingleOCE(System.Collections.Generic.IEnumerable{System.Exception},System.Threading.CancellationToken)">
      <summary>
            Internal utility function that implements the OCE filtering behavior for all Parallel.* APIs.
            Throws a single OperationCancelledException object with the token if the Exception collection only contains 
            OperationCancelledExceptions with the given CancellationToken.
            
            </summary>
      <param name="excCollection"> The exception collection to filter</param>
      <param name="ct"> The CancellationToken expected on all inner exceptions</param>
      <returns>
      </returns>
    </member>
    <member name="T:System.Threading.Tasks.ParallelLoopState">
      <summary>
            Enables iterations of <see cref="T:System.Threading.Tasks.Parallel" /> loops to interact with
            other iterations.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.ParallelLoopState.Stop">
      <summary>
            Communicates that the <see cref="T:System.Threading.Tasks.Parallel" /> loop should cease execution at the system's earliest
            convenience.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> method was previously called.  <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> and <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> may not be used in combination by iterations of the same loop.
            </exception>
      <remarks>
        <para>
          <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> may be used to communicate to the loop that no other iterations need be run.
            For long-running iterations that may already be executing, <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> causes <see cref="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
            to return true for all other iterations of the loop, such that another iteration may check <see cref="P:System.Threading.Tasks.ParallelLoopState.IsStopped" /> and exit early if it's observed to be true.
            </para>
        <para>
          <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> is typically employed in search-based algorithms, where once a result is found,
            no other iterations need be executed.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.ParallelLoopState.Break">
      <summary>
            Communicates that the <see cref="T:System.Threading.Tasks.Parallel" /> loop should cease execution at the system's earliest
            convenience of iterations beyond the current iteration.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> method was previously called. <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> and <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />
            may not be used in combination by iterations of the same loop.
            </exception>
      <remarks>
        <para>
          <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> may be used to communicate to the loop that no other iterations after the
            current iteration need be run. For example, if <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> is called from the 100th
            iteration of a for loop iterating in parallel from 0 to 1000, all iterations less than 100 should
            still be run, but the iterations from 101 through to 1000 are not necessary.
            </para>
        <para>
            For long-running iterations that may already be executing, <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> causes <see cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
            to be set to the current iteration's index if the current index is less than the current value of
            <see cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />.
            </para>
        <para>
          <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> is typically employed in search-based algorithms where an ordering is
            present in the data source.
            </para>
      </remarks>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState.InternalShouldExitCurrentIteration">
      <summary>
            Internal/virtual support for ShouldExitCurrentIteration.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration">
      <summary>
            Gets whether the current iteration of the loop should exit based
            on requests made by this or other iterations.
            </summary>
      <remarks>
            When an iteration of a loop calls <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> or <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />, or
            when one throws an exception, or when the loop is canceled, the <see cref="T:System.Threading.Tasks.Parallel" /> class will proactively
            attempt to prohibit additional iterations of the loop from starting execution.
            However, there may be cases where it is unable to prevent additional iterations from starting.
            It may also be the case that a long-running iteration has already begun execution.  In such
            cases, iterations may explicitly check the <see cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" /> property and
            cease execution if the property returns true.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState.IsStopped">
      <summary>
            Gets whether any iteration of the loop has called <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState.IsExceptional">
      <summary>
            Gets whether any iteration of the loop has thrown an exception that went unhandled by that
            iteration.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState.InternalLowestBreakIteration">
      <summary>
            Internal/virtual support for LowestBreakIteration.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration">
      <summary>
            Gets the lowest iteration of the loop from which <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> was called.
            </summary>
      <remarks>
            If no iteration of the loop called <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" />, this property will return null.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.ParallelLoopState32.#ctor(System.Threading.Tasks.ParallelLoopStateFlags32)">
      <summary>
            Internal constructor to ensure an instance isn't created by users.
            </summary>
      <param name="sharedParallelStateFlags">A flag shared among all threads participating
            in the execution of a certain loop.</param>
    </member>
    <member name="M:System.Threading.Tasks.ParallelLoopState32.InternalBreak">
      <summary>
            Communicates that parallel tasks should stop when they reach a specified iteration element.
            (which is CurrentIteration of the caller).
            </summary>
      <exception cref="T:System.InvalidOperationException">Break() called after Stop().</exception>
      <remarks>
            This is shared with all other concurrent threads in the system which are participating in the
            loop's execution. After calling Break(), no additional iterations will be executed on
            the current thread, and other worker threads will execute once they get beyond the calling iteration.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState32.CurrentIteration">
      <summary>
            Tracks the current loop iteration for the owning task.
            This is used to compute whether or not the task should
            terminate early due to a Break() call.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState32.InternalShouldExitCurrentIteration">
      <summary>
            Returns true if we should be exiting from the current iteration
            due to Stop(), Break() or exception.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState32.InternalLowestBreakIteration">
      <summary>
            Returns the lowest iteration at which Break() has been called, or
            null if Break() has not yet been called.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.ParallelLoopState64">
      <summary>
            Allows independent iterations of a parallel loop to interact with other iterations.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.ParallelLoopState64.#ctor(System.Threading.Tasks.ParallelLoopStateFlags64)">
      <summary>
            Internal constructor to ensure an instance isn't created by users.
            </summary>
      <param name="sharedParallelStateFlags">A flag shared among all threads participating
            in the execution of a certain loop.</param>
    </member>
    <member name="M:System.Threading.Tasks.ParallelLoopState64.InternalBreak">
      <summary>
            Communicates that parallel tasks should stop when they reach a specified iteration element.
            (which is CurrentIteration of the caller).
            </summary>
      <exception cref="T:System.InvalidOperationException">Break() called after Stop().</exception>
      <remarks>
            Atomically sets shared StoppedBroken flag to BROKEN, then atomically sets shared 
            LowestBreakIteration to CurrentIteration, but only if CurrentIteration is less than 
            LowestBreakIteration.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState64.CurrentIteration">
      <summary>
            Tracks the current loop iteration for the owning task.
            This is used to compute whether or not the task should
            terminate early due to a Break() call.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState64.InternalShouldExitCurrentIteration">
      <summary>
            Returns true if we should be exiting from the current iteration
            due to Stop(), Break() or exception.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopState64.InternalLowestBreakIteration">
      <summary>
            Returns the lowest iteration at which Break() has been called, or
            null if Break() has not yet been called.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.ParallelLoopStateFlags">
      <summary>
            State information that is common between ParallelStateFlags class
            and ParallelStateFlags64 class.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.ParallelLoopStateFlags32">
      <summary>
            An internal class used to share accounting information in 32-bit versions
            of For()/ForEach() loops.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.ParallelLoopStateFlags32.ShouldExitLoop(System.Int32)">
      <summary>
            Lets the caller know whether or not to prematurely exit the For/ForEach loop.
            If this returns true, then exit the loop.  Otherwise, keep going.
            </summary>
      <param name="CallerIteration">The caller's current iteration point
            in the loop.</param>
      <remarks>
            The loop should exit on any one of the following conditions:
              (1) Stop() has been called by one or more tasks.
              (2) An exception has been raised by one or more tasks.
              (3) Break() has been called by one or more tasks, and
                  CallerIteration exceeds the (lowest) iteration at which 
                  Break() was called.
              (4) The loop was canceled.
            </remarks>
    </member>
    <member name="T:System.Threading.Tasks.ParallelLoopStateFlags64">
      <summary>
            An internal class used to share accounting information in 64-bit versions
            of For()/ForEach() loops.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.ParallelLoopStateFlags64.ShouldExitLoop(System.Int64)">
      <summary>
            Lets the caller know whether or not to prematurely exit the For/ForEach loop.
            If this returns true, then exit the loop.  Otherwise, keep going.
            </summary>
      <param name="CallerIteration">The caller's current iteration point
            in the loop.</param>
      <remarks>
            The loop should exit on any one of the following conditions:
              (1) Stop() has been called by one or more tasks.
              (2) An exception has been raised by one or more tasks.
              (3) Break() has been called by one or more tasks, and
                  CallerIteration exceeds the (lowest) iteration at which 
                  Break() was called.
              (4) The loop has been canceled.
            </remarks>
    </member>
    <member name="T:System.Threading.Tasks.ParallelLoopResult">
      <summary>
            Provides completion status on the execution of a <see cref="T:System.Threading.Tasks.Parallel" /> loop.
            </summary>
      <remarks>
            If <see cref="P:System.Threading.Tasks.ParallelLoopResult.IsCompleted" /> returns true, then the loop ran to completion, such that all iterations
            of the loop were executed. If <see cref="P:System.Threading.Tasks.ParallelLoopResult.IsCompleted" /> returns false and <see cref="P:System.Threading.Tasks.ParallelLoopResult.LowestBreakIteration" /> returns null, a call to <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> was used to end the loop prematurely. If <see cref="P:System.Threading.Tasks.ParallelLoopResult.IsCompleted" /> returns false and <see cref="P:System.Threading.Tasks.ParallelLoopResult.LowestBreakIteration" /> returns a non-null integral
            value, <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> was used to end the loop prematurely.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopResult.IsCompleted">
      <summary>
            Gets whether the loop ran to completion, such that all iterations of the loop were executed
            and the loop didn't receive a request to end prematurely.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.ParallelLoopResult.LowestBreakIteration">
      <summary>
            Gets the index of the lowest iteration from which <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
            was called.
            </summary>
      <remarks>
            If <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> was not employed, this property will
            return null.
            </remarks>
    </member>
    <member name="T:System.Threading.Tasks.Shared`1">
      <summary>
            Utility class for allocating structs as heap variables
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.IndexRange">
      <summary>
            Represents an index range
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.RangeWorker">
      <summary>
            The RangeWorker struct wraps the state needed by a task that services the parallel loop
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.RangeWorker.#ctor(System.Threading.Tasks.IndexRange[],System.Int32,System.Int64)">
      <summary>
            Initializes a RangeWorker struct
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.RangeWorker.FindNewWork(System.Int64@,System.Int64@)">
      <summary>
            Implements the core work search algorithm that will be used for this range worker. 
            </summary> 
            
            Usage pattern is:
               1) the thread associated with this rangeworker calls FindNewWork
               2) if we return true, the worker uses the nFromInclusiveLocal and nToExclusiveLocal values
                  to execute the sequential loop
               3) if we return false it means there is no more work left. It's time to quit.        
               
        </member>
    <member name="M:System.Threading.Tasks.RangeWorker.FindNewWork32(System.Int32@,System.Int32@)">
      <summary>
            32 bit integer version of FindNewWork. Assumes the ranges were initialized with 32 bit values.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.RangeManager">
      <summary>
            Represents the entire loop operation, keeping track of workers and ranges.
            </summary>
            
            The usage pattern is:
               1) The Parallel loop entry function (ForWorker) creates an instance of this class
               2) Every thread joining to service the parallel loop calls RegisterWorker to grab a 
                  RangeWorker struct to wrap the state it will need to find and execute work, 
                  and they keep interacting with that struct until the end of the loop
        </member>
    <member name="M:System.Threading.Tasks.RangeManager.#ctor(System.Int64,System.Int64,System.Int64,System.Int32)">
      <summary>
            Initializes a RangeManager with the given loop parameters, and the desired number of outer ranges
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.RangeManager.RegisterNewWorker">
      <summary>
            The function that needs to be called by each new worker thread servicing the parallel loop
            in order to get a RangeWorker struct that wraps the state for finding and executing indices
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.Task">
      <summary>
            Represents an asynchronous operation.
            </summary>
      <remarks>
        <para>
          <see cref="T:System.Threading.Tasks.Task" /> instances may be created in a variety of ways. The most common approach is by
            using the Task type's <see cref="P:System.Threading.Tasks.Task.Factory" /> property to retrieve a <see cref="T:System.Threading.Tasks.TaskFactory" /> instance that can be used to create tasks for several
            purposes. For example, to create a <see cref="T:System.Threading.Tasks.Task" /> that runs an action, the factory's StartNew
            method may be used:
            <code>
            // C# 
            var t = Task.Factory.StartNew(() =&gt; DoAction());
            
            ' Visual Basic 
            Dim t = Task.Factory.StartNew(Function() DoAction())
            </code></para>
        <para>
            The <see cref="T:System.Threading.Tasks.Task" /> class also provides constructors that initialize the Task but that do not
            schedule it for execution. For performance reasons, TaskFactory's StartNew method should be the
            preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation
            and scheduling must be separated, the constructors may be used, and the task's <see cref="M:System.Threading.Tasks.Task.Start" />
            method may then be used to schedule the task for execution at a later time.
            </para>
        <para>
            All members of <see cref="T:System.Threading.Tasks.Task" />, except for <see cref="M:System.Threading.Tasks.Task.Dispose" />, are thread-safe
            and may be used from multiple threads concurrently.
            </para>
        <para>
            For operations that return values, the <see cref="T:System.Threading.Tasks.Task`1" /> class
            should be used.
            </para>
        <para>
            For developers implementing custom debuggers, several internal and private members of Task may be
            useful (these may change from release to release). The Int32 m_taskId field serves as the backing
            store for the <see cref="P:System.Threading.Tasks.Task.Id" /> property, however accessing this field directly from a debugger may be
            more efficient than accessing the same value through the property's getter method (the
            s_taskIdCounter Int32 counter is used to retrieve the next available ID for a Task). Similarly, the
            Int32 m_stateFlags field stores information about the current lifecycle stage of the Task,
            information also accessible through the <see cref="P:System.Threading.Tasks.Task.Status" /> property. The m_action System.Object
            field stores a reference to the Task's delegate, and the m_stateObject System.Object field stores the
            async state passed to the Task by the developer. Finally, for debuggers that parse stack frames, the
            InternalWait method serves a potential marker for when a Task is entering a wait operation.
            </para>
      </remarks>
    </member>
    <member name="T:System.Threading.Tasks.Task.TaskContinuation">
      <summary>
            A structure to hold continuation information.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.TaskContinuation.#ctor(System.Threading.Tasks.Task,System.Threading.Tasks.TaskScheduler,System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Constructs a new continuation structure.
            </summary>
      <param name="task">The task to be activated.</param>
      <param name="options">The continuation options.</param>
      <param name="scheduler">The scheduler to use for the continuation.</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.TaskContinuation.Run(System.Threading.Tasks.Task,System.Boolean)">
      <summary>
            Invokes the continuation for the target completion task.
            </summary>
      <param name="completedTask">The completed task.</param>
      <param name="bCanInlineContinuationTask">Whether the continuation can be inlined.</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.#ctor(System.Action)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action.
            </summary>
      <param name="action">The delegate that represents the code to execute in the Task.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="action" /> argument is null.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            </summary>
      <param name="action">The delegate that represents the code to execute in the Task.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            that will be assigned to the new Task.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="action" /> argument is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.
            </summary>
      <param name="action">The delegate that represents the code to execute in the task.</param>
      <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the Task's behavior.
            </param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="action" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.
            </summary>
      <param name="action">The delegate that represents the code to execute in the task.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> that will be assigned to the new task.</param>
      <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the Task's behavior.
            </param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="action" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and state.
            </summary>
      <param name="action">The delegate that represents the code to execute in the task.</param>
      <param name="state">An object representing data to be used by the action.</param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="action" /> argument is null.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, snd options.
            </summary>
      <param name="action">The delegate that represents the code to execute in the task.</param>
      <param name="state">An object representing data to be used by the action.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> that will be assigned to the new task.</param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="action" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, snd options.
            </summary>
      <param name="action">The delegate that represents the code to execute in the task.</param>
      <param name="state">An object representing data to be used by the action.</param>
      <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the Task's behavior.
            </param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="action" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, snd options.
            </summary>
      <param name="action">The delegate that represents the code to execute in the task.</param>
      <param name="state">An object representing data to be used by the action.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> that will be assigned to the new task.</param>
      <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the Task's behavior.
            </param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="action" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.#ctor(System.Object,System.Object,System.Threading.Tasks.Task,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.InternalTaskOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            An internal constructor used by the factory methods on task and its descendent(s).
            This variant does not capture the ExecutionContext; it is up to the caller to do that.
            </summary>
      <param name="action">An action to execute.</param>
      <param name="state">Optional state to pass to the action.</param>
      <param name="parent">Parent of Task.</param>
      <param name="cancellationToken">A CancellationToken for the task.</param>
      <param name="scheduler">A task scheduler under which the task will run.</param>
      <param name="creationOptions">Options to control its execution.</param>
      <param name="internalOptions">Internal options to control its execution</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.TaskConstructorCore(System.Object,System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.InternalTaskOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Common logic used by the following internal ctors:
                Task()
                Task(object action, object state, Task parent, TaskCreationOptions options, TaskScheduler taskScheduler)
            
            ASSUMES THAT m_creatingTask IS ALREADY SET.
            
            </summary>
      <param name="action">Action for task to execute.</param>
      <param name="state">Object to which to pass to action (may be null)</param>
      <param name="scheduler">Task scheduler on which to run thread (only used by continuation tasks).</param>
      <param name="cancellationToken">A CancellationToken for the Task.</param>
      <param name="creationOptions">Options to customize behavior of Task.</param>
      <param name="internalOptions">Internal options to customize behavior of Task.</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.DeregisterCancellationCallback">
      <summary>
            Checks if we registered a CT callback during construction, and deregisters it. 
            This should be called when we know the registration isn't useful anymore. Specifically from Finish() if the task has completed
            successfully or with an exception.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.PossiblyCaptureContext(System.Threading.StackCrawlMark2@)">
      <summary>
            Captures the ExecutionContext so long as flow isn't suppressed.
            </summary>
      <param name="stackMark">A stack crawl mark pointing to the frame of the caller.</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.AddNewChild">
      <summary>
            Internal function that will be called by a new child task to add itself to 
            the children list of the parent (this).
            
            Since a child task can only be created from the thread executing the action delegate
            of this task, reentrancy is neither required nor supported. This should not be called from
            anywhere other than the task construction/initialization codepaths.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.Start">
      <summary>
            Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the current <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>.
            </summary>
      <remarks>
            A task may only be started and run only once.  Any attempts to schedule a task a second time
            will result in an exception.
            </remarks>
      <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started. It may have already been started,
            executed, or canceled, or it may have been created in a manner that doesn't support direct
            scheduling.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
      <summary>
            Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the specified <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>.
            </summary>
      <remarks>
            A task may only be started and run only once. Any attempts to schedule a task a second time will
            result in an exception.
            </remarks>
      <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> with which to associate
            and execute this task.
            </param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler" /> argument is null.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started. It may have already been started,
            executed, or canceled, or it may have been created in a manner that doesn't support direct
            scheduling.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.RunSynchronously">
      <summary>
            Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the current <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>.
            </summary>
      <remarks>
        <para>
            A task may only be started and run only once. Any attempts to schedule a task a second time will
            result in an exception.
            </para>
        <para>
            Tasks executed with <see cref="M:System.Threading.Tasks.Task.RunSynchronously" /> will be associated with the current <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>.
            </para>
        <para>
            If the target scheduler does not support running this Task on the current thread, the Task will
            be scheduled for execution on the scheduler, and the current thread will block until the
            Task has completed execution.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started. It may have already been started,
            executed, or canceled, or it may have been created in a manner that doesn't support direct
            scheduling.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
      <summary>
            Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the <see cref="T:System.Threading.Tasks.TaskScheduler">scheduler</see> provided.
            </summary>
      <remarks>
        <para>
            A task may only be started and run only once. Any attempts to schedule a task a second time will
            result in an exception.
            </para>
        <para>
            If the target scheduler does not support running this Task on the current thread, the Task will
            be scheduled for execution on the scheduler, and the current thread will block until the
            Task has completed execution.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started. It may have already been started,
            executed, or canceled, or it may have been created in a manner that doesn't support direct
            scheduling.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.
            </exception>
      <exception cref="T:System.ArgumentNullException">The <paramref name="scheduler" /> parameter
            is null.</exception>
      <param name="scheduler">The scheduler on which to attempt to run this task inline.</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.ThrowIfDisposed">
      <summary>
            Throws an exception if the task has been disposed, and hence can no longer be accessed.
            </summary>
      <exception cref="T:System.ObjectDisposedException">The task has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.SetCompleted">
      <summary>
            Sets the internal completion event.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.Dispose">
      <summary>
            Disposes the <see cref="T:System.Threading.Tasks.Task" />, releasing all of its unmanaged resources.  
            </summary>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.Tasks.Task" />, this method is not thread-safe.
            Also, <see cref="M:System.Threading.Tasks.Task.Dispose" /> may only be called on a <see cref="T:System.Threading.Tasks.Task" /> that is in one of
            the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>,
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
      <exception cref="T:System.InvalidOperationException">
            The exception that is thrown if the <see cref="T:System.Threading.Tasks.Task" /> is not in 
            one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>,
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
      <summary>
            Disposes the <see cref="T:System.Threading.Tasks.Task" />, releasing all of its unmanaged resources.  
            </summary>
      <param name="disposing">
            A Boolean value that indicates whether this method is being called due to a call to <see cref="M:System.Threading.Tasks.Task.Dispose" />.
            </param>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.Tasks.Task" />, this method is not thread-safe.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Task.ScheduleAndStart(System.Boolean)">
      <summary>
            Schedules the task for execution.
            </summary>
      <param name="needsProtection">If true, TASK_STATE_STARTED bit is turned on in
            an atomic fashion, making sure that TASK_STATE_CANCELED does not get set
            underneath us.  If false, TASK_STATE_STARTED bit is OR-ed right in.  This
            allows us to streamline things a bit for StartNew(), where competing cancellations
            are not a problem.</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.AddException(System.Object)">
      <summary>
            Adds an exception to the list of exceptions this task has thrown.
            </summary>
      <param name="exceptionObject">An object representing either an Exception or a collection of Exceptions.</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.GetExceptions(System.Boolean)">
      <summary>
            Returns a list of exceptions by aggregating the holder's contents. Or null if
            no exceptions have been thrown.
            </summary>
      <param name="includeTaskCanceledExceptions">Whether to include a TCE if cancelled.</param>
      <returns>An aggregate exception, or null if no exceptions have been caught.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Task.ThrowIfExceptional(System.Boolean)">
      <summary>
            Throws an aggregate exception if the task contains exceptions. 
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.UpdateExceptionObservedStatus">
      <summary>
            Checks whether this is an attached task, and whether we are being called by the parent task.
            And sets the TASK_STATE_EXCEPTIONOBSERVEDBYPARENT status flag based on that.
            
            This is meant to be used internally when throwing an exception, and when WaitAll is gathering 
            exceptions for tasks it waited on. If this flag gets set, the implicit wait on children 
            will skip exceptions to prevent duplication.
            
            This should only be called when this task has completed with an exception
            
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.Finish(System.Boolean)">
      <summary>
             Signals completion of this particular task.
            
             The bUserDelegateExecuted parameter indicates whether this Finish() call comes following the
             full execution of the user delegate. 
             
             If bUserDelegateExecuted is false, it mean user delegate wasn't invoked at all (either due to
             a cancellation request, or because this task is a promise style Task). In this case, the steps
             involving child tasks (i.e. WaitForChildren) will be skipped.
             
             </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.FinishStageTwo">
      <summary>
            FinishStageTwo is to be executed as soon as we known there are no more children to complete. 
            It can happen i) either on the thread that originally executed this task (if no children were spawned, or they all completed by the time this task's delegate quit)
                         ii) or on the thread that executed the last child.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.FinishStageThree">
      <summary>
            Final stage of the task completion code path. Notifies the parent (if any) that another of its childre are done, and runs continuations.
            This function is only separated out from FinishStageTwo because these two operations are also needed to be called from CancellationCleanupLogic()
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.ProcessChildCompletion(System.Threading.Tasks.Task)">
      <summary>
            This is called by children of this task when they are completed.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.AddExceptionsFromChildren">
      <summary>
            This is to be called just before the task does its final state transition. 
            It traverses the list of exceptional children, and appends their aggregate exceptions into this one's exception list
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.FinishThreadAbortedTask(System.Boolean,System.Boolean)">
      <summary>
            Special purpose Finish() entry point to be used when the task delegate throws a ThreadAbortedException
            This makes a note in the state flags so that we avoid any costly synchronous operations in the finish codepath
            such as inlined continuations
            </summary>
      <param name="bTAEAddedToExceptionHolder">
            Indicates whether the ThreadAbortException was added to this task's exception holder. 
            This should always be true except for the case of non-root self replicating task copies.
            </param>
      <param name="delegateRan">Whether the delegate was executed.</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.Execute">
      <summary>
            Executes the task. This method will only be called once, and handles bookeeping associated with
            self-replicating tasks, in addition to performing necessary exception marshaling.
            </summary>
      <exception cref="T:System.ObjectDisposedException">The task has already been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.ExecuteEntry(System.Boolean)">
      <summary>
            Outermost entry function to execute this task. Handles all aspects of executing a task on the caller thread.
            Currently this is called by IThreadPoolWorkItem.ExecuteWorkItem(), and TaskManager.TryExecuteInline. 
            
            </summary>
      <param name="bPreventDoubleExecution"> Performs atomic updates to prevent double execution. Should only be set to true
            in codepaths servicing user provided TaskSchedulers. The ConcRT or ThreadPool schedulers don't need this. </param>
    </member>
    <member name="M:System.Threading.Tasks.Task.InnerInvoke">
      <summary>
            The actual code which invokes the body of the task. This can be overriden in derived types.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.InnerInvokeWithArg(System.Threading.Tasks.Task)">
      <summary>
            Alternate InnerInvoke prototype to be called from ExecuteSelfReplicating() so that
            the Parallel Debugger can discover the actual task being invoked. 
            Details: Here, InnerInvoke is actually being called on the rootTask object while we are actually executing the
            childTask. And the debugger needs to discover the childTask, so we pass that down as an argument.
            The NoOptimization and NoInlining flags ensure that the childTask pointer is retained, and that this
            function appears on the callstack.
            </summary>
      <param name="childTask">
      </param>
    </member>
    <member name="M:System.Threading.Tasks.Task.HandleException(System.Exception)">
      <summary>
            Performs whatever handling is necessary for an unhandled exception. Normally
            this just entails adding the exception to the holder object. 
            </summary>
      <param name="unhandledException">The exception that went unhandled.</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.Wait">
      <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.
            </summary>
      <exception cref="T:System.AggregateException">
            The <see cref="T:System.Threading.Tasks.Task" /> was canceled -or- an exception was thrown during
            the execution of the <see cref="T:System.Threading.Tasks.Task" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
      <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.
            </summary>
      <param name="timeout">
            A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <returns>
            true if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, false.
            </returns>
      <exception cref="T:System.AggregateException">
            The <see cref="T:System.Threading.Tasks.Task" /> was canceled -or- an exception was thrown during the execution of the <see cref="T:System.Threading.Tasks.Task" />.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an
            infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
      <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.
            </summary>
      <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> to observe while waiting for the task to complete.
            </param>
      <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken" /> was canceled.
            </exception>
      <exception cref="T:System.AggregateException">
            The <see cref="T:System.Threading.Tasks.Task" /> was canceled -or- an exception was thrown during the execution of the <see cref="T:System.Threading.Tasks.Task" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" />
            has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.Wait(System.Int32)">
      <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.
            </summary>
      <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to
            wait indefinitely.</param>
      <returns>true if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise,
            false.
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
      <exception cref="T:System.AggregateException">
            The <see cref="T:System.Threading.Tasks.Task" /> was canceled -or- an exception was thrown during the execution of the <see cref="T:System.Threading.Tasks.Task" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" />
            has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.
            </summary>
      <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to
            wait indefinitely.
            </param>
      <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> to observe while waiting for the task to complete.
            </param>
      <returns>
            true if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, false.
            </returns>
      <exception cref="T:System.AggregateException">
            The <see cref="T:System.Threading.Tasks.Task" /> was canceled -or- an exception was thrown during the execution of the <see cref="T:System.Threading.Tasks.Task" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" />
            has been disposed.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken" /> was canceled.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.InternalWait(System.Int32,System.Threading.CancellationToken)">
      <summary>
            The core wait function, which is only accesible internally. It's meant to be used in places in TPL code where 
            the current context is known or cached.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.InternalCancel(System.Boolean)">
      <summary>
            Cancels the <see cref="T:System.Threading.Tasks.Task" />.
            </summary>
      <param name="bCancelNonExecutingOnly"> Indiactes whether we should only cancel non-invoked tasks.
            For the default scheduler this option will only be serviced through TryDequeue.
            For custom schedulers we also attempt an atomic state transition.</param>
      <returns>true if the task was successfully canceled; otherwise, false.</returns>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.Tasks.Task" />
            has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.SetCancellationAcknowledged">
      <summary>
            Sets the task's cancellation acknowledged flag.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.FinishContinuations">
      <summary>
            Runs all of the continuations, as appropriate.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWithIsRightKind(System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Helper function to determine whether the current task is in the state desired by the
            continuation kind under evaluation. Three possibilities exist: the task failed with
            an unhandled exception (OnFailed), the task was canceled before running (OnAborted),
            or the task completed successfully (OnCompletedSuccessfully).  Note that the last
            one includes completing due to cancellation.
            </summary>
      <param name="options">The continuation options under evaluation.</param>
      <returns>True if the continuation should be run given the task's current state.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.
            </summary>
      <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task" /> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.
            </summary>
      <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="cancellationToken"> The <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> that will be assigned to the new continuation task.</param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task" /> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.
            </summary>
      <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.  When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task" /> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.
            </summary>
      <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task" /> will not be scheduled for execution until the current task has
            completed. If the continuation criteria specified through the <paramref name="continuationOptions" /> parameter are not met, the continuation task will be canceled
            instead of scheduled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.
            </summary>
      <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> that will be assigned to the new continuation task.</param>
      <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its
            execution.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task" /> will not be scheduled for execution until the current task has
            completed. If the criteria specified through the <paramref name="continuationOptions" /> parameter
            are not met, the continuation task will be canceled instead of scheduled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.
            </summary>
      <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
      <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1" /> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.
            </summary>
      <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
      <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> that will be assigned to the new continuation task.</param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1" /> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.
            </summary>
      <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
      <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.  When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1" /> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.
            </summary>
      <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
      <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1" /> will not be scheduled for execution until the current task has
            completed. If the continuation criteria specified through the <paramref name="continuationOptions" /> parameter are not met, the continuation task will be canceled
            instead of scheduled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.
            </summary>
      <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
      <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
      <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its
            execution.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1" /> will not be scheduled for execution until the current task has
            completed. If the criteria specified through the <paramref name="continuationOptions" /> parameter
            are not met, the continuation task will be canceled instead of scheduled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.CreationOptionsFromContinuationOptions(System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskCreationOptions@,System.Threading.Tasks.InternalTaskOptions@)">
      <summary>
            Converts TaskContinuationOptions to TaskCreationOptions, and also does
            some validity checking along the way.
            </summary>
      <param name="continuationOptions">Incoming TaskContinuationOptions</param>
      <param name="creationOptions">Outgoing TaskCreationOptions</param>
      <param name="internalOptions">Outgoing InternalTaskOptions</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.ContinueWithCore(System.Threading.Tasks.Task,System.Threading.Tasks.TaskScheduler,System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Registers the continuation and possibly runs it (if the task is already finished).
            </summary>
      <param name="continuationTask">The continuation task itself.</param>
      <param name="scheduler">TaskScheduler with which to associate continuation task.</param>
      <param name="options">Restrictions on when the continuation becomes active.</param>
    </member>
    <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
      <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.
            </summary>
      <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.
            </param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks" /> argument contains a null element.
            </exception>
      <exception cref="T:System.AggregateException">
            At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled -or- an exception was thrown during
            the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
      <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.
            </summary>
      <returns>
            true if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time;
            otherwise, false.
            </returns>
      <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.
            </param>
      <param name="timeout">
            A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="tasks" /> argument contains a null element.
            </exception>
      <exception cref="T:System.AggregateException">
            At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled -or- an exception was thrown during
            the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an
            infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
      <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.
            </summary>
      <returns>
            true if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time;
            otherwise, false.
            </returns>
      <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to
            wait indefinitely.</param>
      <param name="tasks">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.
            </param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="tasks" /> argument contains a null element.
            </exception>
      <exception cref="T:System.AggregateException">
            At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled -or- an exception was thrown during
            the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
      <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.
            </summary>
      <returns>
            true if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time;
            otherwise, false.
            </returns>
      <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.
            </param>
      <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> to observe while waiting for the tasks to complete.
            </param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="tasks" /> argument contains a null element.
            </exception>
      <exception cref="T:System.AggregateException">
            At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled -or- an exception was thrown during
            the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken" /> was canceled.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
      <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.
            </summary>
      <returns>
            true if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time;
            otherwise, false.
            </returns>
      <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.
            </param>
      <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to
            wait indefinitely.
            </param>
      <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> to observe while waiting for the tasks to complete.
            </param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="tasks" /> argument contains a null element.
            </exception>
      <exception cref="T:System.AggregateException">
            At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled -or- an exception was thrown during
            the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken" /> was canceled.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.WaitAllSTAAnd64Aware(System.Threading.WaitHandle[],System.Int32,System.Threading.CancellationToken)">
      <summary>
            Waits for a set of handles in a STA-aware way.  In other words, it will wait for each
            of the events individually if we're on a STA thread, because MsgWaitForMultipleObjectsEx
            can't do a true wait-all due to its hidden message queue event. This is not atomic,
            of course, but we only wait on one-way (MRE) events anyway so this is OK.
            </summary>
      <param name="waitHandles">An array of wait handles to wait on.</param>
      <param name="millisecondsTimeout">The timeout to use during waits.</param>
      <param name="cancellationToken">The cancellationToken that enables a wait to be canceled.</param>
      <returns>True if all waits succeeded, false if a timeout occurred.</returns>
    </member>
    <member name="M:System.Threading.Tasks.Task.FastWaitAll(System.Threading.Tasks.Task[])">
      <summary>
            Internal WaitAll implementation which is meant to be used with small number of tasks,
            optimized for Parallel.Invoke and other structured primitives.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.AddExceptionsForCompletedTask(System.Collections.Generic.List{System.Exception}@,System.Threading.Tasks.Task)">
      <summary>
            This internal function is only meant to be called by WaitAll()
            If the completed task is canceled or it has other exceptions, here we will add those
            into the passed in exception list (which will be lazily initialized here).
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
      <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.
            </summary>
      <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.
            </param>
      <returns>The index of the completed task in the <paramref name="tasks" /> array argument.</returns>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="tasks" /> argument contains a null element.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
      <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.
            </summary>
      <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.
            </param>
      <param name="timeout">
            A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <returns>
            The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the
            timeout occurred.
            </returns>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="tasks" /> argument contains a null element.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an
            infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue" />.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
      <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.
            </summary>
      <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.
            </param>
      <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> to observe while waiting for a task to complete.
            </param>
      <returns>
            The index of the completed task in the <paramref name="tasks" /> array argument.
            </returns>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="tasks" /> argument contains a null element.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken" /> was canceled.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
      <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.
            </summary>
      <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.
            </param>
      <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to
            wait indefinitely.
            </param>
      <returns>
            The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the
            timeout occurred.
            </returns>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="tasks" /> argument contains a null element.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
      <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.
            </summary>
      <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.
            </param>
      <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to
            wait indefinitely.
            </param>
      <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken" /> to observe while waiting for a task to complete.
            </param>
      <returns>
            The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the
            timeout occurred.
            </returns>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="tasks" /> argument contains a null element.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken" /> was canceled.
            </exception>
    </member>
    <member name="P:System.Threading.Tasks.Task.Id">
      <summary>
            Gets a unique ID for this <see cref="T:System.Threading.Tasks.Task">Task</see> instance.
            </summary>
      <remarks>
            Task IDs are assigned on-demand and do not necessarily represent the order in the which Task
            instances were created.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.Task.CurrentId">
      <summary>
            Returns the unique ID of the currently executing <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.InternalCurrent">
      <summary>
            Gets the <see cref="T:System.Threading.Tasks.Task">Task</see> instance currently executing, or
            null if none exists.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.CurrentStackGuard">
      <summary>
            Gets the StackGuard object assigned to the current thread.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.Exception">
      <summary>
            Gets the <see cref="T:System.AggregateException">Exception</see> that caused the <see cref="T:System.Threading.Tasks.Task">Task</see> to end prematurely. If the <see cref="T:System.Threading.Tasks.Task">Task</see> completed successfully or has not yet thrown any
            exceptions, this will return null.
            </summary>
      <remarks>
            Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a
            <see cref="T:System.AggregateException" /> in calls to <see cref="M:System.Threading.Tasks.Task.Wait">Wait</see>
            or in accesses to the <see cref="P:System.Threading.Tasks.Task.Exception" /> property.  Any exceptions not observed by the time
            the Task instance is garbage collected will be propagated on the finalizer thread.
            </remarks>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task">Task</see>
            has been disposed.
            </exception>
    </member>
    <member name="P:System.Threading.Tasks.Task.Status">
      <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> of this Task. 
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.IsCanceled">
      <summary>
            Gets whether this <see cref="T:System.Threading.Tasks.Task">Task</see> instance has completed
            execution due to being canceled.
            </summary>
      <remarks>
            A <see cref="T:System.Threading.Tasks.Task">Task</see> will complete in Canceled state either if its <see cref="P:System.Threading.Tasks.Task.CancellationToken">CancellationToken</see> 
            was marked for cancellation before the task started executing, or if the task acknowledged the cancellation request on 
            its already signaled CancellationToken by throwing an 
            <see cref="T:System.OperationCanceledException">OperationCanceledException</see> that bears the same 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.Task.IsCancellationRequested">
      <summary>
            Returns true if this task has a cancellation token and it was signaled.
            To be used internally in execute entry codepaths.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.CancellationToken">
      <summary>
            This internal property provides access to the CancellationToken that was set on the task 
            when it was constructed.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.IsCancellationAcknowledged">
      <summary>
            Gets whether this <see cref="T:System.Threading.Tasks.Task" /> threw an OperationCanceledException while its CancellationToken was signaled.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.IsCompleted">
      <summary>
            Gets whether this <see cref="T:System.Threading.Tasks.Task">Task</see> has completed.
            </summary>
      <remarks>
        <see cref="P:System.Threading.Tasks.Task.IsCompleted" /> will return true when the Task is in one of the three
            final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>,
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.Task.IsDisposed">
      <summary>
            Checks whether this task has been disposed.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.CreationOptions">
      <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used
            to create this task.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.AsyncState">
      <summary>
            Gets the state object supplied when the <see cref="T:System.Threading.Tasks.Task">Task</see> was created,
            or null if none was supplied.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.ExecutingTaskScheduler">
      <summary>
            Provides access to the TaskScheduler responsible for executing this Task.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.Factory">
      <summary>
            Provides access to factory methods for creating <see cref="T:System.Threading.Tasks.Task" /> and <see cref="T:System.Threading.Tasks.Task`1" /> instances.
            </summary>
      <remarks>
            The factory returned from <see cref="P:System.Threading.Tasks.Task.Factory" /> is a default instance
            of <see cref="T:System.Threading.Tasks.TaskFactory" />, as would result from using
            the default constructor on TaskFactory.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.Task.CompletedEvent">
      <summary>
            Provides an event that can be used to wait for completion.
            Only called by Wait*(), which means that we really do need to instantiate a completion event.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.IsSelfReplicatingRoot">
      <summary>
            Determines whether this is the root task of a self replicating group.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.IsChildReplica">
      <summary>
            Determines whether the task is a replica itself.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.ExceptionRecorded">
      <summary>
            The property formerly known as IsFaulted.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.IsFaulted">
      <summary>
            Gets whether the <see cref="T:System.Threading.Tasks.Task" /> completed due to an unhandled exception.
            </summary>
      <remarks>
            If <see cref="P:System.Threading.Tasks.Task.IsFaulted" /> is true, the Task's <see cref="P:System.Threading.Tasks.Task.Status" /> will be equal to
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">TaskStatus.Faulted</see>, and its
            <see cref="P:System.Threading.Tasks.Task.Exception" /> property will be non-null.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.Task.IsExceptionObservedByParent">
      <summary>
            Checks whether the TASK_STATE_EXCEPTIONOBSERVEDBYPARENT status flag is set,
            This will only be used by the implicit wait to prevent double throws
            
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.Task.IsDelegateInvoked">
      <summary>
            Checks whether the body was ever invoked. Used by task scheduler code to verify custom schedulers actually ran the task.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.Task`1">
      <summary>
            Represents an asynchronous operation that produces a result at some time in the future.
            </summary>
      <typeparam name="TResult">
            The type of the result produced by this <see cref="T:System.Threading.Tasks.Task`1" />.
            </typeparam>
      <remarks>
        <para>
          <see cref="T:System.Threading.Tasks.Task`1" /> instances may be created in a variety of ways. The most common approach is by
            using the task's <see cref="P:System.Threading.Tasks.Task`1.Factory" /> property to retrieve a <see cref="T:System.Threading.Tasks.TaskFactory`1" /> instance that can be used to create tasks for several
            purposes. For example, to create a <see cref="T:System.Threading.Tasks.Task`1" /> that runs a function, the factory's StartNew
            method may be used:
            <code>
            // C# 
            var t = Task&lt;int&gt;.Factory.StartNew(() =&gt; GenerateResult());
            - or -
            var t = Task.Factory.StartNew(() =&gt; GenerateResult());
            
            ' Visual Basic 
            Dim t = Task&lt;int&gt;.Factory.StartNew(Function() GenerateResult())
            - or -
            Dim t = Task.Factory.StartNew(Function() GenerateResult())
            </code></para>
        <para>
            The <see cref="T:System.Threading.Tasks.Task`1" /> class also provides constructors that initialize the task but that do not
            schedule it for execution. For performance reasons, the StartNew method should be the
            preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation
            and scheduling must be separated, the constructors may be used, and the task's 
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see>
            method may then be used to schedule the task for execution at a later time.
            </para>
        <para>
            All members of <see cref="T:System.Threading.Tasks.Task`1" />, except for 
            <see cref="M:System.Threading.Tasks.Task.Dispose">Dispose</see>, are thread-safe
            and may be used from multiple threads concurrently.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0})">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function.
            </summary>
      <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.
            </param>
      <exception cref="T:System.ArgumentException">
            The <paramref name="function" /> argument is null.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function.
            </summary>
      <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.
            </param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to be assigned to this task.</param>
      <exception cref="T:System.ArgumentException">
            The <paramref name="function" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function and creation options.
            </summary>
      <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.
            </param>
      <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the task's behavior.
            </param>
      <exception cref="T:System.ArgumentException">
            The <paramref name="function" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function and creation options.
            </summary>
      <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.
            </param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</param>
      <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the task's behavior.
            </param>
      <exception cref="T:System.ArgumentException">
            The <paramref name="function" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified function and state.
            </summary>
      <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.
            </param>
      <param name="state">An object representing data to be used by the action.</param>
      <exception cref="T:System.ArgumentException">
            The <paramref name="function" /> argument is null.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified action, state, and options.
            </summary>
      <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.
            </param>
      <param name="state">An object representing data to be used by the function.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to be assigned to the new task.</param>
      <exception cref="T:System.ArgumentException">
            The <paramref name="function" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified action, state, and options.
            </summary>
      <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.
            </param>
      <param name="state">An object representing data to be used by the function.</param>
      <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the task's behavior.
            </param>
      <exception cref="T:System.ArgumentException">
            The <paramref name="function" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1" /> with the specified action, state, and options.
            </summary>
      <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result" /> property will be set to return the result value of the function.
            </param>
      <param name="state">An object representing data to be used by the function.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to be assigned to the new task.</param>
      <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the task's behavior.
            </param>
      <exception cref="T:System.ArgumentException">
            The <paramref name="function" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.Task,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.InternalTaskOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a new future object.
            </summary>
      <param name="parent">The parent task for this future.</param>
      <param name="valueSelector">A function that yields the future value.</param>
      <param name="scheduler">The task scheduler which will be used to execute the future.</param>
      <param name="cancellationToken">The CancellationToken for the task.</param>
      <param name="creationOptions">Options to control the future's behavior.</param>
      <param name="internalOptions">Internal options to control the future's behavior.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="creationOptions" /> argument specifies
            a SelfReplicating <see cref="T:System.Threading.Tasks.Task`1" />, which is illegal."/&gt;.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.Task,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.InternalTaskOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a new future object.
            </summary>
      <param name="parent">The parent task for this future.</param>
      <param name="state">An object containing data to be used by the action; may be null.</param>
      <param name="valueSelector">A function that yields the future value.</param>
      <param name="cancellationToken">The CancellationToken for the task.</param>
      <param name="scheduler">The task scheduler which will be used to execute the future.</param>
      <param name="creationOptions">Options to control the future's behavior.</param>
      <param name="internalOptions">Internal options to control the future's behavior.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="creationOptions" /> argument specifies
            a SelfReplicating <see cref="T:System.Threading.Tasks.Task`1" />, which is illegal."/&gt;.</exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.InvokeFuture(System.Object)">
      <summary>
            Evaluates the value selector of the Task which is passed in as an object and stores the result.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.
            </summary>
      <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task" /> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.
            </summary>
      <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task" /> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.
            </summary>
      <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task" /> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.
            </summary>
      <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task" /> will not be scheduled for execution until the current task has
            completed. If the continuation criteria specified through the <paramref name="continuationOptions" /> parameter are not met, the continuation task will be canceled
            instead of scheduled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.
            </summary>
      <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
      <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its
            execution.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task" /> will not be scheduled for execution until the current task has
            completed. If the criteria specified through the <paramref name="continuationOptions" /> parameter
            are not met, the continuation task will be canceled instead of scheduled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.
            </summary>
      <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
      <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1" /> will not be scheduled for execution until the current
            task has completed, whether it completes due to running to completion successfully, faulting due
            to an unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.
            </summary>
      <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
      <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1" /> will not be scheduled for execution until the current
            task has completed, whether it completes due to running to completion successfully, faulting due
            to an unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.
            </summary>
      <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
      <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.  When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
      <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1" /> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.
            </summary>
      <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
      <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
      <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
      <remarks>
        <para>
            The returned <see cref="T:System.Threading.Tasks.Task`1" /> will not be scheduled for execution until the current
            task has completed, whether it completes due to running to completion successfully, faulting due
            to an unhandled exception, or exiting out early due to being canceled.
            </para>
        <para>
            The <paramref name="continuationFunction" />, when executed, should return a <see cref="T:System.Threading.Tasks.Task`1" />. This task's completion state will be transferred to the task returned
            from the ContinueWith call.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes.
            </summary>
      <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
      <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes. When run, the delegate will be passed as
            an argument this completed task.
            </param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new task.</param>
      <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
      <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its
            execution.
            </param>
      <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
      <remarks>
        <para>
            The returned <see cref="T:System.Threading.Tasks.Task`1" /> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </para>
        <para>
            The <paramref name="continuationFunction" />, when executed, should return a <see cref="T:System.Threading.Tasks.Task`1" />.
            This task's completion state will be transferred to the task returned from the
            ContinueWith call.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler" /> argument is null.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task`1" /> has been disposed.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="P:System.Threading.Tasks.Task`1.Result">
      <summary>
            Gets the result value of this <see cref="T:System.Threading.Tasks.Task`1" />.
            </summary>
      <remarks>
            The get accessor for this property ensures that the asynchronous operation is complete before
            returning. Once the result of the computation is available, it is stored and will be returned
            immediately on later calls to <see cref="P:System.Threading.Tasks.Task`1.Result" />.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.Task`1.Factory">
      <summary>
            Provides access to factory methods for creating <see cref="T:System.Threading.Tasks.Task`1" /> instances.
            </summary>
      <remarks>
            The factory returned from <see cref="P:System.Threading.Tasks.Task`1.Factory" /> is a default instance
            of <see cref="T:System.Threading.Tasks.TaskFactory`1" />, as would result from using
            the default constructor on the factory type.
            </remarks>
    </member>
    <member name="T:System.Threading.Tasks.TaskFactory`1">
      <summary>
            Provides support for creating and scheduling
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task{TResult}</see> objects.
            </summary>
      <typeparam name="TResult">The type of the results that are available though 
            the <see cref="T:System.Threading.Tasks.Task{TResult}">Task{TResult}</see> objects that are associated with 
            the methods in this class.</typeparam>
      <remarks>
        <para>
            There are many common patterns for which tasks are relevant. The <see cref="T:System.Threading.Tasks.TaskFactory`1" />
            class encodes some of these patterns into methods that pick up default settings, which are
            configurable through its constructors.
            </para>
        <para>
            A default instance of <see cref="T:System.Threading.Tasks.TaskFactory`1" /> is available through the
            <see cref="P:System.Threading.Tasks.Task`1.Factory">Task{TResult}.Factory</see> property.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.#ctor">
      <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory`1" /> instance with the default configuration.
            </summary>
      <remarks>
            This constructor creates a <see cref="T:System.Threading.Tasks.TaskFactory`1" /> instance with a default configuration. The
            <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> property is initialized to <see cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to the current scheduler (see <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken)">
      <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory`1" /> instance with the default configuration.
            </summary>
      <param name="cancellationToken">The default <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken" /> that will be assigned 
            to tasks created by this <see cref="T:System.Threading.Tasks.TaskFactory" /> unless another CancellationToken is explicitly specified 
            while calling the factory methods.</param>
      <remarks>
            This constructor creates a <see cref="T:System.Threading.Tasks.TaskFactory`1" /> instance with a default configuration. The
            <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> property is initialized to <see cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to the current scheduler (see <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskScheduler)">
      <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory`1" /> instance with the specified configuration.
            </summary>
      <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler">
            TaskScheduler</see> to use to schedule any tasks created with this TaskFactory{TResult}. A null value
            indicates that the current TaskScheduler should be used.
            </param>
      <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> property is initialized to <see cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to <paramref name="scheduler" />, unless it's null, in which case the property is
            initialized to the current scheduler (see <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory`1" /> instance with the specified configuration.
            </summary>
      <param name="creationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions">
            TaskCreationOptions</see> to use when creating tasks with this TaskFactory{TResult}.
            </param>
      <param name="continuationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> to use when creating continuation tasks with this TaskFactory{TResult}.
            </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when the
            <paramref name="creationOptions" /> argument or the <paramref name="continuationOptions" />
            argument specifies an invalid value.
            </exception>
      <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> property is initialized to <paramref name="creationOptions" />,
            the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> property is initialized to <paramref name="continuationOptions" />, and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is initialized to the
            current scheduler (see <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory`1" /> instance with the specified configuration.
            </summary>
      <param name="cancellationToken">The default <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken" /> that will be assigned 
            to tasks created by this <see cref="T:System.Threading.Tasks.TaskFactory" /> unless another CancellationToken is explicitly specified 
            while calling the factory methods.</param>
      <param name="creationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions">
            TaskCreationOptions</see> to use when creating tasks with this TaskFactory{TResult}.
            </param>
      <param name="continuationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> to use when creating continuation tasks with this TaskFactory{TResult}.
            </param>
      <param name="scheduler">
            The default <see cref="T:System.Threading.Tasks.TaskScheduler">
            TaskScheduler</see> to use to schedule any Tasks created with this TaskFactory{TResult}. A null value
            indicates that TaskScheduler.Current should be used.
            </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when the
            <paramref name="creationOptions" /> argument or the <paramref name="continuationOptions" />
            argumentspecifies an invalid value.
            </exception>
      <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> property is initialized to <paramref name="creationOptions" />,
            the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> property is initialized to <paramref name="continuationOptions" />, and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is initialized to
            <paramref name="scheduler" />, unless it's null, in which case the property is initialized to the
            current scheduler (see <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0})">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken" /> that will be assigned to the new task.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken" /> that will be assigned to the new task.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see cref="T:System.Threading.Tasks.Task{TResult}">
            Task{TResult}</see>.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="scheduler" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="state">An object containing data to be used by the <paramref name="function" />
            delegate.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="state">An object containing data to be used by the <paramref name="function" />
            delegate.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken" /> that will be assigned to the new task.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="state">An object containing data to be used by the <paramref name="function" />
            delegate.</param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="state">An object containing data to be used by the <paramref name="function" />
            delegate.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken" /> that will be assigned to the new task.</param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see cref="T:System.Threading.Tasks.Task{TResult}">
            Task{TResult}</see>.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="scheduler" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0})">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
      <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod" />.</param>
      <param name="endMethod">The function delegate that processes the completed <paramref name="asyncResult" />.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
      <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod" />.</param>
      <param name="endMethod">The function delegate that processes the completed <paramref name="asyncResult" />.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
      <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod" />.</param>
      <param name="endMethod">The function delegate that processes the completed <paramref name="asyncResult" />.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the task that executes the end method.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func_{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg3">The third argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func_{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg3">The third argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in 
            the <paramref name="tasks" /> array have completed.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in 
            the <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the <paramref name="tasks" /> array have completed.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the <paramref name="tasks" /> array completes.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the <paramref name="tasks" /> array completes.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.TaskFactory`1.CancellationToken">
      <summary>
            Gets the default <see cref="T:System.Threading.CancellationToken">CancellationToken</see> of this
            TaskFactory.
            </summary>
      <remarks>
            This property returns the default <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken" /> that will be assigned to all 
            tasks created by this factory unless another CancellationToken value is explicitly specified 
            during the call to the factory methods.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.TaskFactory`1.Scheduler">
      <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> of this
            TaskFactory{TResult}.
            </summary>
      <remarks>
            This property returns the default scheduler for this factory.  It will be used to schedule all 
            tasks unless another scheduler is explicitly specified during calls to this factory's methods.  
            If null, <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see> 
            will be used.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.TaskFactory`1.CreationOptions">
      <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions
            </see> value of this TaskFactory{TResult}.
            </summary>
      <remarks>
            This property returns the default creation options for this factory.  They will be used to create all 
            tasks unless other options are explicitly specified during calls to this factory's methods.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.TaskFactory`1.ContinuationOptions">
      <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskContinuationOptions
            </see> value of this TaskFactory{TResult}.
            </summary>
      <remarks>
            This property returns the default continuation options for this factory.  They will be used to create 
            all continuation tasks unless other options are explicitly specified during calls to this factory's methods.
            </remarks>
    </member>
    <member name="T:System.Threading.Tasks.TaskStatus">
      <summary>
            Represents the current stage in the lifecycle of a <see cref="T:System.Threading.Tasks.Task" />.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskStatus.Created">
      <summary> 
            The task has been initialized but has not yet been scheduled.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskStatus.WaitingForActivation">
      <summary> 
            The task is waiting to be activated and scheduled internally by the .NET Framework infrastructure.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskStatus.WaitingToRun">
      <summary>
            The task has been scheduled for execution but has not yet begun executing.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskStatus.Running">
      <summary>
            The task is running but has not yet completed.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskStatus.WaitingForChildrenToComplete">
      <summary>
            The task has finished executing and is implicitly waiting for
            attached child tasks to complete.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskStatus.RanToCompletion">
      <summary>
            The task completed execution successfully.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskStatus.Canceled">
      <summary>
            The task acknowledged cancellation by throwing an OperationCanceledException with its own CancellationToken
            while the token was in signaled state, or the task's CancellationToken was already signaled before the
            task started executing.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskStatus.Faulted">
      <summary>
            The task completed due to an unhandled exception.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.ParallelForReplicaTask.SaveStateForNextReplica(System.Object)">
      <summary>
             In some cases a replica will want to quit prematurely (ie. before finishing a chunk of work it may have grabbed)
             yet they will need the next replica to pick things up from where they left. This API is used to save such state.
            
             Calling it is also the only way to record a premature exit.
             </summary>
      <param name="stateForNextReplica">
      </param>
    </member>
    <member name="T:System.Threading.Tasks.TaskCreationOptions">
      <summary>
            Specifies flags that control optional behavior for the creation and execution of tasks.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskCreationOptions.None">
      <summary>
            Specifies that the default behavior should be used.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskCreationOptions.PreferFairness">
      <summary>
            A hint to a <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> to schedule a
            task in as fair a manner as possible, meaning that tasks scheduled sooner will be more likely to
            be run sooner, and tasks scheduled later will be more likely to be run later.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskCreationOptions.LongRunning">
      <summary>
            Specifies that a task will be a long-running, course-grained operation. It provides a hint to the
            <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> that oversubscription may be
            warranted. 
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskCreationOptions.AttachedToParent">
      <summary>
            Specifies that a task is attached to a parent in the task hierarchy.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.InternalTaskOptions">
      <summary>
            Task creation flags which are only used internally.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.InternalTaskOptions.None">
      <summary> Specifies "No internal task options" </summary>
    </member>
    <member name="F:System.Threading.Tasks.InternalTaskOptions.InternalOptionsMask">
      <summary>Used to filter out internal vs. public task creation options.</summary>
    </member>
    <member name="F:System.Threading.Tasks.InternalTaskOptions.QueuedByRuntime">
      <summary>Specifies that the task will be queued by the runtime before handing it over to the user. 
            This flag will be used to skip the cancellationtoken registration step, which is only meant for unstarted tasks.</summary>
    </member>
    <member name="T:System.Threading.Tasks.TaskContinuationOptions">
      <summary>
            Specifies flags that control optional behavior for the creation and execution of continuation tasks.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskContinuationOptions.None">
      <summary>
            Default = "Continue on any, no task options, run asynchronously"
            Specifies that the default behavior should be used.  Continuations, by default, will
            be scheduled when the antecedent task completes, regardless of the task's final <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see>.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskContinuationOptions.PreferFairness">
      <summary>
            A hint to a <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> to schedule a
            task in as fair a manner as possible, meaning that tasks scheduled sooner will be more likely to
            be run sooner, and tasks scheduled later will be more likely to be run later.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskContinuationOptions.LongRunning">
      <summary>
            Specifies that a task will be a long-running, course-grained operation.  It provides
            a hint to the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> that
            oversubscription may be warranted.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent">
      <summary>
            Specifies that a task is attached to a parent in the task hierarchy.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskContinuationOptions.NotOnRanToCompletion">
      <summary>
            Specifies that the continuation task should not be scheduled if its antecedent ran to completion.
            This option is not valid for multi-task continuations.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted">
      <summary>
            Specifies that the continuation task should not be scheduled if its antecedent threw an unhandled
            exception. This option is not valid for multi-task continuations.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled">
      <summary>
            Specifies that the continuation task should not be scheduled if its antecedent was canceled. This
            option is not valid for multi-task continuations.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion">
      <summary>
            Specifies that the continuation task should be scheduled only if its antecedent ran to
            completion. This option is not valid for multi-task continuations.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted">
      <summary>
            Specifies that the continuation task should be scheduled only if its antecedent threw an
            unhandled exception. This option is not valid for multi-task continuations.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">
      <summary>
            Specifies that the continuation task should be scheduled only if its antecedent was canceled.
            This option is not valid for multi-task continuations.
            </summary>
    </member>
    <member name="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">
      <summary>
            Specifies that the continuation task should be executed synchronously. With this option
            specified, the continuation will be run on the same thread that causes the antecedent task to
            transition into its final state. If the antecedent is already complete when the continuation is
            created, the continuation will run on the thread creating the continuation.  Only very
            short-running continuations should be executed synchronously.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.StackGuard">
      <summary>
            Internal helper class to keep track of stack depth and decide whether we should inline or not.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.StackGuard.TryBeginInliningScope">
      <summary>
            This method needs to be called before attempting inline execution on the current thread. 
            If false is returned, it means we are too close to the end of the stack and should give up inlining.
            Each call to TryBeginInliningScope() that returns true must be matched with a 
            call to EndInliningScope() regardless of whether inlining actually took place.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.StackGuard.EndInliningScope">
      <summary>
            This needs to be called once for each previous successful TryBeginInliningScope() call after
            inlining related logic runs.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.TaskCanceledException">
      <summary>
            Represents an exception used to communicate task cancellation.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException" /> class.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException" />
            class with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException" />
            class with a specified error message and a reference to the inner exception that is the cause of
            this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception.</param>
    </member>
    <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Threading.Tasks.Task)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException" /> class
            with a reference to the <see cref="T:System.Threading.Tasks.Task" /> that has been canceled.
            </summary>
      <param name="task">A task that has been canceled.</param>
    </member>
    <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException" />
            class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination. </param>
    </member>
    <member name="P:System.Threading.Tasks.TaskCanceledException.Task">
      <summary>
            Gets the task associated with this exception.
            </summary>
      <remarks>
            It is permissible for no Task to be associated with a 
            <see cref="T:System.Threading.Tasks.TaskCanceledException" />, in which case
            this property will return null.
            </remarks>
    </member>
    <member name="T:System.Threading.Tasks.TaskExceptionHolder">
      <summary>
            An exception holder manages a list of exceptions for one particular task.
            It offers the ability to aggregate, but more importantly, also offers intrinsic
            support for propagating unhandled exceptions that are never observed. It does
            this by aggregating and throwing if the holder is ever GC'd without the holder's
            contents ever having been requested (e.g. by a Task.Wait, Task.get_Exception, etc).
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskExceptionHolder.#ctor(System.Threading.Tasks.Task)">
      <summary>
            Creates a new holder; it will be registered for finalization.
            </summary>
      <param name="task">The task this holder belongs to.</param>
    </member>
    <member name="M:System.Threading.Tasks.TaskExceptionHolder.Finalize">
      <summary>
            A finalizer that repropagates unhandled exceptions.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskExceptionHolder.Add(System.Object)">
      <summary>
            Add an exception to the internal list.  This will ensure the holder is
            in the proper state (handled/unhandled) depending on the list's contents.
            </summary>
      <param name="exceptionObject">An exception object (either an Exception or an 
            IEnumerable{Exception}) to add to the list.</param>
    </member>
    <member name="M:System.Threading.Tasks.TaskExceptionHolder.MarkAsUnhandled">
      <summary>
            A private helper method that ensures the holder is considered
            unhandled, i.e. it is registered for finalization.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskExceptionHolder.MarkAsHandled(System.Boolean)">
      <summary>
            A private helper method that ensures the holder is considered
            handled, i.e. it is not registered for finalization.
            </summary>
      <param name="calledFromFinalizer">Whether this is called from the finalizer thread.</param>
    </member>
    <member name="M:System.Threading.Tasks.TaskExceptionHolder.CreateExceptionObject(System.Boolean,System.Exception)">
      <summary>
            Allocates a new aggregate exception and adds the contents of the list to
            it. By calling this method, the holder assumes exceptions to have been
            "observed", such that the finalization check will be subsequently skipped.
            </summary>
      <param name="calledFromFinalizer">Whether this is being called from a finalizer.</param>
      <param name="includeThisException">An extra exception to be included (optionally).</param>
      <returns>The aggregate exception to throw.</returns>
    </member>
    <member name="T:System.Threading.Tasks.TaskFactory">
      <summary>
            Provides support for creating and scheduling
            <see cref="T:System.Threading.Tasks.Task">Tasks</see>.
            </summary>
      <remarks>
        <para>
            There are many common patterns for which tasks are relevant. The <see cref="T:System.Threading.Tasks.TaskFactory" />
            class encodes some of these patterns into methods that pick up default settings, which are
            configurable through its constructors.
            </para>
        <para>
            A default instance of <see cref="T:System.Threading.Tasks.TaskFactory" /> is available through the
            <see cref="P:System.Threading.Tasks.Task.Factory">Task.Factory</see> property.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.#ctor">
      <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory" /> instance with the default configuration.
            </summary>
      <remarks>
            This constructor creates a <see cref="T:System.Threading.Tasks.TaskFactory" /> instance with a default configuration. The
            <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> property is initialized to <see cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to the current scheduler (see <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)">
      <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory" /> instance with the specified configuration.
            </summary>
      <param name="cancellationToken">The default <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned 
            to tasks created by this <see cref="T:System.Threading.Tasks.TaskFactory" /> unless another CancellationToken is explicitly specified 
            while calling the factory methods.</param>
      <remarks>
            This constructor creates a <see cref="T:System.Threading.Tasks.TaskFactory" /> instance with a default configuration. The
            <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> property is initialized to <see cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to the current scheduler (see <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)">
      <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory" /> instance with the specified configuration.
            </summary>
      <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler">
            TaskScheduler</see> to use to schedule any tasks created with this TaskFactory. A null value
            indicates that the current TaskScheduler should be used.
            </param>
      <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> property is initialized to <see cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to <paramref name="scheduler" />, unless it's null, in which case the property is
            initialized to the current scheduler (see <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory" /> instance with the specified configuration.
            </summary>
      <param name="creationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions">
            TaskCreationOptions</see> to use when creating tasks with this TaskFactory.
            </param>
      <param name="continuationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> to use when creating continuation tasks with this TaskFactory.
            </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when the
            <paramref name="creationOptions" /> argument or the <paramref name="continuationOptions" />
            argument specifies an invalid value.
            </exception>
      <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> property is initialized to <paramref name="creationOptions" />,
            the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> property is initialized to <paramref name="continuationOptions" />, and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is initialized to the
            current scheduler (see <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory" /> instance with the specified configuration.
            </summary>
      <param name="cancellationToken">The default <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned 
            to tasks created by this <see cref="T:System.Threading.Tasks.TaskFactory" /> unless another CancellationToken is explicitly specified 
            while calling the factory methods.</param>
      <param name="creationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions">
            TaskCreationOptions</see> to use when creating tasks with this TaskFactory.
            </param>
      <param name="continuationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> to use when creating continuation tasks with this TaskFactory.
            </param>
      <param name="scheduler">
            The default <see cref="T:System.Threading.Tasks.TaskScheduler">
            TaskScheduler</see> to use to schedule any Tasks created with this TaskFactory. A null value
            indicates that TaskScheduler.Current should be used.
            </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when the
            <paramref name="creationOptions" /> argument or the <paramref name="continuationOptions" />
            argumentspecifies an invalid value.
            </exception>
      <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> property is initialized to <paramref name="creationOptions" />,
            the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> property is initialized to <paramref name="continuationOptions" />, and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is initialized to
            <paramref name="scheduler" />, unless it's null, in which case the property is initialized to the
            current scheduler (see <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
      <param name="action">The action delegate to execute asynchronously.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="action" /> 
            argument is null.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors 
            and then calling 
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.  However,
            unless creation and scheduling must be separated, StartNew is the recommended
            approach for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
      <param name="action">The action delegate to execute asynchronously.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new task.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="action" /> 
            argument is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors 
            and then calling 
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.  However,
            unless creation and scheduling must be separated, StartNew is the recommended
            approach for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
      <param name="action">The action delegate to execute asynchronously.</param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task">Task.</see></param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="action" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
      <param name="action">The action delegate to execute asynchronously.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new <see cref="T:System.Threading.Tasks.Task" /></param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task">Task.</see></param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="action" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="scheduler" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
      <param name="action">The action delegate to execute asynchronously.</param>
      <param name="state">An object containing data to be used by the <paramref name="action" />
            delegate.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="action" />
            argument is null.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
      <param name="action">The action delegate to execute asynchronously.</param>
      <param name="state">An object containing data to be used by the <paramref name="action" />
            delegate.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new <see cref="T:System.Threading.Tasks.Task" /></param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="action" />
            argument is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
      <param name="action">The action delegate to execute asynchronously.</param>
      <param name="state">An object containing data to be used by the <paramref name="action" />
            delegate.</param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task">Task.</see></param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="action" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
      <param name="action">The action delegate to execute asynchronously.</param>
      <param name="state">An object containing data to be used by the <paramref name="action" />
            delegate.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new task.</param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task">Task.</see></param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="action" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="scheduler" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new <see cref="T:System.Threading.Tasks.Task" /></param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new task.</param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see cref="T:System.Threading.Tasks.Task{TResult}">
            Task{TResult}</see>.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="scheduler" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="state">An object containing data to be used by the <paramref name="function" />
            delegate.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="state">An object containing data to be used by the <paramref name="function" />
            delegate.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new <see cref="T:System.Threading.Tasks.Task" /></param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="state">An object containing data to be used by the <paramref name="function" />
            delegate.</param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}" />.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="state">An object containing data to be used by the <paramref name="function" />
            delegate.</param>
      <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new task.</param>
      <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see cref="T:System.Threading.Tasks.Task{TResult}">
            Task{TResult}</see>.</param>
      <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="function" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="scheduler" />
            argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1" /> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that executes an end method action
            when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
      <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod" />.</param>
      <param name="endMethod">The action delegate that processes the completed <paramref name="asyncResult" />.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the asynchronous
            operation.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that executes an end method action
            when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
      <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod" />.</param>
      <param name="endMethod">The action delegate that processes the completed <paramref name="asyncResult" />.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the asynchronous
            operation.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that executes an end method action
            when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
      <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod" />.</param>
      <param name="endMethod">The action delegate that processes the completed <paramref name="asyncResult" />.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the task that executes the end method.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the asynchronous
            operation.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" />
            delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" />
            delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func_{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg3">The third argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func_{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg3">The third argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod" />.</param>
      <param name="endMethod">The function delegate that processes the completed <paramref name="asyncResult" />.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod" />.</param>
      <param name="endMethod">The function delegate that processes the completed <paramref name="asyncResult" />.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod" />.</param>
      <param name="endMethod">The function delegate that processes the completed <paramref name="asyncResult" />.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the task that executes the end method.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func_{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg3">The third argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func_{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
      <typeparam name="TArg1">The type of the first argument passed to the <paramref name="beginMethod" /> delegate.</typeparam>
      <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod" />
            delegate.</typeparam>
      <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
      <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
      <param name="endMethod">The delegate that ends the asynchronous operation.</param>
      <param name="arg1">The first argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg2">The second argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="arg3">The third argument passed to the <paramref name="beginMethod" />
            delegate.</param>
      <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="state">An object containing data to be used by the <paramref name="beginMethod" />
            delegate.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions" /> argument specifies an invalid TaskCreationOptions
            value.</exception>
      <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
      <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod" />.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.CheckFromAsyncOptions(System.Threading.Tasks.TaskCreationOptions,System.Boolean)">
      <summary>
            Check validity of options passed to FromAsync method
            </summary>
      <param name="creationOptions">The options to be validated.</param>
      <param name="hasBeginMethod">determines type of FromAsync method that called this method</param>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationAction">The action delegate to execute when all tasks in 
            the <paramref name="tasks" /> array have completed.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationAction">The action delegate to execute when all tasks in 
            the <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationAction">The action delegate to execute when all tasks in the <paramref name="tasks" /> array have completed.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationAction">The action delegate to execute when all tasks in the <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationAction">The action delegate to execute when all tasks in 
            the <paramref name="tasks" /> array have completed.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationAction">The action delegate to execute when all tasks in 
            the <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationAction">The action delegate to execute when all tasks in the <paramref name="tasks" /> array have completed.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationAction">The action delegate to execute when all tasks in the <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue.</param>
      <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks" /> array have completed.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationAction">The action delegate to execute when one task in the <paramref name="tasks" /> array completes.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationAction">The action delegate to execute when one task in the <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationAction">The action delegate to execute when one task in the <paramref name="tasks" /> array completes.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationAction">The action delegate to execute when one task in the <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TResult">The type of the result that is returned by the <paramref name="continuationFunction" />
            delegate and associated with the created <see cref="T:System.Threading.Tasks.Task{TResult}" />.</typeparam>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationAction">The action delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationAction">The action delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationAction">The action delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
      <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
      <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks" />.</typeparam>
      <param name="tasks">The array of tasks from which to continue when one task completes.</param>
      <param name="continuationAction">The action delegate to execute when one task in the
            <paramref name="tasks" /> array completes.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
      <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
      <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>The new continuation <see cref="T:System.Threading.Tasks.Task" />.</returns>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks" /> array is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction" /> argument is null.</exception>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array contains a null value.</exception>
      <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks" /> array is empty.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions" /> argument specifies an invalid TaskContinuationOptions
            value.</exception>
      <exception cref="T:System.ObjectDisposedException">The exception that is thrown when one 
            of the elements in the <paramref name="tasks" /> array has been disposed.</exception>
      <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
      <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.TaskFactory.CancellationToken">
      <summary>
            Gets the default <see cref="T:System.Threading.CancellationToken">CancellationToken</see> of this
            TaskFactory.
            </summary>
      <remarks>
            This property returns the default <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to all 
            tasks created by this factory unless another CancellationToken value is explicitly specified 
            during the call to the factory methods.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.TaskFactory.Scheduler">
      <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> of this
            TaskFactory.
            </summary>
      <remarks>
            This property returns the default scheduler for this factory.  It will be used to schedule all 
            tasks unless another scheduler is explicitly specified during calls to this factory's methods.  
            If null, <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see> 
            will be used.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.TaskFactory.CreationOptions">
      <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions
            </see> value of this TaskFactory.
            </summary>
      <remarks>
            This property returns the default creation options for this factory.  They will be used to create all 
            tasks unless other options are explicitly specified during calls to this factory's methods.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.TaskFactory.ContinuationOptions">
      <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskContinuationOptions
            </see> value of this TaskFactory.
            </summary>
      <remarks>
            This property returns the default continuation options for this factory.  They will be used to create 
            all continuation tasks unless other options are explicitly specified during calls to this factory's methods.
            </remarks>
    </member>
    <member name="T:System.Threading.Tasks.TaskCompletionSource`1">
      <summary>
            Represents the producer side of a <see cref="T:System.Threading.Tasks.Task{TResult}" /> unbound to a
            delegate, providing access to the consumer side through the <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> property.
            </summary>
      <remarks>
        <para>
            It is often the case that a <see cref="T:System.Threading.Tasks.Task{TResult}" /> is desired to
            represent another asynchronous operation.
            <see cref="T:System.Threading.Tasks.TaskCompletionSource`1">TaskCompletionSource</see> is provided for this purpose. It enables
            the creation of a task that can be handed out to consumers, and those consumers can use the members
            of the task as they would any other. However, unlike most tasks, the state of a task created by a
            TaskCompletionSource is controlled explicitly by the methods on TaskCompletionSource. This enables the
            completion of the external asynchronous operation to be propagated to the underlying Task. The
            separation also ensures that consumers are not able to transition the state without access to the
            corresponding TaskCompletionSource.
            </para>
        <para>
            All members of <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> are thread-safe
            and may be used from multiple threads concurrently.
            </para>
      </remarks>
      <typeparam name="TResult">The type of the result value assocatied with this <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</typeparam>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />
            with the specified options.
            </summary>
      <remarks>
            The <see cref="T:System.Threading.Tasks.Task{TResult}" /> created
            by this instance and accessible through its <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> property
            will be instantiated using the specified <paramref name="creationOptions" />.
            </remarks>
      <param name="creationOptions">The options to use when creating the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions" /> represent options invalid for use
            with a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />
            with the specified state.
            </summary>
      <param name="state">The state to use as the underlying 
            <see cref="T:System.Threading.Tasks.Task{TResult}" />'s AsyncState.</param>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object,System.Threading.Tasks.TaskCreationOptions)">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> with
            the specified state and options.
            </summary>
      <param name="creationOptions">The options to use when creating the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <param name="state">The state to use as the underlying 
            <see cref="T:System.Threading.Tasks.Task{TResult}" />'s AsyncState.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions" /> represent options invalid for use
            with a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Exception)">
      <summary>
            Attempts to transition the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>
            state.
            </summary>
      <param name="exception">The exception to bind to this <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>True if the operation was successful; otherwise, false.</returns>
      <remarks>This operation will return false if the 
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
      <exception cref="T:System.ArgumentNullException">The <paramref name="exception" /> argument is null.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> was disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Collections.Generic.IEnumerable{System.Exception})">
      <summary>
            Attempts to transition the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>
            state.
            </summary>
      <param name="exceptions">The collection of exceptions to bind to this <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>True if the operation was successful; otherwise, false.</returns>
      <remarks>This operation will return false if the 
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
      <exception cref="T:System.ArgumentNullException">The <paramref name="exceptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">There are one or more null elements in <paramref name="exceptions" />.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="exceptions" /> collection is empty.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> was disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Exception)">
      <summary>
            Transitions the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>
            state.
            </summary>
      <param name="exception">The exception to bind to this <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="exception" /> argument is null.</exception>
      <exception cref="T:System.InvalidOperationException">
            The underlying <see cref="T:System.Threading.Tasks.Task{TResult}" /> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> was disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Collections.Generic.IEnumerable{System.Exception})">
      <summary>
            Transitions the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>
            state.
            </summary>
      <param name="exceptions">The collection of exceptions to bind to this <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="exceptions" /> argument is null.</exception>
      <exception cref="T:System.ArgumentException">There are one or more null elements in <paramref name="exceptions" />.</exception>
      <exception cref="T:System.InvalidOperationException">
            The underlying <see cref="T:System.Threading.Tasks.Task{TResult}" /> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> was disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetResult(`0)">
      <summary>
            Attempts to transition the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>
            state.
            </summary>
      <param name="result">The result value to bind to this <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <returns>True if the operation was successful; otherwise, false.</returns>
      <remarks>This operation will return false if the 
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
      <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> was disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetResult(`0)">
      <summary>
            Transitions the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>
            state.
            </summary>
      <param name="result">The result value to bind to this <see cref="T:System.Threading.Tasks.Task{TResult}" />.</param>
      <exception cref="T:System.InvalidOperationException">
            The underlying <see cref="T:System.Threading.Tasks.Task{TResult}" /> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> was disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetCanceled">
      <summary>
            Transitions the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>
            state.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The underlying <see cref="T:System.Threading.Tasks.Task{TResult}" /> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> was disposed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled">
      <summary>
            Attempts to transition the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>
            state.
            </summary>
      <returns>True if the operation was successful; otherwise, false.</returns>
      <remarks>This operation will return false if the 
            <see cref="T:System.Threading.Tasks.Task{TResult}" /> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
      <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> was disposed.</exception>
    </member>
    <member name="P:System.Threading.Tasks.TaskCompletionSource`1.Task">
      <summary>
            Gets the <see cref="T:System.Threading.Tasks.Task{TResult}" /> created
            by this <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.
            </summary>
      <remarks>
            This property enables a consumer access to the <see cref="T:System.Threading.Tasks.Task{TResult}" /> that is controlled by this instance.
            The <see cref="M:System.Threading.Tasks.TaskCompletionSource`1.SetResult(`0)" />, <see cref="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Exception)" />,
            <see cref="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Collections.Generic.IEnumerable{System.Exception})" />, and <see cref="M:System.Threading.Tasks.TaskCompletionSource`1.SetCanceled" />
            methods (and their "Try" variants) on this instance all result in the relevant state
            transitions on this underlying Task.
            </remarks>
    </member>
    <member name="T:System.Threading.Tasks.TaskScheduler">
      <summary>
            Represents an abstract scheduler for tasks.
            </summary>
      <remarks>
        <para>
          <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> acts as the extension point for all 
            pluggable scheduling logic.  This includes mechanisms such as how to schedule a task for execution, and
            how scheduled tasks should be exposed to debuggers.
            </para>
        <para>
            All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe
            and may be used from multiple threads concurrently.
            </para>
      </remarks>
    </member>
    <member name="T:System.Threading.Tasks.TaskScheduler.SystemThreadingTasks_TaskSchedulerDebugView">
      <summary>
            Nested class that provides debugger view for TaskScheduler
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
      <summary>
            Queues a <see cref="T:System.Threading.Tasks.Task">Task</see> to the scheduler.
            </summary>
      <remarks>
        <para>
            A class derived from <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>  
            implements this method to accept tasks being scheduled on the scheduler.
            A typical implementation would store the task in an internal data structure, which would
            be serviced by threads that would execute those tasks at some time in the future.
            </para>
        <para>
            This method is only meant to be called by the .NET Framework and
            should not be called directly by the derived class. This is necessary 
            for maintaining the consistency of the system.
            </para>
      </remarks>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task">Task</see> to be queued.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="task" /> argument is null.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <summary>
            Determines whether the provided <see cref="T:System.Threading.Tasks.Task">Task</see>
            can be executed synchronously in this call, and if it can, executes it.
            </summary>
      <remarks>
        <para>
            A class derived from <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> implements this function to
            support inline execution of a task on a thread that initiates a wait on that task object. Inline
            execution is optional, and the request may be rejected by returning false. However, better
            scalability typically results the more tasks that can be inlined, and in fact a scheduler that
            inlines too little may be prone to deadlocks. A proper implementation should ensure that a
            request executing under the policies guaranteed by the scheduler can successfully inline. For
            example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that
            thread should succeed.
            </para>
        <para>
            If a scheduler decides to perform the inline execution, it should do so by calling to the base
            TaskScheduler's
            <see cref="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">TryExecuteTask</see> method with the provided task object, propagating
            the return value. It may also be appropriate for the scheduler to remove an inlined task from its
            internal data structures if it decides to honor the inlining request. Note, however, that under
            some circumstances a scheduler may be asked to inline a task that was not previously provided to
            it with the <see cref="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" /> method.
            </para>
        <para>
            The derived scheduler is responsible for making sure that the calling thread is suitable for
            executing the given task as far as its own scheduling and execution policies are concerned.
            </para>
      </remarks>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task">Task</see> to be
            executed.</param>
      <param name="taskWasPreviouslyQueued">A Boolean denoting whether or not task has previously been
            queued. If this parameter is True, then the task may have been previously queued (scheduled); if
            False, then the task is known not to have been queued, and this call is being made in order to
            execute the task inline without queueing it.</param>
      <returns>A Boolean value indicating whether the task was executed inline.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="task" /> argument is
            null.</exception>
      <exception cref="T:System.InvalidOperationException">The <paramref name="task" /> was already
            executed.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
      <summary>
            Generates an enumerable of <see cref="T:System.Threading.Tasks.Task">Task</see> instances
            currently queued to the scheduler waiting to be executed.
            </summary>
      <remarks>
        <para>
            A class derived from <see cref="T:System.Threading.Tasks.TaskScheduler" /> implements this method in order to support
            integration with debuggers. This method will only be invoked by the .NET Framework when the
            debugger requests access to the data. The enumerable returned will be traversed by debugging
            utilities to access the tasks currently queued to this scheduler, enabling the debugger to
            provide a representation of this information in the user interface.
            </para>
        <para>
            It is important to note that, when this method is called, all other threads in the process will
            be frozen. Therefore, it's important to avoid synchronization with other threads that may lead to
            blocking. If synchronization is necessary, the method should prefer to throw a <see cref="T:System.NotSupportedException" />
            than to block, which could cause a debugger to experience delays. Additionally, this method and
            the enumerable returned must not modify any globally visible state.
            </para>
        <para>
            The returned enumerable should never be null. If there are currently no queued tasks, an empty
            enumerable should be returned instead.
            </para>
        <para>
            For developers implementing a custom debugger, this method shouldn't be called directly, but
            rather this functionality should be accessed through the internal wrapper method
            GetScheduledTasksForDebugger:
            <c>internal Task[] GetScheduledTasksForDebugger()</c>. This method returns an array of tasks,
            rather than an enumerable. In order to retrieve a list of active schedulers, a debugger may use
            another internal method: <c>internal static TaskScheduler[] GetTaskSchedulersForDebugger()</c>.
            This static method returns an array of all active TaskScheduler instances.
            GetScheduledTasksForDebugger then may be used on each of these scheduler instances to retrieve
            the list of scheduled tasks for each.
            </para>
      </remarks>
      <returns>An enumerable that allows traversal of tasks currently queued to this scheduler.
            </returns>
      <exception cref="T:System.NotSupportedException">
            This scheduler is unable to generate a list of queued tasks at this time.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.GetThreadStatics">
      <summary>
            Retrieves some thread static state that can be cached and passed to multiple
            TryRunInline calls, avoiding superflous TLS fetches.
            </summary>
      <returns>A bag of TLS state (or null if none exists).</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.TryRunInline(System.Threading.Tasks.Task,System.Boolean,System.Object)">
      <summary>
            Attempts to execute the target task synchronously.
            </summary>
      <param name="task">The task to run.</param>
      <param name="taskWasPreviouslyQueued">True if the task may have been previously queued,
            false if the task was absolutely not previously queued.</param>
      <param name="threadStatics">The state retrieved from GetThreadStatics</param>
      <returns>True if it ran, false otherwise.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
      <summary>
            Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task">Task</see> that was previously queued to
            this scheduler.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task">Task</see> to be dequeued.</param>
      <returns>A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="task" /> argument is null.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.NotifyWorkItemProgress">
      <summary>
            Notifies the scheduler that a work item has made progress.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.#ctor">
      <summary>
            Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.Finalize">
      <summary>
            Frees all resources associated with this scheduler.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
      <summary>
            Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" />
            associated with the current <see cref="T:System.Threading.SynchronizationContext" />.
            </summary>
      <remarks>
            All <see cref="T:System.Threading.Tasks.Task">Task</see> instances queued to 
            the returned scheduler will be executed through a call to the
            <see cref="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">Post</see> method
            on that context.
            </remarks>
      <returns>
            A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with 
            the current <see cref="T:System.Threading.SynchronizationContext">SynchronizationContext</see>, as
            determined by <see cref="P:System.Threading.SynchronizationContext.Current">SynchronizationContext.Current</see>.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The current SynchronizationContext may not be used as a TaskScheduler.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
      <summary>
            Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task">Task</see>
            on this scheduler.
            </summary>
      <remarks>
        <para>
            Scheduler implementations are provided with <see cref="T:System.Threading.Tasks.Task">Task</see>
            instances to be executed through either the <see cref="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" /> method or the
            <see cref="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" /> method. When the scheduler deems it appropriate to run the
            provided task, <see cref="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" /> should be used to do so. TryExecuteTask handles all
            aspects of executing a task, including action invocation, exception handling, state management,
            and lifecycle control.
            </para>
        <para>
          <see cref="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" /> must only be used for tasks provided to this scheduler by the .NET
            Framework infrastructure. It should not be used to execute arbitrary tasks obtained through
            custom mechanisms.
            </para>
      </remarks>
      <param name="task">
            A <see cref="T:System.Threading.Tasks.Task">Task</see> object to be executed.</param>
      <exception cref="T:System.InvalidOperationException">
            The <paramref name="task" /> is not associated with this scheduler.
            </exception>
      <returns>A Boolean that is true if <paramref name="task" /> was successfully executed, false if it
            was not. A common reason for execution failure is that the task had previously been executed or
            is in the process of being executed by another thread.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasksForDebugger">
      <summary>
            Provides an array of all queued <see cref="T:System.Threading.Tasks.Task">Task</see> instances
            for the debugger.
            </summary>
      <remarks>
            The returned array is populated through a call to <see cref="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />.
            Note that this function is only meant to be invoked by a debugger remotely. 
            It should not be called by any other codepaths.
            </remarks>
      <returns>An array of <see cref="T:System.Threading.Tasks.Task">Task</see> instances.</returns>
      <exception cref="T:System.NotSupportedException">
            This scheduler is unable to generate a list of queued tasks at this time.
            </exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.GetTaskSchedulersForDebugger">
      <summary>
            Provides an array of all active <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> 
            instances for the debugger.
            </summary>
      <remarks>
            This function is only meant to be invoked by a debugger remotely. 
            It should not be called by any other codepaths.
            </remarks>
      <returns>An array of <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> instances.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.RegisterTaskScheduler(System.Threading.Tasks.TaskScheduler)">
      <summary>
            Registers a new TaskScheduler instance in the global collection of schedulers.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskScheduler.UnregisterTaskScheduler(System.Threading.Tasks.TaskScheduler)">
      <summary>
            Removes a TaskScheduler instance from the global collection of schedulers.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
      <summary>
            Indicates the maximum concurrency level this 
            <see cref="T:System.Threading.Tasks.TaskScheduler" />  is able to support.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.TaskScheduler.RequiresAtomicStartTransition">
      <summary>
            Indicates whether this is a custom scheduler, in which case the safe code paths will be taken upon task entry
            using a CAS to transition from queued state to executing.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.TaskScheduler.Default">
      <summary>
            Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> instance.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.TaskScheduler.Current">
      <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            associated with the currently executing task.
            </summary>
      <remarks>
            When not called from within a task, <see cref="P:System.Threading.Tasks.TaskScheduler.Current" /> will return the <see cref="P:System.Threading.Tasks.TaskScheduler.Default" /> scheduler.
            </remarks>
    </member>
    <member name="P:System.Threading.Tasks.TaskScheduler.Id">
      <summary>
            Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.
            </summary>
    </member>
    <member name="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
      <summary>
            Occurs when a faulted <see cref="T:System.Threading.Tasks.Task" />'s unobserved exception is about to trigger exception escalation
            policy, which, by default, would terminate the process.
            </summary>
      <remarks>
            This AppDomain-wide event provides a mechanism to prevent exception
            escalation policy (which, by default, terminates the process) from triggering. 
            Each handler is passed a <see cref="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" />
            instance, which may be used to examine the exception and to mark it as observed.
            </remarks>
    </member>
    <member name="T:System.Threading.Tasks.SynchronizationContextTaskScheduler">
      <summary>
            A TaskScheduler implementation that executes all tasks queued to it through a call to 
            <see cref="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)" /> on the <see cref="T:System.Threading.SynchronizationContext" /> 
            that its associated with. The default constructor for this class binds to the current <see cref="T:System.Threading.SynchronizationContext" /></summary>
    </member>
    <member name="M:System.Threading.Tasks.SynchronizationContextTaskScheduler.#ctor">
      <summary>
            Constructs a SynchronizationContextTaskScheduler associated with <see cref="T:System.Threading.SynchronizationContext.Current" /></summary>
      <exception cref="T:System.InvalidOperationException">This constructor expects <see cref="T:System.Threading.SynchronizationContext.Current" /> to be set.</exception>
    </member>
    <member name="M:System.Threading.Tasks.SynchronizationContextTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
      <summary>
            Implemetation of <see cref="T:System.Threading.Tasks.TaskScheduler.QueueTask" /> for this scheduler class.
            
            Simply posts the tasks to be executed on the associated <see cref="T:System.Threading.SynchronizationContext" />.
            </summary>
      <param name="task">
      </param>
    </member>
    <member name="M:System.Threading.Tasks.SynchronizationContextTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <summary>
            Implementation of <see cref="T:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline" />  for this scheduler class.
            
            The task will be executed inline only if the call happens within 
            the associated <see cref="T:System.Threading.SynchronizationContext" />.
            </summary>
      <param name="task">
      </param>
      <param name="taskWasPreviouslyQueued">
      </param>
    </member>
    <member name="P:System.Threading.Tasks.SynchronizationContextTaskScheduler.MaximumConcurrencyLevel">
      <summary>
            Implementes the <see cref="T:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" /> property for
            this scheduler class.
            
            By default it returns 1, because a <see cref="T:System.Threading.SynchronizationContext" /> based
            scheduler only supports execution on a single thread.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs">
      <summary>
            Provides data for the event that is raised when a faulted <see cref="T:System.Threading.Tasks.Task" />'s
            exception goes unobserved.
            </summary>
      <remarks>
            The Exception property is used to examine the exception without marking it
            as observed, whereas the <see cref="M:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.SetObserved" /> method is used to mark the exception
            as observed.  Marking the exception as observed prevents it from triggering exception escalation policy
            which, by default, terminates the process.
            </remarks>
    </member>
    <member name="M:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.#ctor(System.AggregateException)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs" /> class
            with the unobserved exception.
            </summary>
      <param name="exception">The Exception that has gone unobserved.</param>
    </member>
    <member name="M:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.SetObserved">
      <summary>
            Marks the <see cref="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Exception" /> as "observed," thus preventing it
            from triggering exception escalation policy which, by default, terminates the process.
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Observed">
      <summary>
            Gets whether this exception has been marked as "observed."
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Exception">
      <summary>
            The Exception that went unobserved.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.ThreadPoolTaskScheduler">
      <summary>
            An implementation of TaskScheduler that uses the ThreadPool scheduler
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.ThreadPoolTaskScheduler.#ctor">
      <summary>
            Constructs a new ThreadPool task scheduler object
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.ThreadPoolTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
      <summary>
            Schedules a task to the ThreadPool.
            </summary>
      <param name="task">The task to schedule.</param>
    </member>
    <member name="M:System.Threading.Tasks.ThreadPoolTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <summary>
            This internal function will do this:
              (1) If the task had previously been queued, attempt to pop it and return false if that fails.
              (2) Propagate the return value from Task.ExecuteEntry() back to the caller.
            
            IMPORTANT NOTE: TryExecuteTaskInline will NOT throw task exceptions itself. Any wait code path using this function needs
            to account for exceptions that need to be propagated, and throw themselves accordingly.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.ThreadPoolTaskScheduler.NotifyWorkItemProgress">
      <summary>
            Notifies the scheduler that work is progressing (no-op).
            </summary>
    </member>
    <member name="P:System.Threading.Tasks.ThreadPoolTaskScheduler.RequiresAtomicStartTransition">
      <summary>
            This is the only scheduler that returns false for this property, indicating that the task entry codepath is unsafe (CAS free)
            since we know that the underlying scheduler already takes care of atomic transitions from queued to non-queued.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.TaskSchedulerException">
      <summary>
            Represents an exception used to communicate an invalid operation by a
            <see cref="T:System.Threading.Tasks.TaskScheduler" />.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskSchedulerException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskSchedulerException" /> class.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskSchedulerException" />
            class with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskSchedulerException" />
            class using the default error message and a reference to the inner exception that is the cause of
            this exception.
            </summary>
      <param name="innerException">The exception that is the cause of the current exception.</param>
    </member>
    <member name="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskSchedulerException" />
            class with a specified error message and a reference to the inner exception that is the cause of
            this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception.</param>
    </member>
    <member name="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskSchedulerException" />
            class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds
            the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that
            contains contextual information about the source or destination. </param>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary>
            The exception that is thrown when the post-phase action of a <see cref="T:System.Threading.Barrier" /> fails.
            </summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.BarrierPostPhaseException" /> class.
            </summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.BarrierPostPhaseException" /> class with the specified inner exception.
            </summary>
      <param name="innerException">The exception that is the cause of the current exception.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.BarrierPostPhaseException" /> class with a specified error message.
            </summary>
      <param name="message">A string that describes the exception.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.BarrierPostPhaseException" /> class with a specified error message and inner exception.
            </summary>
      <param name="message">A string that describes the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.BarrierPostPhaseException" /> class with serialized data.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">An object that describes the source or destination of the serialized data.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary>
            Enables multiple tasks to cooperatively work on an algorithm in parallel through multiple phases.
            </summary>
      <remarks>
        <para>
            A group of tasks cooperate by moving through a series of phases, where each in the group signals it
            has arrived at the <see cref="T:System.Threading.Barrier" /> in a given phase and implicitly waits for all others to
            arrive. The same <see cref="T:System.Threading.Barrier" /> can be used for multiple phases.
            </para>
        <para>
            All public and protected members of <see cref="T:System.Threading.Barrier" /> are thread-safe and may be used
            concurrently from multiple threads, with the exception of Dispose, which
            must only be used when all other operations on the <see cref="T:System.Threading.Barrier" /> have
            completed.
            </para>
      </remarks>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Barrier" /> class.
            </summary>
      <param name="participantCount">The number of participating threads.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> is less than 0
            or greater than <see cref="T:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Barrier" /> class.
            </summary>
      <param name="participantCount">The number of participating threads.</param>
      <param name="postPhaseAction">The <see cref="T:System.Action`1" /> to be executed after each
            phase.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> is less than 0
            or greater than <see cref="T:System.Int32.MaxValue" />.</exception>
      <remarks>
            The <paramref name="postPhaseAction" /> delegate will be executed after
            all participants have arrived at the barrier in one phase.  The participants
            will not be released to the next phase until the postPhaseAction delegate
            has completed execution.
            </remarks>
    </member>
    <member name="M:System.Threading.Barrier.GetCurrentTotal(System.Int32,System.Int32@,System.Int32@,System.Boolean@)">
      <summary>
            Extract the three variables current, total and sense from a given big variable
            </summary>
      <param name="currentTotal">The integer variable that contains the other three variables</param>
      <param name="current">The current cparticipant count</param>
      <param name="total">The total participants count</param>
      <param name="sense">The sense flag</param>
    </member>
    <member name="M:System.Threading.Barrier.SetCurrentTotal(System.Int32,System.Int32,System.Int32,System.Boolean)">
      <summary>
            Write the three variables current. total and the sense to the m_currentTotal
            </summary>
      <param name="currentTotal">The old current total to compare</param>
      <param name="current">The current cparticipant count</param>
      <param name="total">The total participants count</param>
      <param name="sense">The sense flag</param>
      <returns>True if the CAS succeeded, false otherwise</returns>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary>
            Notifies the <see cref="T:System.Threading.Barrier" /> that there will be an additional participant.
            </summary>
      <returns>The phase number of the barrier in which the new participants will first
            participate.</returns>
      <exception cref="T:System.InvalidOperationException">
            Adding a participant would cause the barrier's participant count to 
            exceed <see cref="T:System.Int16.MaxValue" />.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary>
            Notifies the <see cref="T:System.Threading.Barrier" /> that there will be additional participants.
            </summary>
      <param name="participantCount">The number of additional participants to add to the
            barrier.</param>
      <returns>The phase number of the barrier in which the new participants will first
            participate.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> is less than
            0.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Adding <paramref name="participantCount" /> participants would cause the
            barrier's participant count to exceed <see cref="T:System.Int16.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary>
            Notifies the <see cref="T:System.Threading.Barrier" /> that there will be one less participant.
            </summary>
      <exception cref="T:System.InvalidOperationException">The barrier already has 0
            participants.</exception>
      <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary>
            Notifies the <see cref="T:System.Threading.Barrier" /> that there will be fewer participants.
            </summary>
      <param name="participantCount">The number of additional participants to remove from the barrier.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> is less than
            0.</exception>
      <exception cref="T:System.InvalidOperationException">The barrier already has 0 participants.</exception>
      <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary>
            Signals that a participant has reached the <see cref="T:System.Threading.Barrier" /> and waits for all other
            participants to reach the barrier as well.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary>
            Signals that a participant has reached the <see cref="T:System.Threading.Barrier" /> and waits for all other
            participants to reach the barrier, while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
      <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> has been
            canceled.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary>
            Signals that a participant has reached the <see cref="T:System.Threading.Barrier" /> and waits for all other
            participants to reach the barrier as well, using a
            <see cref="T:System.TimeSpan" /> to measure the time interval.
            </summary>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of
            milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to
            wait indefinitely.</param>
      <returns>true if all other participants reached the barrier; otherwise, false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" />is a negative number
            other than -1 milliseconds, which represents an infinite time-out, or it is greater than
            <see cref="T:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
            Signals that a participant has reached the <see cref="T:System.Threading.Barrier" /> and waits for all other
            participants to reach the barrier as well, using a
            <see cref="T:System.TimeSpan" /> to measure the time interval, while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of
            milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to
            wait indefinitely.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
      <returns>true if all other participants reached the barrier; otherwise, false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" />is a negative number
            other than -1 milliseconds, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> has been
            canceled.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary>
            Signals that a participant has reached the <see cref="T:System.Threading.Barrier" /> and waits for all other
            participants to reach the barrier as well, using a
            32-bit signed integer to measure the time interval.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to wait indefinitely.</param>
      <returns>true if all other participants reached the barrier; otherwise, false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary>
            Signals that a participant has reached the barrier and waits for all other participants to reach
            the barrier as well, using a
            32-bit signed integer to measure the time interval, while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to wait indefinitely.</param>
      <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
      <returns>true if all other participants reached the barrier; otherwise, false.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> has been
            canceled.</exception>
      <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
    </member>
    <member name="M:System.Threading.Barrier.FinishPhase(System.Boolean)">
      <summary>
            Finish the phase by invoking the post phase action, and setting the event, this must be called by the 
            last arrival thread
            </summary>
      <param name="observedSense">The current phase sense</param>
    </member>
    <member name="M:System.Threading.Barrier.SetResetEvents(System.Boolean)">
      <summary>
            Sets the current phase event and reset the next phase event
            </summary>
      <param name="observedSense">The current phase sense</param>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary>
            Releases all resources used by the current instance of <see cref="T:System.Threading.Barrier" />.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action.
            </exception>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.Barrier" />, Dispose is not thread-safe and may not be
            used concurrently with other members of this instance.
            </remarks>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary>
            When overridden in a derived class, releases the unmanaged resources used by the
            <see cref="T:System.Threading.Barrier" />, and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources; false to release
            only unmanaged resources.</param>
      <remarks>
            Unlike most of the members of <see cref="T:System.Threading.Barrier" />, Dispose is not thread-safe and may not be
            used concurrently with other members of this instance.
            </remarks>
    </member>
    <member name="M:System.Threading.Barrier.ThrowIfDisposed">
      <summary>
            Throw ObjectDisposedException if the barrier is disposed
            </summary>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary>
            Gets the number of participants in the barrier that havent yet signaled
            in the current phase.
            </summary>
      <remarks>
            This could be 0 during a post-phase action delegate execution or if the
            ParticipantCount is 0.
            </remarks>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary>
            Gets the total number of participants in the barrier.
            </summary>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary>
            Gets the number of the barrier's current phase.
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.BlockingCollection`1">
      <summary> 
            Provides blocking and bounding capabilities for thread-safe collections that 
            implement <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}" />. 
            </summary>
      <remarks>
        <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}" /> represents a collection
            that allows for thread-safe adding and removing of data. 
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> is used as a wrapper
            for an <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}" /> instance, allowing
            removal attempts from the collection to block until data is available to be removed.  Similarly,
            a <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> can be created to enforce
            an upper-bound on the number of data elements allowed in the 
            <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}" />; addition attempts to the
            collection may then block until space is available to store the added items.  In this manner,
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> is similar to a traditional
            blocking queue data structure, except that the underlying data storage mechanism is abstracted
            away as an <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}" />. 
            </remarks>
      <typeparam name="T">Specifies the type of elements in the collection.</typeparam>
    </member>
    <member name="T:System.Collections.Concurrent.BlockingCollection`1.OperationMode">
      <summary>An enumerated data type used internal to the class to specify to a generic method
            the current mode of operation.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor">
      <summary>Initializes a new instance of the 
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />
            class without an upper-bound.
            </summary>
      <remarks>
            The default underlying collection is a <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1">ConcurrentQueue&lt;T&gt;</see>.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />
            class with the specified upper-bound.
            </summary>
      <param name="boundedCapacity">The bounded size of the collection.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="boundedCapacity" /> is
            not a positive value.</exception>
      <remarks>
            The default underlying collection is a <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1">ConcurrentQueue&lt;T&gt;</see>.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />
            class with the specified upper-bound and using the provided 
            <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}" /> as its underlying data store.</summary>
      <param name="collection">The collection to use as the underlying data store.</param>
      <param name="boundedCapacity">The bounded size of the collection.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collection" /> argument is
            null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="boundedCapacity" /> is not a positive value.</exception>
      <exception cref="T:System.ArgumentException">The supplied <paramref name="collection" /> contains more values 
            than is permitted by <paramref name="boundedCapacity" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
      <summary>Initializes a new instance of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />
            class without an upper-bound and using the provided 
            <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}" /> as its underlying data store.</summary>
      <param name="collection">The collection to use as the underlying data store.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collection" /> argument is
            null.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Initialize(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32,System.Int32)">
      <summary>Initializes the BlockingCollection instance.</summary>
      <param name="collection">The collection to use as the underlying data store.</param>
      <param name="boundedCapacity">The bounded size of the collection.</param>
      <param name="collectionCount">The number of items currently in the underlying collection.</param>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
      <summary>
            Adds the item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.
            </summary>
      <param name="item">The item to be added to the collection. The value can be a null reference.</param>
      <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been marked
            as complete with regards to additions.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
      <remarks>
            If a bounded capacity was specified when this instance of 
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> was initialized, 
            a call to Add may block until space is available to store the provided item.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
      <summary>
            Adds the item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.
            A <see cref="T:System.OperationCanceledException" /> is thrown if the <see cref="T:System.Threading.CancellationToken" /> is
            canceled.
            </summary>
      <param name="item">The item to be added to the collection. The value can be a null reference.</param>
      <param name="cancellationToken">A cancellation token to observe.</param>
      <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is canceled.</exception>
      <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been marked
            as complete with regards to additions.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
      <remarks>
            If a bounded capacity was specified when this instance of 
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> was initialized, 
            a call to <see cref="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)" /> may block until space is available to store the provided item.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
      <summary>
            Attempts to add the specified item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.
            </summary>
      <param name="item">The item to be added to the collection.</param>
      <returns>true if the <paramref name="item" /> could be added; otherwise, false.</returns>
      <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been marked
            as complete with regards to additions.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
      <summary>
            Attempts to add the specified item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.
            </summary>
      <param name="item">The item to be added to the collection.</param>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <returns>true if the <paramref name="item" /> could be added to the collection within 
            the alloted time; otherwise, false.</returns>
      <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been marked
            as complete with regards to additions.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
      <summary>
            Attempts to add the specified item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.
            </summary>
      <param name="item">The item to be added to the collection.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <returns>true if the <paramref name="item" /> could be added to the collection within 
            the alloted time; otherwise, false.</returns>
      <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been marked
            as complete with regards to additions.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
      <summary>
            Attempts to add the specified item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.
            A <see cref="T:System.OperationCanceledException" /> is thrown if the <see cref="T:System.Threading.CancellationToken" /> is
            canceled.
            </summary>
      <param name="item">The item to be added to the collection.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <param name="cancellationToken">A cancellation token to observe.</param>
      <returns>true if the <paramref name="item" /> could be added to the collection within 
            the alloted time; otherwise, false.</returns>
      <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is canceled.</exception>
      <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been marked
            as complete with regards to additions.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddWithNoTimeValidation(`0,System.Int32,System.Threading.CancellationToken)">
      <summary>Adds an item into the underlying data store using its IProducerConsumerCollection&lt;T&gt;.Add 
            method. If a bounded capacity was specified and the collection was full, 
            this method will wait for, at most, the timeout period trying to add the item. 
            If the timeout period was exhaused before successfully adding the item this method will 
            return false.</summary>
      <param name="item">The item to be added to the collection.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait for the collection to accept the item,
            or Timeout.Infinite to wait indefinitely.</param>
      <param name="cancellationToken">A cancellation token to observe.</param>
      <returns>False if the collection remained full till the timeout period was exhausted.True otherwise.</returns>
      <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is canceled.</exception>
      <exception cref="T:System.InvalidOperationException">the collection has already been marked
            as complete with regards to additions.</exception>
      <exception cref="T:System.ObjectDisposedException">If the collection has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Take">
      <summary>Takes an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.</summary>
      <returns>The item removed from the collection.</returns>
      <exception cref="T:System.OperationCanceledException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> is empty and has been marked
            as complete with regards to additions.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
      <remarks>A call to <see cref="M:System.Collections.Concurrent.BlockingCollection`1.Take" /> may block until an item is available to be removed.</remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
      <summary>Takes an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.</summary>
      <returns>The item removed from the collection.</returns>
      <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is
            canceled or the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> is empty and has been marked
            as complete with regards to additions.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
      <remarks>A call to <see cref="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)" /> may block until an item is available to be removed.</remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
      <summary>
            Attempts to remove an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.
            </summary>
      <param name="item">The item removed from the collection.</param>
      <returns>true if an item could be removed; otherwise, false.</returns>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
      <summary>
            Attempts to remove an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.
            </summary>
      <param name="item">The item removed from the collection.</param>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <returns>true if an item could be removed from the collection within 
            the alloted time; otherwise, false.</returns>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
      <summary>
            Attempts to remove an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.
            </summary>
      <param name="item">The item removed from the collection.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <returns>true if an item could be removed from the collection within 
            the alloted time; otherwise, false.</returns>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
      <summary>
            Attempts to remove an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.
            A <see cref="T:System.OperationCanceledException" /> is thrown if the <see cref="T:System.Threading.CancellationToken" /> is
            canceled.
            </summary>
      <param name="item">The item removed from the collection.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <param name="cancellationToken">A cancellation token to observe.</param>
      <returns>true if an item could be removed from the collection within 
            the alloted time; otherwise, false.</returns>
      <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is canceled.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(`0@,System.Int32,System.Threading.CancellationToken,System.Threading.CancellationTokenSource)">
      <summary>Takes an item from the underlying data store using its IProducerConsumerCollection&lt;T&gt;.Take 
            method. If the collection was empty, this method will wait for, at most, the timeout period (if AddingIsCompleted is false)
            trying to remove an item. If the timeout period was exhaused before successfully removing an item 
            this method will return false.
            A <see cref="T:System.OperationCanceledException" /> is thrown if the <see cref="T:System.Threading.CancellationToken" /> is
            canceled.
            </summary>
      <param name="item">The item removed from the collection.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait for the collection to have an item available 
            for removal, or Timeout.Infinite to wait indefinitely.</param>
      <param name="cancellationToken">A cancellation token to observe.</param>
      <param name="combinedTokenSource">A combined cancellation token if created, it is only created by GetConsumingEnumerable to avoid creating the linked token 
            multiple times.</param>
      <returns>False if the collection remained empty till the timeout period was exhausted. True otherwise.</returns>
      <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is canceled.</exception>
      <exception cref="T:System.ObjectDisposedException">If the collection has been disposed.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
      <summary>
            Adds the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item to be added to one of the collections.</param>
      <returns>The index of the collection in the <paramref name="collections" /> array to which the item was added.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
      <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
      <remarks>
            If a bounded capacity was specified when all of the
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances were initialized, 
            a call to AddToAny may block until space is available in one of the collections
            to store the provided item.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
      <summary>
            Adds the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            A <see cref="T:System.OperationCanceledException" /> is thrown if the <see cref="T:System.Threading.CancellationToken" /> is
            canceled. 
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item to be added to one of the collections.</param>
      <param name="cancellationToken">A cancellation token to observe.</param>
      <returns>The index of the collection in the <paramref name="collections" /> array to which the item was added.</returns>
      <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is canceled.</exception>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
      <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
      <remarks>
            If a bounded capacity was specified when all of the
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances were initialized, 
            a call to AddToAny may block until space is available in one of the collections
            to store the provided item.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
      <summary>
            Attempts to add the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item to be added to one of the collections.</param>
      <returns>The index of the collection in the <paramref name="collections" /> 
            array to which the item was added, or -1 if the item could not be added.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
      <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
      <summary>
            Attempts to add the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item to be added to one of the collections.</param>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <returns>The index of the collection in the <paramref name="collections" /> 
            array to which the item was added, or -1 if the item could not be added.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
      <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
      <summary>
            Attempts to add the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item to be added to one of the collections.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>        /// <returns>The index of the collection in the <paramref name="collections" /> 
            array to which the item was added, or -1 if the item could not be added.</returns><exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception><exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception><exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception><exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception><exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception></member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
      <summary>
            Attempts to add the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            A <see cref="T:System.OperationCanceledException" /> is thrown if the <see cref="T:System.Threading.CancellationToken" /> is
            canceled.
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item to be added to one of the collections.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>        /// <returns>The index of the collection in the <paramref name="collections" /> 
            array to which the item was added, or -1 if the item could not be added.</returns><param name="cancellationToken">A cancellation token to observe.</param><exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is canceled.</exception><exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception><exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception><exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception><exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception><exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception></member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddTakeAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Collections.Concurrent.BlockingCollection{`0}.OperationMode,System.Threading.CancellationToken)">
      <summary>Adds/Takes an item to/from anyone of the specified collections.
            A <see cref="T:System.OperationCanceledException" /> is thrown if the <see cref="T:System.Threading.CancellationToken" /> is
            canceled. 
            </summary>
      <param name="collections">The collections into which the item can be added.</param>
      <param name="item">The item to be added or the item removed and returned to the caller.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait for a collection to accept the 
            operation, or -1 to wait indefinitely.</param>
      <param name="operationMode">Indicates whether this method is called to Add or Take.</param>
      <param name="externalCancellationToken">A cancellation token to observe.</param>
      <returns>The index into collections for the collection which accepted the 
            adding/removal of the item; -1 if the item could not be added/removed.</returns>
      <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is canceled.</exception>
      <exception cref="T:System.ArgumentNullException">If the collections argument is null.</exception>
      <exception cref="T:System.ArgumentException">If the collections argument is a 0-length array or contains a 
            null element. Also, if atleast one of the collections has been marked complete for adds.</exception>
      <exception cref="T:System.ObjectDisposedException">If atleast one of the collections has been disposed.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetHandles(System.Collections.Concurrent.BlockingCollection{`0}[],System.Collections.Concurrent.BlockingCollection{`0}.OperationMode,System.Threading.CancellationToken,System.Boolean,System.Threading.CancellationToken[]@)">
      <summary>
            Local static method, used by TryAddTakeAny to get the wait handles for the collection, with exclude option to exclude the Compeleted collections
            </summary>
      <param name="collections">The blocking collections</param>
      <param name="operationMode">Add or Take operation</param>
      <param name="externalCancellationToken">The original CancellationToken</param>
      <param name="excludeCompleted">True to exclude the compeleted collections</param>
      <param name="cancellationTokens">Complete list of cancellationTokens to observe</param>
      <returns>The collections wait handles</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.WaitHandle_WaitAny(System.Collections.Generic.List{System.Threading.WaitHandle},System.Int32,System.Threading.CancellationToken,System.Threading.CancellationToken)">
      <summary>
            Helper to perform WaitHandle.WaitAny(.., CancellationToken)
            this should eventually appear on the WaitHandle class.
            </summary>
      <param name="handles">
      </param>
      <param name="millisecondsTimeout">
      </param>
      <param name="combinedToken">
      </param>
      <param name="externalToken">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.UpdateTimeOut(System.Int64,System.Int32)">
      <summary>
            Helper function to measure and update the wait time
            </summary>
      <param name="startTimeTicks"> The first time (in Ticks) observed when the wait started</param>
      <param name="originalWaitMillisecondsTimeout">The orginal wait timeoutout in milliseconds</param>
      <returns>The new wait time in milliseconds, -1 if the time expired</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
      <summary>
            Takes an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item removed from one of the collections.</param>
      <returns>The index of the collection in the <paramref name="collections" /> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element.</exception>
      <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
      <remarks>A call to TakeFromAny may block until an item is available to be removed.</remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
      <summary>
            Takes an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            A <see cref="T:System.OperationCanceledException" /> is thrown if the <see cref="T:System.Threading.CancellationToken" /> is
            canceled.
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item removed from one of the collections.</param>
      <param name="cancellationToken">A cancellation token to observe.</param>
      <returns>The index of the collection in the <paramref name="collections" /> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception>
      <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is canceled.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element.</exception>
      <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of 
            62 for STA and 63 for MTA.</exception>
      <remarks>A call to TakeFromAny may block until an item is available to be removed.</remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
      <summary>
            Attempts to remove an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item removed from one of the collections.</param>
      <returns>The index of the collection in the <paramref name="collections" /> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element.</exception>
      <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception>
      <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
      <remarks>A call to TryTakeFromAny may block until an item is available to be removed.</remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
      <summary>
            Attempts to remove an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item removed from one of the collections.</param>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
      <returns>The index of the collection in the <paramref name="collections" /> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element.</exception>
      <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
      <remarks>A call to TryTakeFromAny may block until an item is available to be removed.</remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
      <summary>
            Attempts to remove an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item removed from one of the collections.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <returns>The index of the collection in the <paramref name="collections" /> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element.</exception>
      <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
      <remarks>A call to TryTakeFromAny may block until an item is available to be removed.</remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
      <summary>
            Attempts to remove an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances.
            A <see cref="T:System.OperationCanceledException" /> is thrown if the <see cref="T:System.Threading.CancellationToken" /> is
            canceled. 
            </summary>
      <param name="collections">The array of collections.</param>
      <param name="item">The item removed from one of the collections.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <param name="cancellationToken">A cancellation token to observe.</param>
      <returns>The index of the collection in the <paramref name="collections" /> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
      <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is canceled.</exception>
      <exception cref="T:System.ArgumentNullException">The <paramref name="collections" /> argument is
            null.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="collections" /> argument is
            a 0-length array or contains a null element.</exception>
      <exception cref="T:System.ObjectDisposedException">At least one of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances has been disposed.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections" /> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
      <remarks>A call to TryTakeFromAny may block until an item is available to be removed.</remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
      <summary>
            Marks the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instances
            as not accepting any more additions.  
            </summary>
      <remarks>
            After a collection has been marked as complete for adding, adding to the collection is not permitted 
            and attempts to remove from the collection will not wait when the collection is empty.
            </remarks>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.CancelWaitingConsumers">
      <summary>Cancels the semaphores.</summary>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
      <summary>
            Releases resources used by the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)">
      <summary>
            Releases resources used by the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.
            </summary>
      <param name="disposing">Whether being disposed explicitly (true) or due to a finalizer (false).</param>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
      <summary>Copies the items from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance into a new array.</summary>
      <returns>An array containing copies of the elements of the collection.</returns>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <remarks>
            The copied elements are not removed from the collection.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
      <summary>Copies all of the items in the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance 
            to a compatible one-dimensional array, starting at the specified index of the target array.
            </summary>
      <param name="array">The one-dimensional array that is the destination of the elements copied from 
            the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance. The array must have zero-based indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="array" /> argument is
            null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="index" /> argument is less than zero.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="index" /> argument is equal to or greater 
            than the length of the <paramref name="array" />.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
      <summary>Provides a consuming <see cref="T:System.Collections.Generics.IEnumerable{T}" /> for items in the collection.</summary>
      <returns>An <see cref="T:System.Collections.Generics.IEnumerable{T}" /> that removes and returns items from the collection.</returns>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
      <summary>Provides a consuming <see cref="T:System.Collections.Generics.IEnumerable{T}" /> for items in the collection.
            Calling MoveNext on the returned enumerable will block if there is no data available, or will
            throw an <see cref="T:System.OperationCanceledException" /> if the <see cref="T:System.Threading.CancellationToken" /> is canceled.
            </summary>
      <param name="cancellationToken">A cancellation token to observe.</param>
      <returns>An <see cref="T:System.Collections.Generics.IEnumerable{T}" /> that removes and returns items from the collection.</returns>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
      <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken" /> is canceled.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.ValidateCollectionsArray(System.Collections.Concurrent.BlockingCollection{`0}[],System.Collections.Concurrent.BlockingCollection{`0}.OperationMode)">
      <summary>Centralizes the logic for validating the BlockingCollections array passed to TryAddToAny()
            and TryTakeFromAny().</summary>
      <param name="collections">The collections to/from which an item should be added/removed.</param>
      <param name="operationMode">Indicates whether this method is called to Add or Take.</param>
      <returns>A copy of the collections array that acts as a defense to prevent an outsider from changing 
            elements of the array after we have done the validation on them.</returns>
      <exception cref="T:System.ArgumentNullException">If the collections argument is null.</exception>
      <exception cref="T:System.ArgumentException">If the collections argument is a 0-length array or contains a 
            null element. Also, if atleast one of the collections has been marked complete for adds.</exception>
      <exception cref="T:System.ObjectDisposedException">If atleast one of the collections has been disposed.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.ValidateTimeout(System.TimeSpan)">
      <summary>Centeralizes the logic of validating the timeout input argument.</summary>
      <param name="timeout">The TimeSpan to wait for to successfully complete an operation on the collection.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">If the number of millseconds represented by the timeout 
            TimeSpan is less than 0 or is larger than Int32.MaxValue and not Timeout.Infinite</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.ValidateMillisecondsTimeout(System.Int32)">
      <summary>Centralizes the logic of validating the millisecondsTimeout input argument.</summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait for to successfully complete an 
            operation on the collection.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">If the number of millseconds is less than 0 and not 
            equal to Timeout.Infinite.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.CheckDisposed">
      <summary>Throws a System.ObjectDisposedException if the collection was disposed</summary>
      <exception cref="T:System.ObjectDisposedException">If the collection has been disposed.</exception>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
      <summary>Gets the bounded capacity of this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> instance.</summary>
      <value>The bounded capacity of this collection, or int.MaxValue if no bound was supplied.</value>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
      <summary>Gets whether this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been marked as complete for adding.</summary>
      <value>Whether this collection has been marked as complete for adding.</value>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
      <summary>Gets whether this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been marked as complete for adding and is empty.</summary>
      <value>Whether this collection has been marked as complete for adding and is empty.</value>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.Count">
      <summary>Gets the number of items contained in the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.</summary>
      <value>The number of items contained in the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" />.</value>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection{T}" /> has been disposed.</exception>
    </member>
    <member name="T:System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1">
      <summary>A debugger view of the blocking collection that makes it simple to browse the
            collection's contents at a point in time.</summary>
      <typeparam name="T">The type of element that the BlockingCollection will hold.</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1.#ctor(System.Collections.Concurrent.BlockingCollection{`0})">
      <summary>Constructs a new debugger view object for the provided blocking collection object.</summary>
      <param name="collection">A blocking collection to browse in the debugger.</param>
    </member>
    <member name="P:System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1.Items">
      <summary>Returns a snapshot of the underlying collection's elements.</summary>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentBag`1">
      <summary>
            Represents an thread-safe, unordered collection of objects. 
            </summary>
      <typeparam name="T">Specifies the type of elements in the bag.</typeparam>
      <remarks>
        <para>
            Bags are useful for storing objects when ordering doesn't matter, and unlike sets, bags support
            duplicates. <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> is a thread-safe bag implementation, optimized for
            scenarios where the same thread will be both producing and consuming data stored in the bag.
            </para>
        <para>
          <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> accepts null reference (Nothing in Visual Basic) as a valid 
            value for reference types.
            </para>
        <para>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> are thread-safe and may be used
            concurrently from multiple threads.
            </para>
      </remarks>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentBag`1.Node">
      <summary>
            A class that represents a node in the lock thread list
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentBag`1.ThreadLocalList">
      <summary>
            A class that represents the lock thread list
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.ThreadLocalList.#ctor(System.Threading.Thread)">
      <summary>
            ThreadLocalList constructor
            </summary>
      <param name="ownerThread">The owner thread for this list</param>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.ThreadLocalList.Count">
      <summary>
            Gets the total list count, it's not thread safe, may provide incorrect count if it is called concurrently
            </summary>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentBag`1.ListOperation">
      <summary>
            List operations
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />
            class.
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />
            class that contains elements copied from the specified collection.
            </summary>
      <param name="collection">The collection whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is a null reference
            (Nothing in Visual Basic).</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Initialize(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Local helper function to initalize a new bag object
            </summary>
      <param name="collection">An enumeration containing items with which to initialize this bag.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Add(`0)">
      <summary>
            Adds an object to the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.
            </summary>
      <param name="item">The object to be added to the
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. The value can be a null reference
            (Nothing in Visual Basic) for reference types.</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.AddInternal(System.Collections.Concurrent.ConcurrentBag{`0}.ThreadLocalList,`0)">
      <summary>
      </summary>
      <param name="list">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryTake(`0@)">
      <summary>
            Attempts to remove and return an object from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.
            </summary>
      <param name="result">When this method returns, <paramref name="result" /> contains the object
            removed from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> or the default value
            of <typeparamref name="T" /> if the operation failed.</param>
      <returns>true if an object was removed successfully; otherwise, false.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryPeek(`0@)">
      <summary>
            Attempts to return an object from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />
            without removing it.
            </summary>
      <param name="result">When this method returns, <paramref name="result" /> contains an object from
            the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> or the default value of
            <typeparamref name="T" /> if the operation failed.</param>
      <returns>true if and object was returned successfully; otherwise, false.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryTakeOrPeek(`0@,System.Boolean)">
      <summary>
            Local helper function to Take or Peek an item from the bag
            </summary>
      <param name="result">To receive the item retrieved from the bag</param>
      <param name="take">True means Take operation, false means Peek operation</param>
      <returns>True if succeeded, false otherwise</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetThreadList(System.Boolean)">
      <summary>
            Local helper function to retrieve a thread local list by a thread object
            </summary>
      <param name="forceCreate">Create a new list if the thread does ot exist</param>
      <returns>The local list object</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetUnownedList">
      <summary>
            Try to reuse an unowned list if exist
            unowned lists are the lists that their owner threads are aborted or terminated
            this is workaround to avoid memory leaks.
            </summary>
      <returns>The list object, null if all lists are owned</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Steal(`0@,System.Boolean)">
      <summary>
            Local helper method to steal an item from any other non empty thread
            It enumerate all other threads in two passes first pass acquire the lock with TryEnter if succeeded
            it steals the item, otherwise it enumerate them again in 2nd pass and acquire the lock using Enter
            </summary>
      <param name="result">To receive the item retrieved from the bag</param>
      <param name="take">Whether to remove or peek.</param>
      <returns>True if succeeded, false otherwise.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TrySteal(System.Collections.Concurrent.ConcurrentBag{`0}.ThreadLocalList,`0@,System.Boolean)">
      <summary>
            local helper function tries to steal an item from given local list
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.CanSteal(System.Collections.Concurrent.ConcurrentBag{`0}.ThreadLocalList)">
      <summary>
            Local helper function to check the list if it became empty after acquiring the lock
            and wait if there is unsynchronized Add/Take operation in the list to be done
            </summary>
      <param name="list">The list to steal</param>
      <returns>True if can steal, false otherwise</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> elements to an existing
            one-dimensional <see cref="T:System.Array">Array</see>, starting at the specified array
            index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />. The <see cref="T:System.Array">Array</see> must have zero-based indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying
            begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is a null reference (Nothing in
            Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than
            zero.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> is equal to or greater than the
            length of the <paramref name="array" />
            -or- the number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> is greater than the available space from
            <paramref name="index" /> to the end of the destination <paramref name="array" />.</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.ToArray">
      <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> elements to a new array.
            </summary>
      <returns>A new array containing a snapshot of elements copied from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.
            </summary>
      <returns>An enumerator for the contents of the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</returns>
      <remarks>
            The enumeration represents a moment-in-time snapshot of the contents
            of the bag.  It does not reflect any updates to the collection after 
            <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator" /> was called.  The enumerator is safe to use
            concurrently with reads from and writes to the bag.
            </remarks>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.OnSerializing(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Get the data array to be serialized
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Construct the stack from a previously seiralized one
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.FreezeBag(System.Boolean@)">
      <summary>
            Local helper method to freeze all bag operations, it
            1- Acquire the global lock to prevent any other thread to freeze the bag, and also new new thread can be added
            to the dictionary
            2- Then Acquire all local lists locks to prevent steal and synchronized operations
            3- Wait for all un-synchronized operations to be done
            </summary>
      <param name="lockTaken">Retrieve the lock taken result for the global lock, to be passed to Unfreeze method</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.UnfreezeBag(System.Boolean)">
      <summary>
            Local helper method to unfreeze the bag from a frozen state
            </summary>
      <param name="lockTaken">The lock taken result from the Freeze method</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.AcquireAllLocks">
      <summary>
            local helper method to acquire all local lists locks
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.ReleaseAllLocks">
      <summary>
            Local helper method to release all local lists locks
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WaitAllOperations">
      <summary>
            Local helper function to wait all unsynchronized operations
            </summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetCountInternal">
      <summary>
            Local helper function to get the bag count, the caller should call it from Freeze/Unfreeze block
            </summary>
      <returns>The current bag count</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.ToList">
      <summary>
            Local helper function to return the bag item in a list, this is mainly used by CopyTo and ToArray
            This is not thread safe, should be called in Freeze/UnFreeze bag block
            </summary>
      <returns>List the contains the bag items</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.
            </summary>
      <value>The number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />.</value>
      <remarks>
            The count returned represents a moment-in-time snapshot of the contents
            of the bag.  It does not reflect any updates to the collection after 
            <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator" /> was called.
            </remarks>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.IsEmpty">
      <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> is empty.
            </summary>
      <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> is empty; otherwise, false.</value>
    </member>
    <member name="T:System.Collections.Concurrent.SystemThreadingCollection_IProducerConsumerCollectionDebugView`1">
      <summary>
            A simple class for the debugger view window
            </summary>
    </member>
    <member name="T:System.Linq.ParallelEnumerable">
      <summary>
            Provides a set of methods for querying objects that implement 
            ParallelQuery{TSource}.  This is the parallel equivalent of 
            <see cref="T:System.Linq.Enumerable" />.
            </summary>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.AsParallel``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Enables parallelization of a query.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> 
            to convert to a <see cref="T:System.Linq.ParallelQuery`1" />.</param>
      <returns>The source as a <see cref="T:System.Linq.ParallelQuery`1" /> to bind to
            ParallelEnumerable extension methods.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.AsParallel``1(System.Collections.Concurrent.Partitioner{``0})">
      <summary>
            Enables parallelization of a query, as sourced by a partitioner
            responsible for splitting the input sequence into partitions.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A partitioner over the input sequence.</param>
      <returns>The <paramref name="source" /> as a ParallelQuery to bind to ParallelEnumerable extension methods.</returns>
      <remarks>
            The source partitioner's GetOrderedPartitions method is used when ordering is enabled,
            whereas the partitioner's GetPartitions is used if ordering is not enabled (the default).
            The source partitioner's GetDynamicPartitions and GetDynamicOrderedPartitions are not used.
            </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.AsOrdered``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Enables treatment of a data source as if it was ordered, overriding the default of unordered.
            AsOrdered may only be invoked on sequences returned by AsParallel, ParallelEnumerable.Range,
            and ParallelEnumerable.Repeat.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">The input sequence.</param>
      <exception cref="T:System.InvalidOperationException">
            Thrown if <paramref name="source" /> is not one of AsParallel, ParallelEnumerable.Range, or ParallelEnumerable.Repeat.
            </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <remarks>
            A natural tension exists between performance and preserving order in parallel processing. By default, 
            a parallelized query behaves as if the ordering of the results is arbitrary 
            unless AsOrdered is applied or there is an explicit OrderBy operator in the query.
            </remarks>
      <returns>The source sequence which will maintain ordering in the query.</returns>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.AsOrdered(System.Linq.ParallelQuery)">
      <summary>
            Enables treatment of a data source as if it was ordered, overriding the default of unordered.
            AsOrdered may only be invoked on sequences returned by AsParallel, ParallelEnumerable.Range,
            and ParallelEnumerable.Repeat.
            </summary>
      <param name="source">The input sequence.</param>
      <exception cref="T:System.InvalidOperationException">
            Thrown if the <paramref name="source" /> is not one of AsParallel, ParallelEnumerable.Range, or ParallelEnumerable.Repeat.
            </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <remarks>
            A natural tension exists between performance and preserving order in parallel processing. By default, 
            a parallelized query behaves as if the ordering of the results is arbitrary unless AsOrdered 
            is applied or there is an explicit OrderBy operator in the query.
            </remarks>
      <returns>The source sequence which will maintain ordering in the query.</returns>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.AsUnordered``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Allows an intermediate query to be treated as if no ordering is implied among the elements.
            </summary>
      <remarks>
            AsUnordered may provide
            performance benefits when ordering is not required in a portion of a query.
            </remarks>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">The input sequence.</param>
      <returns>The source sequence with arbitrary order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.AsParallel(System.Collections.IEnumerable)">
      <summary>
            Enables parallelization of a query.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to convert 
            to a <see cref="T:System.Linq.ParallelQuery`1" />.</param>
      <returns>
            The source as a ParallelQuery to bind to
            ParallelEnumerable extension methods.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.AsSequential``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Converts a <see cref="T:System.Linq.ParallelQuery`1" /> into an 
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> to force sequential
            evaluation of the query.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A <see cref="T:System.Linq.ParallelQuery`1" /> to convert to an <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <returns>The source as an <see cref="T:System.Collections.Generic.IEnumerable`1" />
            to bind to sequential extension methods.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.WithTaskScheduler``1(System.Linq.ParallelQuery{``0},System.Threading.Tasks.TaskScheduler)">
      <summary>
            Sets the task scheduler to execute the query.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A ParallelQuery on which to set the task scheduler option.</param>
      <param name="taskScheduler">Task scheduler to execute the query.</param>
      <returns>ParallelQuery representing the same query as source, but with the task scheduler option set.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="taskScheduler" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
            WithTaskScheduler is used multiple times in the query.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.WithDegreeOfParallelism``1(System.Linq.ParallelQuery{``0},System.Int32)">
      <summary>
            Sets the degree of parallelism to use in a query. Degree of parallelism is the maximum number of concurrently
            executing tasks that will be used to process the query.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A ParallelQuery on which to set the limit on the degrees of parallelism.</param>
      <param name="degreeOfParallelism">The degree of parallelism for the query.</param>
      <returns>ParallelQuery representing the same query as source, with the limit on the degrees of parallelism set.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
            WithDegreeOfParallelism is used multiple times in the query.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="degreeOfParallelism" /> is less than 1 or greater than 63.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.WithCancellation``1(System.Linq.ParallelQuery{``0},System.Threading.CancellationToken)">
      <summary>
            Sets the <see cref="T:System.Threading.CancellationToken" /> to associate with the query.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A ParallelQuery on which to set the option.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>ParallelQuery representing the same query as source, but with the <seealso cref="T:System.Threading.CancellationToken" />
            registered.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
            WithCancellation is used multiple times in the query.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <paramref name="cancellationToken" /> has been disposed.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.WithExecutionMode``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelExecutionMode)">
      <summary>
            Sets the execution mode of the query.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A ParallelQuery on which to set the option.</param>
      <param name="executionMode">The mode in which to execute the query.</param>
      <returns>ParallelQuery representing the same query as source, but with the 
            <seealso cref="T:System.Linq.ParallelExecutionMode" /> registered.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="executionMode" /> is not a valid <see cref="T:System.Linq.ParallelExecutionMode" /> value.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            WithExecutionMode is used multiple times in the query.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.WithMergeOptions``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelMergeOptions)">
      <summary>
            Sets the merge options for this query, which specify how the query will buffer output.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A ParallelQuery on which to set the option.</param>
      <param name="mergeOptions">The merge optiosn to set for this query.</param>
      <returns>ParallelQuery representing the same query as source, but with the 
            <seealso cref="T:System.Linq.ParallelMergeOptions" /> registered.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="mergeOptions" /> is not a valid <see cref="T:System.Linq.ParallelMergeOptions" /> value.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            WithMergeOptions is used multiple times in the query.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)">
      <summary>
            Generates a parallel sequence of integral numbers within a specified range.
            </summary>
      <param name="start">The value of the first integer in the sequence.</param>
      <param name="count">The number of sequential integers to generate.</param>
      <returns>An <b>IEnumerable&lt;Int32&gt;</b> in C# or <B>IEnumerable(Of Int32)</B> in 
            Visual Basic that contains a range of sequential integral numbers.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is less than 0
            -or-
            <paramref name="start" /> + <paramref name="count" /> - 1 is larger than <see cref="M:System.Int32.MaxValue" />.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)">
      <summary>
            Generates a parallel sequence that contains one repeated value.
            </summary>
      <typeparam name="TResult">The type of the value to be repeated in the result sequence.</typeparam>
      <param name="element">The value to be repeated.</param>
      <param name="count">The number of times to repeat the value in the generated sequence.</param>
      <returns>A sequence that contains a repeated value.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is less than 0.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Empty``1">
      <summary>
            Returns an empty ParallelQuery{TResult} that has the specified type argument.
            </summary>
      <typeparam name="TResult">The type to assign to the type parameter of the returned 
            generic sequence.</typeparam>
      <returns>An empty sequence whose type argument is <typeparamref name="TResult" />.</returns>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ForAll``1(System.Linq.ParallelQuery{``0},System.Action{``0})">
      <summary>
            Invokes in parallel the specified action for each element in the <paramref name="source" />.
            </summary>
      <remarks>
            This is an efficient way to process the output from a parallelized query because it does 
            not require a merge step at the end.  However, order of execution is non-deterministic.
            </remarks>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">The <see cref="T:System.Linq.ParallelQuery`1" /> whose elements will be processed by 
            <paramref name="action" />.</param>
      <param name="action">An Action to invoke on each element.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Filters in parallel a sequence of values based on a predicate.
            </summary>
      <typeparam name="TSource">The type of the elements of source.</typeparam>
      <param name="source">A sequence to filter.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>A sequence that contains elements from the input sequence that satisfy 
            the condition.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})">
      <summary>
            Filters in parallel a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.
            </summary>
      <typeparam name="TSource">The type of the elements of source.</typeparam>
      <param name="source">A sequence to filter.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>A sequence that contains elements from the input sequence that satisfy the condition.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})">
      <summary>
            Projects in parallel each element of a sequence into a new form.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TResult">The type of elements resturned by <b>selector</b>.</typeparam>
      <param name="source">A sequence of values to invoke a transform function on.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A sequence whose elements are the result of invoking the transform function on each 
            element of <paramref name="source" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,``1})">
      <summary>
            Projects in parallel each element of a sequence into a new form by incorporating the element's index.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TResult">The type of elements resturned by <b>selector</b>.</typeparam>
      <param name="source">A sequence of values to invoke a transform function on.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A sequence whose elements are the result of invoking the transform function on each 
            element of <paramref name="source" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Zip``3(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``1,``2})">
      <summary>
            Merges in parallel two sequences by using the specified predicate function.
            </summary>
      <typeparam name="TFirst">The type of the elements of the first sequence.</typeparam>
      <typeparam name="TSecond">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the return elements.</typeparam>
      <param name="first">The first sequence to zip.</param>
      <param name="second">The second sequence to zip.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <returns>
            A sequence that has elements of type <typeparamref name="TResult" /> that are obtained by performing 
            resultSelector pairwise on two sequences. If the sequence lengths are unequal, this truncates
            to the length of the shorter sequence.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Zip``3(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
      <summary>
            This Zip overload should never be called. 
            This method is marked as obsolete and always throws 
            <see cref="T:System.NotSupportedException" /> when invoked.
            </summary>
      <typeparam name="TFirst">This type parameter is not used.</typeparam>
      <typeparam name="TSecond">This type parameter is not used.</typeparam>
      <typeparam name="TResult">This type parameter is not used.</typeparam>
      <param name="first">This parameter is not used.</param>
      <param name="second">This parameter is not used.</param>
      <param name="resultSelector">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of Zip with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the Zip operator would appear to be bind to the parallel implementation, but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
      <summary>
            Correlates in parallel the elements of two sequences based on matching keys. 
            The default equality comparer is used to compare keys.
            </summary>
      <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
      <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <param name="outer">The first sequence to join.</param>
      <param name="inner">The sequence to join to the first sequence.</param>
      <param name="outerKeySelector">A function to extract the join key from each element of 
            the first sequence.</param>
      <param name="innerKeySelector">A function to extract the join key from each element of 
            the second sequence.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <returns>A sequence that has elements of type <typeparamref name="TResult" /> that are obtained by performing 
            an inner join on two sequences.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or
            <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
      <summary>
            This Join overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when invoked.
            </summary>
      <typeparam name="TOuter">This type parameter is not used.</typeparam>
      <typeparam name="TInner">This type parameter is not used.</typeparam>
      <typeparam name="TKey">This type parameter is not used.</typeparam>
      <typeparam name="TResult">This type parameter is not used.</typeparam>
      <param name="outer">This parameter is not used.</param>
      <param name="inner">This parameter is not used.</param>
      <param name="outerKeySelector">This parameter is not used.</param>
      <param name="innerKeySelector">This parameter is not used.</param>
      <param name="resultSelector">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
            This overload exists to disallow usage Join with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the Join operator would appear to be binding to the parallel implementation, but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>
            Correlates in parallel the elements of two sequences based on matching keys. 
            A specified IEqualityComparer{T} is used to compare keys.
            </summary>
      <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
      <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <param name="outer">The first sequence to join.</param>
      <param name="inner">The sequence to join to the first sequence.</param>
      <param name="outerKeySelector">A function to extract the join key from each element 
            of the first sequence.</param>
      <param name="innerKeySelector">A function to extract the join key from each element 
            of the second sequence.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to hash and compare keys.</param>
      <returns>A sequence that has elements of type <typeparamref name="TResult" /> that are obtained by performing 
            an inner join on two sequences.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or
            <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>
            This Join overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when invoked.
            </summary>
      <typeparam name="TOuter">This type parameter is not used.</typeparam>
      <typeparam name="TInner">This type parameter is not used.</typeparam>
      <typeparam name="TKey">This type parameter is not used.</typeparam>
      <typeparam name="TResult">This type parameter is not used.</typeparam>
      <param name="outer">This parameter is not used.</param>
      <param name="inner">This parameter is not used.</param>
      <param name="outerKeySelector">This parameter is not used.</param>
      <param name="innerKeySelector">This parameter is not used.</param>
      <param name="resultSelector">This parameter is not used.</param>
      <param name="comparer">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of Join with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the Join operator would appear to be binding to the parallel implementation, but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})">
      <summary>
            Correlates in parallel the elements of two sequences based on equality of keys and groups the results. 
            The default equality comparer is used to compare keys.
            </summary>
      <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
      <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <param name="outer">The first sequence to join.</param>
      <param name="inner">The sequence to join to the first sequence.</param>
      <param name="outerKeySelector">A function to extract the join key from each element 
            of the first sequence.</param>
      <param name="innerKeySelector">A function to extract the join key from each element 
            of the second sequence.</param>
      <param name="resultSelector">A function to create a result element from an element from 
            the first sequence and a collection of matching elements from the second sequence.</param>
      <returns>A sequence that has elements of type <typeparamref name="TResult" /> that are obtained by performing 
            a grouped join on two sequences.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or
            <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})">
      <summary>
             This GroupJoin overload should never be called. 
             This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.
             </summary>
      <typeparam name="TOuter">This type parameter is not used.</typeparam>
      <typeparam name="TInner">This type parameter is not used.</typeparam>
      <typeparam name="TKey">This type parameter is not used.</typeparam>
      <typeparam name="TResult">This type parameter is not used.</typeparam>
      <param name="outer">This parameter is not used.</param>
      <param name="inner">This parameter is not used.</param>
      <param name="outerKeySelector">This parameter is not used.</param>
      <param name="innerKeySelector">This parameter is not used.</param>
      <param name="resultSelector">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
             This overload exists to disallow usage of GroupJoin with a left data source of type
             <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
             Otherwise, the GroupJoin operator would appear to be binding to the parallel implementation, 
             but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>
            Correlates in parallel the elements of two sequences based on key equality and groups the results. 
            A specified IEqualityComparer{T} is used to compare keys.
            </summary>
      <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
      <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <param name="outer">The first sequence to join.</param>
      <param name="inner">The sequence to join to the first sequence.</param>
      <param name="outerKeySelector">A function to extract the join key from each element 
            of the first sequence.</param>
      <param name="innerKeySelector">A function to extract the join key from each element 
            of the second sequence.</param>
      <param name="resultSelector">A function to create a result element from an element from 
            the first sequence and a collection of matching elements from the second sequence.</param>
      <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to hash and compare keys.</param>
      <returns>A sequence that has elements of type <typeparamref name="TResult" /> that are obtained by performing 
            a grouped join on two sequences.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or
            <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>
            This GroupJoin overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.
            </summary>
      <typeparam name="TOuter">This type parameter is not used.</typeparam>
      <typeparam name="TInner">This type parameter is not used.</typeparam>
      <typeparam name="TKey">This type parameter is not used.</typeparam>
      <typeparam name="TResult">This type parameter is not used.</typeparam>
      <param name="outer">This parameter is not used.</param>
      <param name="inner">This parameter is not used.</param>
      <param name="outerKeySelector">This parameter is not used.</param>
      <param name="innerKeySelector">This parameter is not used.</param>
      <param name="resultSelector">This parameter is not used.</param>
      <param name="comparer">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of GroupJoin with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the GroupJoin operator would appear to be binding to the parallel implementation, 
            but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Projects in parallel each element of a sequence to an IEnumerable{T} 
            and flattens the resulting sequences into one sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TResult">The type of the elements of the sequence returned by <B>selector</B>.</typeparam>
      <param name="source">A sequence of values to project.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A sequence whose elements are the result of invoking the one-to-many transform 
            function on each element of the input sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Projects in parallel each element of a sequence to an IEnumerable{T}, and flattens the resulting 
            sequences into one sequence. The index of each source element is used in the projected form of 
            that element.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TResult">The type of the elements of the sequence returned by <B>selector</B>.</typeparam>
      <param name="source">A sequence of values to project.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A sequence whose elements are the result of invoking the one-to-many transform 
            function on each element of the input sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
      <summary>
            Projects each element of a sequence to an IEnumerable{T}, 
            flattens the resulting sequences into one sequence, and invokes a result selector 
            function on each element therein.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TCollection">The type of the intermediate elements collected by <paramref name="collectionSelector" />.</typeparam>
      <typeparam name="TResult">
      </typeparam>
      <param name="source">A sequence of values to project.</param>
      <param name="collectionSelector">A transform function to apply to each source element; 
            the second parameter of the function represents the index of the source element.</param>
      <param name="resultSelector">A function to create a result element from an element from 
            the first sequence and a collection of matching elements from the second sequence.</param>
      <returns>A sequence whose elements are the result of invoking the one-to-many transform 
            function <paramref name="collectionSelector" /> on each element of <paramref name="source" /> and then mapping 
            each of those sequence elements and their corresponding source element to a result element.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="collectionSelector" /> or
            <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
      <summary>
            Projects each element of a sequence to an IEnumerable{T}, flattens the resulting 
            sequences into one sequence, and invokes a result selector function on each element 
            therein. The index of each source element is used in the intermediate projected 
            form of that element.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TCollection">The type of the intermediate elements collected by 
            <paramref name="collectionSelector" />.</typeparam>
      <typeparam name="TResult">The type of elements to return.</typeparam>
      <param name="source">A sequence of values to project.</param>
      <param name="collectionSelector">A transform function to apply to each source element; 
            the second parameter of the function represents the index of the source element.</param>
      <param name="resultSelector">A function to create a result element from an element from 
            the first sequence and a collection of matching elements from the second sequence.</param>
      <returns>
            A sequence whose elements are the result of invoking the one-to-many transform 
            function <paramref name="collectionSelector" /> on each element of <paramref name="source" /> and then mapping 
            each of those sequence elements and their corresponding source element to a 
            result element.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="collectionSelector" /> or
            <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})">
      <summary>
            Sorts in parallel the elements of a sequence in ascending order according to a key.
            </summary>
      <remarks>
            In contrast to the sequential implementation, this is not a stable sort. 
            To achieve a stable sort, change a query of the form:
            <code>var ordered = source.OrderBy((e) =&gt; e.k);</code>
            to instead be formed as:
            <code>var ordered = source.Select((e,i) =&gt; new { E=e, I=i }).OrderBy((v) =&gt; v.i).Select((v) =&gt; v.e);</code></remarks>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">A sequence of values to order.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <returns>An OrderedParallelQuery{TSource} whose elements are sorted 
            according to a key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>
            Sorts in parallel the elements of a sequence in ascending order by using a specified comparer.
            </summary>
      <remarks>
            In contrast to the sequential implementation, this is not a stable sort.
            See the remarks for OrderBy(ParallelQuery{TSource}, Func{TSource,TKey}) for 
            an approach to implementing a stable sort.
            </remarks>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">A sequence of values to order.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <param name="comparer">An IComparer{TKey} to compare keys.</param>
      <returns>An OrderedParallelQuery{TSource} whose elements are sorted according 
            to a key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})">
      <summary>
            Sorts in parallel the elements of a sequence in descending order according to a key.
            </summary>
      <remarks>
            In contrast to the sequential implementation, this is not a stable sort.
            See the remarks for OrderBy(ParallelQuery{TSource}, Func{TSource,TKey}) for 
            an approach to implementing a stable sort.
            </remarks>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">A sequence of values to order.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <returns>An OrderedParallelQuery{TSource} whose elements are sorted 
            descending according to a key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>
            Sorts the elements of a sequence in descending order by using a specified comparer.
            </summary>
      <remarks>
            In contrast to the sequential implementation, this is not a stable sort.
            See the remarks for OrderBy(ParallelQuery{TSource}, Func{TSource,TKey}) for 
            an approach to implementing a stable sort.
            </remarks>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">A sequence of values to order.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <param name="comparer">An IComparer{TKey} to compare keys.</param>
      <returns>An OrderedParallelQuery{TSource} whose elements are sorted descending 
            according to a key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1})">
      <summary>
            Performs in parallel a subsequent ordering of the elements in a sequence 
            in ascending order according to a key.
            </summary>
      <remarks>
            In contrast to the sequential implementation, this is not a stable sort.
            See the remarks for OrderBy(ParallelQuery{TSource}, Func{TSource,TKey}) for 
            an approach to implementing a stable sort.
            </remarks>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">An OrderedParallelQuery{TSource} than 
            contains elements to sort.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <returns>An OrderedParallelQuery{TSource} whose elements are 
            sorted according to a key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>
            Performs in parallel a subsequent ordering of the elements in a sequence in 
            ascending order by using a specified comparer.
            </summary>
      <remarks>
            In contrast to the sequential implementation, this is not a stable sort.
            See the remarks for OrderBy(ParallelQuery{TSource}, Func{TSource,TKey}) for 
            an approach to implementing a stable sort.
            </remarks>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">An OrderedParallelQuery{TSource} that contains 
            elements to sort.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <param name="comparer">An IComparer{TKey} to compare keys.</param>
      <returns>An OrderedParallelQuery{TSource} whose elements are sorted 
            according to a key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1})">
      <summary>
            Performs in parallel a subsequent ordering of the elements in a sequence in 
            descending order, according to a key.
            </summary>
      <remarks>
            In contrast to the sequential implementation, this is not a stable sort.
            See the remarks for OrderBy(ParallelQuery{TSource}, Func{TSource,TKey}) for 
            an approach to implementing a stable sort.
            </remarks>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">An OrderedParallelQuery{TSource} than contains 
            elements to sort.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <returns>An OrderedParallelQuery{TSource} whose elements are sorted 
            descending according to a key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>
            Performs in parallel a subsequent ordering of the elements in a sequence in descending 
            order by using a specified comparer.
            </summary>
      <remarks>
            In contrast to the sequential implementation, this is not a stable sort.
            See the remarks for OrderBy(ParallelQuery{TSource}, Func{TSource,TKey}) for 
            an approach to implementing a stable sort.
            </remarks>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">An OrderedParallelQuery{TSource} than contains 
            elements to sort.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <param name="comparer">An IComparer{TKey} to compare keys.</param>
      <returns>An OrderedParallelQuery{TSource} whose elements are sorted 
            descending according to a key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})">
      <summary>
            Groups in parallel the elements of a sequence according to a specified key selector function.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">An OrderedParallelQuery{TSource}than contains 
            elements to sort.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <returns>An OrderedParallelQuery{TSource}whose elements are sorted 
            descending according to a key.</returns>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Groups in parallel the elements of a sequence according to a specified key selector function and compares the keys by using a specified comparer.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />&gt;.</typeparam>
      <param name="source">An OrderedParallelQuery{TSource} than contains 
            elements to sort.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <param name="comparer">An IComparer{TSource} to compare keys.</param>
      <returns>An OrderedParallelQuery{TSource} whose elements are sorted 
            descending according to a key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})">
      <summary>
            Groups in parallel the elements of a sequence according to a specified key selector function and 
            projects the elements for each group by using a specified function.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">The type of the elements in the IGrouping</typeparam>
      <param name="source">An OrderedParallelQuery&lt;(Of &lt;(TElement&gt;)&gt;) than contains 
            elements to sort.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <param name="elementSelector">A function to map each source element to an element in an  IGrouping.</param>
      <returns>A ParallelQuery&lt;IGrouping&lt;TKey, TElement&gt;&gt; in C# or 
            ParallelQuery(Of IGrouping(Of TKey, TElement)) in Visual Basic where each IGrouping 
            generic object contains a collection of objects of type <typeparamref name="TElement" /> and a key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> or
            <paramref name="elementSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Groups in parallel the elements of a sequence according to a key selector function. 
            The keys are compared by using a comparer and each group's elements are projected by 
            using a specified function.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">The type of the elements in the IGrouping</typeparam>
      <param name="source">An OrderedParallelQuery{TSource}than contains elements to sort.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <param name="elementSelector">A function to map each source element to an element in an  IGrouping.</param>
      <param name="comparer">An IComparer{TSource} to compare keys.</param>
      <returns>
            A ParallelQuery{IGrouping{TKey, TElement}} in C# or 
            ParallelQuery(Of IGrouping(Of TKey, TElement)) in Visual Basic where each IGrouping 
            generic object contains a collection of objects of type <typeparamref name="TElement" /> and a key.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> or
            <paramref name="elementSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})">
      <summary>
            Groups in parallel the elements of a sequence according to a specified 
            key selector function and creates a result value from each group and its key.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
      <param name="source">A sequence whose elements to group.</param>
      <param name="keySelector">A function to extract the key for each element.</param>
      <param name="resultSelector">A function to create a result value from each group.</param>
      <returns>A collection of elements of type <typeparamref name="TResult" /> where each element represents a 
            projection over a group and its key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> or
            <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Groups in parallel the elements of a sequence according to a specified key selector function 
            and creates a result value from each group and its key. The keys are compared 
            by using a specified comparer.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
      <param name="source">A sequence whose elements to group.</param>
      <param name="keySelector">A function to extract the key for each element.</param>
      <param name="resultSelector">A function to create a result value from each group.</param>
      <param name="comparer">An IEqualityComparer{TKey} to compare keys.</param>
      <returns>
            An <B>ParallelQuery&lt;IGrouping&lt;TKey, TResult&gt;&gt;</B> in C# or 
            <B>ParallelQuery(Of IGrouping(Of TKey, TResult))</B> in Visual Basic where each 
            IGrouping&lt;(Of &lt;(TKey, TResult&gt;)&gt;) object contains a collection of objects 
            of type <typeparamref name="TResult" /> and a key.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> or
            <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})">
      <summary>
            Groups in parallel the elements of a sequence according to a specified key 
            selector function and creates a result value from each group and its key. 
            The elements of each group are projected by using a specified function.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">The type of the elements in each 
            IGrouping{TKey, TElement}.</typeparam>
      <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
      <param name="source">A sequence whose elements to group.</param>
      <param name="keySelector">A function to extract the key for each element.</param>
      <param name="elementSelector">A function to map each source element to an element in an 
            IGrouping&lt;TKey, TElement&gt;.</param>
      <param name="resultSelector">A function to create a result value from each group.</param>
      <returns>A collection of elements of type <typeparamref name="TElement" /> where each element represents a 
            projection over a group and its key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> or
            <paramref name="elementSelector" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Groups the elements of a sequence according to a specified key selector function and 
            creates a result value from each group and its key. Key values are compared by using a 
            specified comparer, and the elements of each group are projected by using a specified function.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">The type of the elements in each 
            IGrouping{TKey, TElement}.</typeparam>
      <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
      <param name="source">A sequence whose elements to group.</param>
      <param name="keySelector">A function to extract the key for each element.</param>
      <param name="elementSelector">A function to map each source element to an element in an 
            IGrouping{Key, TElement}.</param>
      <param name="resultSelector">A function to create a result value from each group.</param>
      <param name="comparer">An IEqualityComparer{TKey} to compare keys.</param>
      <returns>A collection of elements of type <typeparamref name="TResult" /> where each element represents a 
            projection over a group and its key.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> or
            <paramref name="elementSelector" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.PerformSequentialAggregation``2(System.Linq.ParallelQuery{``0},``1,System.Boolean,System.Func{``1,``0,``1})">
      <summary>
            Run an aggregation sequentially. If the user-provided reduction function throws an exception, wrap
            it with an AggregateException.
            </summary>
      <param name="source">
      </param>
      <param name="seed">
      </param>
      <param name="seedIsSpecified">
            if true, use the seed provided in the method argument
            if false, use the first element of the sequence as the seed instead
            </param>
      <param name="func">
      </param>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Aggregate``1(System.Linq.ParallelQuery{``0},System.Func{``0,``0,``0})">
      <summary>
            Applies in parallel an accumulator function over a sequence.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence to aggregate over.</param>
      <param name="func">An accumulator function to be invoked on each element.</param>
      <returns>The final accumulator value.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="func" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Aggregate``2(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1})">
      <summary>
            Applies in parallel an accumulator function over a sequence. 
            The specified seed value is used as the initial accumulator value.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
      <param name="source">A sequence to aggregate over.</param>
      <param name="seed">The initial accumulator value.</param>
      <param name="func">An accumulator function to be invoked on each element.</param>
      <returns>The final accumulator value.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="func" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
      <summary>
            Applies in parallel an accumulator function over a sequence. The specified 
            seed value is used as the initial accumulator value, and the specified 
            function is used to select the result value.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
      <typeparam name="TResult">The type of the resulting value.</typeparam>
      <param name="source">A sequence to aggregate over.</param>
      <param name="seed">The initial accumulator value.</param>
      <param name="func">An accumulator function to be invoked on each element.</param>
      <param name="resultSelector">A function to transform the final accumulator value 
            into the result value.</param>
      <returns>The transformed final accumulator value.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="func" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})">
      <summary>
            Applies in parallel an accumulator function over a sequence. This overload is not
            available in the sequential implementation.
            </summary>
      <remarks>
            This overload is specific to processing a parallelized query. A parallelized query may 
            partition the data source sequence into several sub-sequences (partitions). 
            The <paramref name="updateAccumulatorFunc" /> is invoked on each element within partitions. 
            Each partition then yields a single accumulated result. The <paramref name="combineAccumulatorsFunc" />
            is then invoked on the results of each partition to yield a single element. This element is then
            transformed by the <paramref name="resultSelector" /> function.
            </remarks>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
      <typeparam name="TResult">The type of the resulting value.</typeparam>
      <param name="source">A sequence to aggregate over.</param>
      <param name="seed">The initial accumulator value.</param>
      <param name="updateAccumulatorFunc">
            An accumulator function to be invoked on each element in a partition.
            </param>
      <param name="combineAccumulatorsFunc">
            An accumulator function to be invoked on the yielded element from each partition.
            </param>
      <param name="resultSelector">
            A function to transform the final accumulator value into the result value.
            </param>
      <returns>The transformed final accumulator value.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="updateAccumulatorFunc" /> 
            or <paramref name="combineAccumulatorsFunc" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},System.Func{``1},System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})">
      <summary>
            Applies in parallel an accumulator function over a sequence.  This overload is not
            available in the sequential implementation.
            </summary>
      <remarks>
            This overload is specific to parallelized queries. A parallelized query may partition the data source sequence
            into several sub-sequences (partitions). The <paramref name="updateAccumulatorFunc" /> is invoked 
            on each element within partitions. Each partition then yields a single accumulated result. 
            The <paramref name="combineAccumulatorsFunc" />
            is then invoked on the results of each partition to yield a single element. This element is then
            transformed by the <paramref name="resultSelector" /> function.
            </remarks>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
      <typeparam name="TResult">The type of the resulting value.</typeparam>
      <param name="source">A sequence to aggregate over.</param>
      <param name="seedFactory">
            A function that returns the initial accumulator value.
            </param>
      <param name="updateAccumulatorFunc">
            An accumulator function to be invoked on each element in a partition.
            </param>
      <param name="combineAccumulatorsFunc">
            An accumulator function to be invoked on the yielded element from each partition. 
            </param>
      <param name="resultSelector">
            A function to transform the final accumulator value into the result value.
            </param>
      <returns>The transformed final accumulator value.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="seedFactory" /> or <paramref name="updateAccumulatorFunc" /> 
            or <paramref name="combineAccumulatorsFunc" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns the number of elements in a parallel sequence.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence that contains elements to be counted.</param>
      <returns>The number of elements in the input sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The number of elements in source is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Returns a number that represents how many elements in the specified 
            parallel sequence satisfy a condition.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence that contains elements to be counted.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>
            A number that represents how many elements in the sequence satisfy the condition 
            in the predicate function.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The number of elements in source is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns an Int64 that represents the total number of elements in a parallel sequence.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence that contains elements to be counted.</param>
      <returns>The number of elements in the input sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The number of elements in source is larger than <see cref="M:System.Int64.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Returns an Int64 that represents how many elements in a parallel sequence satisfy a condition.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence that contains elements to be counted.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>
            A number that represents how many elements in the sequence satisfy the condition 
            in the predicate function.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The number of elements in source is larger than <see cref="M:System.Int64.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Int32})">
      <summary>
            Computes in parallel the sum of a sequence of values.
            </summary>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Int32}})">
      <summary>
            Computes in parallel the sum of a sequence of values.
            </summary>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Int64})">
      <summary>
            Computes in parallel the sum of a sequence of values.
            </summary>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Int64.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Int64}})">
      <summary>
            Computes in parallel the sum of a sequence of values.
            </summary>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Int64.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Single})">
      <summary>
            Computes in parallel the sum of a sequence of values.
            </summary>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Single}})">
      <summary>
            Computes in parallel the sum of a sequence of values.
            </summary>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Double})">
      <summary>
            Computes in parallel the sum of a sequence of values.
            </summary>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Double}})">
      <summary>
            Computes in parallel the sum of a sequence of values.
            </summary>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Decimal})">
      <summary>
            Computes in parallel the sum of a sequence of values.
            </summary>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Decimal.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})">
      <summary>
            Computes in parallel the sum of a sequence of values.
            </summary>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Decimal.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})">
      <summary>
            Computes in parallel the sum of the sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>
            Computes in parallel the sum of the sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})">
      <summary>
            Computes in parallel the sum of the sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Int64.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>
            Computes in parallel the sum of the sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Int64.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})">
      <summary>
            Computes in parallel the sum of the sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>
            Computes in parallel the sum of the sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})">
      <summary>
            Computes in parallel the sum of the sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>
            Computes in parallel the sum of the sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})">
      <summary>
            Computes in parallel the sum of the sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Decimal.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>
            Computes in parallel the sum of the sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The sum of the values in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum is larger than <see cref="M:System.Decimal.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Int32})">
      <summary>
            Returns the minimum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Int32}})">
      <summary>
            Returns the minimum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Int64})">
      <summary>
            Returns the minimum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Int64}})">
      <summary>
            Returns the minimum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Single})">
      <summary>
            Returns the minimum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Single}})">
      <summary>
            Returns the minimum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Double})">
      <summary>
            Returns the minimum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Double}})">
      <summary>
            Returns the minimum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Decimal})">
      <summary>
            Returns the minimum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})">
      <summary>
            Returns the minimum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns the minimum value in a parallel sequence of values.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements and <typeparamref name="TSource" /> is a non-nullable value type.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the minimum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the minimum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the minimum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the minimum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the minimum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the minimum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the minimum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the minimum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the minimum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the minimum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Min``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the minimum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TResult">The type of the value returned by <paramref name="selector" />.</typeparam>
      <param name="source">A sequence of values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The minimum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements and <typeparamref name="TResult" /> is a non-nullable value type.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Int32})">
      <summary>
            Returns the maximum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Int32}})">
      <summary>
            Returns the maximum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Int64})">
      <summary>
            Returns the maximum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Int64}})">
      <summary>
            Returns the maximum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Single})">
      <summary>
            Returns the maximum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Single}})">
      <summary>
            Returns the maximum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Double})">
      <summary>
            Returns the maximum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Double}})">
      <summary>
            Returns the maximum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Decimal})">
      <summary>
            Returns the maximum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})">
      <summary>
            Returns the maximum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns the maximum value in a parallel sequence of values.
            </summary>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements and <typeparam name="TSource" /> is a non-nullable value type.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the maximum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the maximum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the maximum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the maximum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the maximum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the maximum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the maximum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the maximum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the maximum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the maximum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Max``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})">
      <summary>
            Invokes in parallel a transform function on each element of a 
            sequence and returns the maximum value.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TResult">The type of the value returned by <paramref name="selector" />.</typeparam>
      <param name="source">A sequence of values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The maximum value in the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements and <typeparamref name="TResult" /> is a non-nullable value type.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Int32})">
      <summary>
            Computes in parallel the average of a sequence of values.
            </summary>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            The sum or count of the elements in the sequence is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Int32}})">
      <summary>
            Computes in parallel the average of a sequence of values.
            </summary>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum or count of the elements in the sequence is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Int64})">
      <summary>
            Computes in parallel the average of a sequence of values.
            </summary>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            The sum or count of the elements in the sequence is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Int64}})">
      <summary>
            Computes in parallel the average of a sequence of values.
            </summary>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum or count of the elements in the sequence is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Single})">
      <summary>
            Computes in parallel the average of a sequence of values.
            </summary>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Single}})">
      <summary>
            Computes in parallel the average of a sequence of values.
            </summary>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Double})">
      <summary>
            Computes in parallel the average of a sequence of values.
            </summary>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Double}})">
      <summary>
            Computes in parallel the average of a sequence of values.
            </summary>
      <exception cref="T:System.ArgumentNullException">
        <param name="source">A sequence of values that are used to calculate an average.</param>
        <returns>The average of the sequence of values.</returns>
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Decimal})">
      <summary>
            Computes in parallel the average of a sequence of values.
            </summary>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})">
      <summary>
            Computes in parallel the average of a sequence of values.
            </summary>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})">
      <summary>
            Computes in parallel the average of a sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            The sum or count of the elements in the sequence is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>
            Computes in parallel the average of a sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum or count of the elements in the sequence is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})">
      <summary>
            Computes in parallel the average of a sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            The sum or count of the elements in the sequence is larger than <see cref="M:System.Int32.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>
            Computes in parallel the average of a sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            The sum or count of the elements in the sequence is larger than <see cref="M:System.Int64.MaxValue" />.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})">
      <summary>
            Computes in parallel the average of a sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>
            Computes in parallel the average of a sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})">
      <summary>
            Computes in parallel the average of a sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>
            Computes in parallel the average of a sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})">
      <summary>
            Computes in parallel the average of a sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>
            Computes in parallel the average of a sequence of values that are obtained 
            by invoking a transform function on each element of the input sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values that are used to calculate an average.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>The average of the sequence of values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Determines in parallel whether any element of a sequence satisfies a condition.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">An IEnumerable whose elements to apply the predicate to.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>
            true if any elements in the source sequence pass the test in the specified predicate; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Determines whether a parallel sequence contains any elements.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">The IEnumerable to check for emptiness.</param>
      <returns>true if the source sequence contains any elements; otherwise, false.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.All``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Determines in parallel whether all elements of a sequence satisfy a condition.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence whose elements to apply the predicate to.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>
            true if all elements in the source sequence pass the test in the specified predicate; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.ParallelQuery{``0},``0)">
      <summary>
            Determines in parallel whether a sequence contains a specified element 
            by using the default equality comparer.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence in which to locate a value.</param>
      <param name="value">The value to locate in the sequence.</param>
      <returns>
            true if the source sequence contains an element that has the specified value; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.ParallelQuery{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines in parallel whether a sequence contains a specified element by using a 
            specified IEqualityComparer{T}.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence in which to locate a value.</param>
      <param name="value">The value to locate in the sequence.</param>
      <param name="comparer">An equality comparer to compare values.</param>
      <returns>
            true if the source sequence contains an element that has the specified value; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Take``1(System.Linq.ParallelQuery{``0},System.Int32)">
      <summary>
            Returns a specified number of contiguous elements from the start of a parallel sequence.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return elements from.</param>
      <param name="count">The number of elements to return.</param>
      <returns>
            A sequence that contains the specified number of elements from the start of the input sequence.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Returns elements from a parallel sequence as long as a specified condition is true.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return elements from.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>
            A sequence that contains the elements from the input sequence that occur before 
            the element at which the test no longer passes.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})">
      <summary>
            Returns elements from a parallel sequence as long as a specified condition is true. 
            The element's index is used in the logic of the predicate function.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return elements from.</param>
      <param name="predicate">
            A function to test each source element for a condition; the second parameter of the 
            function represents the index of the source element.
            </param>
      <returns>
            A sequence that contains elements from the input sequence that occur before 
            the element at which the test no longer passes.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Skip``1(System.Linq.ParallelQuery{``0},System.Int32)">
      <summary>
            Bypasses a specified number of elements in a parallel sequence and then returns the remaining elements.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return elements from.</param>
      <param name="count">The number of elements to skip before returning the remaining elements.</param>
      <returns>
            A sequence that contains the elements that occur after the specified index in the input sequence.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Bypasses elements in a parallel sequence as long as a specified 
            condition is true and then returns the remaining elements.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return elements from.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>A sequence that contains the elements from the input sequence starting at 
            the first element in the linear series that does not pass the test specified by 
            <B>predicate</B>.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})">
      <summary>
            Bypasses elements in a parallel sequence as long as a specified condition is true and 
            then returns the remaining elements. The element's index is used in the logic of 
            the predicate function.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return elements from.</param>
      <param name="predicate">
            A function to test each source element for a condition; the 
            second parameter of the function represents the index of the source element.
            </param>
      <returns>
            A sequence that contains the elements from the input sequence starting at the 
            first element in the linear series that does not pass the test specified by 
            <B>predicate</B>.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Concat``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})">
      <summary>
            Concatenates two parallel sequences.
            </summary>
      <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
      <param name="first">The first sequence to concatenate.</param>
      <param name="second">The sequence to concatenate to the first sequence.</param>
      <returns>A sequence that contains the concatenated elements of the two input sequences.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Concat``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            This Concat overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.
            </summary>
      <typeparam name="TSource">This type parameter is not used.</typeparam>
      <param name="first">This parameter is not used.</param>
      <param name="second">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of Concat with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the Concat operator would appear to be binding to the parallel implementation, 
            but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})">
      <summary>
            Determines whether two parallel sequences are equal by comparing the elements by using 
            the default equality comparer for their type.
            </summary>
      <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
      <param name="first">A sequence to compare to <b>second</b>.</param>
      <param name="second">A sequence to compare to the first input sequence.</param>
      <returns>
            true if the two source sequences are of equal length and their corresponding elements 
            are equal according to the default equality comparer for their type; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            This SequenceEqual overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.
            </summary>
      <typeparam name="TSource">This type parameter is not used.</typeparam>
      <param name="first">This parameter is not used.</param>
      <param name="second">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">Thrown every time this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of SequenceEqual with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the SequenceEqual operator would appear to be binding to the parallel implementation, 
            but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines whether two parallel sequences are equal by comparing their elements by 
            using a specified IEqualityComparer{T}.
            </summary>
      <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
      <param name="first">A sequence to compare to <paramref name="second" />.</param>
      <param name="second">A sequence to compare to the first input sequence.</param>
      <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to use to compare elements.</param>
      <returns>
            true if the two source sequences are of equal length and their corresponding 
            elements are equal according to the default equality comparer for their type; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.DisposeEnumerator``1(System.Collections.Generic.IEnumerator{``0},System.Linq.Parallel.CancellationState)">
      <summary>
            A helper method for SequenceEqual to dispose an enumerator. If an exception is thrown by the disposal, 
            it gets wrapped into an AggregateException, unless it is an OCE with the query's CancellationToken.
            </summary>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            This SequenceEqual overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.
            </summary>
      <typeparam name="TSource">This type parameter is not used.</typeparam>
      <param name="first">This parameter is not used.</param>
      <param name="second">This parameter is not used.</param>
      <param name="comparer">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">Thrown every time this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of SequenceEqual with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the SequenceEqual operator would appear to be binding to the parallel implementation, 
            but would in reality bind to sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns distinct elements from a parallel sequence by using the 
            default equality comparer to compare values.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to remove duplicate elements from.</param>
      <returns>A sequence that contains distinct elements from the source sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Returns distinct elements from a parallel sequence by using a specified 
            IEqualityComparer{T} to compare values.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to remove duplicate elements from.</param>
      <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare values.</param>
      <returns>A sequence that contains distinct elements from the source sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})">
      <summary>
            Produces the set union of two parallel sequences by using the default equality comparer.
            </summary>
      <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
      <param name="first">A sequence whose distinct elements form the first set for the union.</param>
      <param name="second">A sequence whose distinct elements form the second set for the union.</param>
      <returns>A sequence that contains the elements from both input sequences, excluding duplicates.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            This Union overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.
            </summary>
      <typeparam name="TSource">This type parameter is not used.</typeparam>
      <param name="first">This parameter is not used.</param>
      <param name="second">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of Union with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the Union operator would appear to be binding to the parallel implementation, 
            but would in reality bind to sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Produces the set union of two parallel sequences by using a specified IEqualityComparer{T}.
            </summary>
      <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
      <param name="first">A sequence whose distinct elements form the first set for the union.</param>
      <param name="second">A sequence whose distinct elements form the second set for the union.</param>
      <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare values.</param>
      <returns>A sequence that contains the elements from both input sequences, excluding duplicates.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            This Union overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.
            </summary>
      <typeparam name="TSource">This type parameter is not used.</typeparam>
      <param name="first">This parameter is not used.</param>
      <param name="second">This parameter is not used.</param>
      <param name="comparer">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of Union with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the Union operator would appear to be binding to the parallel implementation, 
            but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})">
      <summary>
            Produces the set intersection of two parallel sequences by using the 
            default equality comparer to compare values.
            </summary>
      <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
      <param name="first">A sequence whose distinct elements that also appear in <paramref name="second" /> will be returned.
            </param>
      <param name="second">
            A sequence whose distinct elements that also appear in the first sequence will be returned.
            </param>
      <returns>A sequence that contains the elements that form the set intersection of two sequences.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            This Intersect overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.
            </summary>
      <typeparam name="TSource">This type parameter is not used.</typeparam>
      <param name="first">This parameter is not used.</param>
      <param name="second">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of Intersect with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the Intersect operator would appear to be binding to the parallel implementation, 
            but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Produces the set intersection of two parallel sequences by using 
            the specified IEqualityComparer{T} to compare values.
            </summary>
      <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
      <param name="first">
            A sequence whose distinct elements that also appear in <paramref name="second" /> will be returned.
            </param>
      <param name="second">
            A sequence whose distinct elements that also appear in the first sequence will be returned.
            </param>
      <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare values.</param>
      <returns>A sequence that contains the elements that form the set intersection of two sequences.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            This Intersect overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.
            </summary>
      <typeparam name="TSource">This type parameter is not used.</typeparam>
      <param name="first">This parameter is not used.</param>
      <param name="second">This parameter is not used.</param>
      <param name="comparer">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of Intersect with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the Intersect operator would appear to be binding to the parallel implementation, 
            but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})">
      <summary>
            Produces the set difference of two parallel sequences by using 
            the default equality comparer to compare values.
            </summary>
      <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
      <param name="first">
            A sequence whose elements that are not also in <paramref name="second" /> will be returned.
            </param>
      <param name="second">
            A sequence whose elements that also occur in the first sequence will cause those 
            elements to be removed from the returned sequence.
            </param>
      <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            This Except overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.
            </summary>
      <typeparam name="TSource">This type parameter is not used.</typeparam>
      <param name="first">This parameter is not used.</param>
      <param name="second">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of Except with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the Except operator would appear to be binding to the parallel implementation, 
            but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Produces the set difference of two parallel sequences by using the 
            specified IEqualityComparer{T} to compare values.
            </summary>
      <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
      <param name="first">A sequence whose elements that are not also in <paramref name="second" /> will be returned.</param>
      <param name="second">
            A sequence whose elements that also occur in the first sequence will cause those elements 
            to be removed from the returned sequence.
            </param>
      <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare values.</param>
      <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            This Except overload should never be called. 
            This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.
            </summary>
      <typeparam name="TSource">This type parameter is not used.</typeparam>
      <param name="first">This parameter is not used.</param>
      <param name="second">This parameter is not used.</param>
      <param name="comparer">This parameter is not used.</param>
      <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
      <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
      <remarks>
            This overload exists to disallow usage of Except with a left data source of type
            <see cref="T:System.Linq.ParallelQuery`1" /> and a right data source of type <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Otherwise, the Except operator would appear to be binding to the parallel implementation, 
            but would in reality bind to the sequential implementation.
            </remarks>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.AsEnumerable``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Converts a <see cref="T:System.Linq.ParallelQuery`1" /> into an 
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> to force sequential
            evaluation of the query.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to type as <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <returns>The input sequence types as <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ToArray``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Creates an array from a ParallelQuery{T}.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence to create an array from.</param>
      <returns>An array that contains the elements from the input sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ToList``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Creates a List{T} from an ParallelQuery{T}.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence to create a List&lt;(Of &lt;(T&gt;)&gt;) from.</param>
      <returns>A List&lt;(Of &lt;(T&gt;)&gt;) that contains elements from the input sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})">
      <summary>
            Creates a Dictionary{TKey,TValue} from a ParallelQuery{T} according to 
            a specified key selector function.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">A sequence to create a Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) from.</param>
      <param name="keySelector">A function to extract a key from each element.</param>
      <returns>A Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) that contains keys and values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
        <paramref name="keySelector" /> produces a key that is a null reference (Nothing in Visual Basic).
            -or-
            <paramref name="keySelector" /> produces duplicate keys for two elements.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Creates a Dictionary{TKey,TValue} from a ParallelQuery{T} according to a 
            specified key selector function and key comparer.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">A sequence to create a Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) from.</param>
      <param name="keySelector">A function to extract a key from each element.</param>
      <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
      <returns>A Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) that contains keys and values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
        <paramref name="keySelector" /> produces a key that is a null reference (Nothing in Visual Basic).
            -or-
            <paramref name="keySelector" /> produces duplicate keys for two elements.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})">
      <summary>
            Creates a Dictionary{TKey,TValue} from a ParallelQuery{T} according to specified 
            key selector and element selector functions.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
      <param name="source">A sequence to create a Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) from.</param>
      <param name="keySelector">A function to extract a key from each element.</param>
      <param name="elementSelector">
            A transform function to produce a result element value from each element.
            </param>
      <returns>
            A Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) that contains values of type <typeparamref name="TElement" /> 
            selected from the input sequence
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
        <paramref name="keySelector" /> produces a key that is a null reference (Nothing in Visual Basic).
            -or-
            <paramref name="keySelector" /> produces duplicate keys for two elements.
            -or- 
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Creates a Dictionary{TKey,TValue from a ParallelQuery{T} according to a 
            specified key selector function, a comparer, and an element selector function.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
      <param name="source">A sequence to create a Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) from.</param>
      <param name="keySelector">A function to extract a key from each element.</param>
      <param name="elementSelector">A transform function to produce a result element 
            value from each element.</param>
      <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
      <returns>
            A Dictionary&lt;(Of &lt;(TKey, TValue&gt;)&gt;) that contains values of type <typeparamref name="TElement" /> 
            selected from the input sequence
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
        <paramref name="keySelector" /> produces a key that is a null reference (Nothing in Visual Basic).
            -or-
            <paramref name="keySelector" /> produces duplicate keys for two elements.
            -or-
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})">
      <summary>
            Creates an ILookup{TKey,T} from a ParallelQuery{T} according to a specified key selector function.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">The sequence to create a Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) from.</param>
      <param name="keySelector">A function to extract a key from each element.</param>
      <returns>A Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) that contains keys and values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Creates an ILookup{TKey,T} from a ParallelQuery{T} according to a specified 
            key selector function and key comparer.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <param name="source">The sequence to create a Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) from.</param>
      <param name="keySelector">A function to extract a key from each element.</param>
      <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
      <returns>A Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) that contains keys and values.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> or is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})">
      <summary>
            Creates an ILookup{TKey,TElement} from a ParallelQuery{T} according to specified 
            key selector and element selector functions.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
      <param name="source">The sequence to create a Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) from.</param>
      <param name="keySelector">A function to extract a key from each element.</param>
      <param name="elementSelector">
            A transform function to produce a result element value from each element.
            </param>
      <returns>
            A Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) that contains values of type TElement 
            selected from the input sequence.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>
            Creates an ILookup{TKey,TElement} from a ParallelQuery{T} according to 
            a specified key selector function, a comparer and an element selector function.
            </summary>
      <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
      <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
      <param name="source">The sequence to create a Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) from.</param>
      <param name="keySelector">A function to extract a key from each element.</param>
      <param name="elementSelector">
            A transform function to produce a result element value from each element.
            </param>
      <param name="comparer">An IEqualityComparer&lt;(Of &lt;(T&gt;)&gt;) to compare keys.</param>
      <returns>
            A Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) that contains values of type TElement selected 
            from the input sequence.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Reverse``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Inverts the order of the elements in a parallel sequence.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence of values to reverse.</param>
      <returns>A sequence whose elements correspond to those of the input sequence in reverse order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.OfType``1(System.Linq.ParallelQuery)">
      <summary>
            Filters the elements of a ParallelQuery based on a specified type.
            </summary>
      <typeparam name="TResult">The type to filter the elements of the sequence on.</typeparam>
      <param name="source">The sequence whose elements to filter.</param>
      <returns>A sequence that contains elements from the input sequence of type <typeparamref name="TResult" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Cast``1(System.Linq.ParallelQuery)">
      <summary>
            Converts the elements of a ParallelQuery to the specified type.
            </summary>
      <typeparam name="TResult">The type to convert the elements of <paramref name="source" /> to.</typeparam>
      <param name="source">The sequence that contains the elements to be converted.</param>
      <returns>
            A sequence that contains each element of the source sequence converted to the specified type.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.First``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns the first element of a parallel sequence.</summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return the first element of.</param>
      <returns>The first element in the specified sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.First``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Returns the first element in a parallel sequence that satisfies a specified condition.
            </summary>
      <remarks>There's a temporary difference from LINQ to Objects, this does not throw
            ArgumentNullException when the predicate is null.</remarks>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return an element from.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>The first element in the sequence that passes the test in the specified predicate function.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
            No element in <paramref name="source" /> satisfies the condition in <paramref name="predicate" />.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns the first element of a parallel sequence, or a default value if the 
            sequence contains no elements.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return the first element of.</param>
      <returns>
            default(<B>TSource</B>) if <paramref name="source" /> is empty; otherwise, the first element in <paramref name="source" />.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Returns the first element of the parallel sequence that satisfies a condition or a 
            default value if no such element is found.
            </summary>
      <remarks>There's a temporary difference from LINQ to Objects, this does not throw
            ArgumentNullException when the predicate is null.</remarks>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return an element from.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>
            default(<B>TSource</B>) if <paramref name="source" /> is empty or if no element passes the test 
            specified by <B>predicate</B>; otherwise, the first element in <paramref name="source" /> that 
            passes the test specified by <B>predicate</B>.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns the last element of a parallel sequence.</summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return the last element from.</param>
      <returns>The value at the last position in the source sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> contains no elements.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Returns the last element of a parallel sequence that satisfies a specified condition.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return an element from.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>
            The last element in the sequence that passes the test in the specified predicate function.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
            No element in <paramref name="source" /> satisfies the condition in <paramref name="predicate" />.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns the last element of a parallel sequence, or a default value if the 
            sequence contains no elements.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return an element from.</param>
      <returns>
            default(<typeparamref name="TSource" />) if the source sequence is empty; otherwise, the last element in the sequence.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Returns the last element of a parallel sequence that satisfies a condition, or 
            a default value if no such element is found.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return an element from.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>
            default(<typeparamref name="TSource" />) if the sequence is empty or if no elements pass the test in the 
            predicate function; otherwise, the last element that passes the test in the predicate function.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns the only element of a parallel sequence, and throws an exception if there is not 
            exactly one element in the sequence.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return the single element of.</param>
      <returns>The single element of the input sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
            The input sequence contains more than one element. -or- The input sequence is empty.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Returns the only element of a parallel sequence that satisfies a specified condition, 
            and throws an exception if more than one such element exists.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return the single element of.</param>
      <param name="predicate">A function to test an element for a condition.</param>
      <returns>The single element of the input sequence that satisfies a condition.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.InvalidOperationException">
            No element satisfies the condition in <paramref name="predicate" />. -or- More than one element satisfies the condition in <paramref name="predicate" />.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns the only element of a parallel sequence, or a default value if the sequence is 
            empty; this method throws an exception if there is more than one element in the sequence.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return the single element of.</param>
      <returns>
            The single element of the input sequence, or default(<typeparamref name="TSource" />) if the 
            sequence contains no elements.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})">
      <summary>
            Returns the only element of a parallel sequence that satisfies a specified condition 
            or a default value if no such element exists; this method throws an exception 
            if more than one element satisfies the condition.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return the single element of.</param>
      <param name="predicate">A function to test an element for a condition.</param>
      <returns>
            The single element of the input sequence that satisfies the condition, or 
            default(<typeparamref name="TSource" />) if no such element is found.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.ParallelQuery{``0})">
      <summary>
            Returns the elements of the specified parallel sequence or the type parameter's 
            default value in a singleton collection if the sequence is empty.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return a default value for if it is empty.</param>
      <returns>
            A sequence that contains default(<B>TSource</B>) if <paramref name="source" /> is empty; otherwise, <paramref name="source" />.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.ParallelQuery{``0},``0)">
      <summary>
            Returns the elements of the specified parallel sequence or the specified value 
            in a singleton collection if the sequence is empty.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">The sequence to return the specified value for if it is empty.</param>
      <param name="defaultValue">The value to return if the sequence is empty.</param>
      <returns>
            A sequence that contains <B>defaultValue</B> if <paramref name="source" /> is empty; otherwise, <paramref name="source" />.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ElementAt``1(System.Linq.ParallelQuery{``0},System.Int32)">
      <summary>
            Returns the element at a specified index in a parallel sequence.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence to return an element from.</param>
      <param name="index">The zero-based index of the element to retrieve.</param>
      <returns>The element at the specified position in the source sequence.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than 0 or greater than or equal to the number of elements in <paramref name="source" />.
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="M:System.Linq.ParallelEnumerable.ElementAtOrDefault``1(System.Linq.ParallelQuery{``0},System.Int32)">
      <summary>
            Returns the element at a specified index in a parallel sequence or a default value if the 
            index is out of range.
            </summary>
      <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
      <param name="source">A sequence to return an element from.</param>
      <param name="index">The zero-based index of the element to retrieve.</param>
      <returns>
            default(<B>TSource</B>) if the index is outside the bounds of the source sequence; 
            otherwise, the element at the specified position in the source sequence.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is a null reference (Nothing in Visual Basic).
            </exception>
      <exception cref="T:System.AggregateException">
            One or more exceptions occurred during the evaluation of the query.
            </exception>
      <exception cref="T:System.OperationCanceledException">
            The query was canceled.
            </exception>
    </member>
    <member name="T:System.Linq.ParallelMergeOptions">
      <summary>
            Specifies the preferred type of output merge to use in a query. This is a hint only, and may not be
            respected by the system when parallelizing all queries.
            </summary>
      <remarks>
        <para>
            Use <b>NotBuffered</b> for queries that will be consumed and output as streams, this has the lowest latency
            between beginning query execution and elements being yielded. For some queries, such as those involving a 
            sort (OrderBy, OrderByDescending), buffering is essential and a hint of NotBuffered or AutoBuffered will 
            be ignored.
            </para>
        <para>
            Use <b>AutoBuffered</b> for most cases; this is the default.  It strikes a balance between latency and
            overall performance.
            </para>
        <para>
            Use <b>FullyBuffered</b> for queries when the entire output can be processed before the information is 
            needed. This option offers the best performance when all of the output can be accumulated before yielding
            any information, though it is not suitable for stream processing or showing partial results mid-query.
            </para>
      </remarks>
    </member>
    <member name="F:System.Linq.ParallelMergeOptions.Default">
      <summary>
            Use the default merge type, which is AutoBuffered.
            </summary>
    </member>
    <member name="F:System.Linq.ParallelMergeOptions.NotBuffered">
      <summary>
            Use a merge without output buffers. As soon as result elements have been computed, 
            make that element available to the consumer of the query.
            </summary>
    </member>
    <member name="F:System.Linq.ParallelMergeOptions.AutoBuffered">
      <summary>
            Use a merge with output buffers of a size chosen by the system. Results
            will accumulate into an output buffer before they are available to the consumer of
            the query.
            </summary>
    </member>
    <member name="F:System.Linq.ParallelMergeOptions.FullyBuffered">
      <summary>
            Use a merge with full output buffers. The system will accumulate all of the
            results before making any of them available to the consumer of the query.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.AsynchronousChannel`1">
      <summary>
            This is a bounded channel meant for single-producer/single-consumer scenarios. 
            </summary>
      <typeparam name="T">Specifies the type of data in the channel.</typeparam>
    </member>
    <member name="T:System.Linq.Parallel.SynchronousChannel`1">
      <summary>
             The simplest channel is one that has no synchronization.  This is used for stop-
             and-go productions where we are guaranteed the consumer is not running
             concurrently. It just wraps a FIFO queue internally.
            
             Assumptions:
                 Producers and consumers never try to enqueue/dequeue concurrently.
             </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.ParallelQuery">
      <summary>
            Represents a parallel sequence.
            </summary>
    </member>
    <member name="T:System.Linq.ParallelQuery`1">
      <summary>
            Represents a parallel sequence.
            </summary>
    </member>
    <member name="M:System.Linq.ParallelQuery`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the sequence.
            </summary>
      <returns>An enumerator that iterates through the sequence.</returns>
    </member>
    <member name="T:System.Linq.Parallel.EmptyEnumerable`1">
      <summary>
            We occassionally need a no-op enumerator to stand-in when we don't have data left
            within a partition's data stream. These are simple enumerable and enumerator
            implementations that always and consistently yield no elements.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.QueryOperatorEnumerator`2">
      <summary>
            A common enumerator type that unifies all query operator enumerators. 
            </summary>
      <typeparam name="TElement">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.EnumerableWrapperWeakToStrong">
      <summary>
            A simple implementation of the IEnumerable{object} interface which wraps
            a weakly typed IEnumerable object, allowing it to be accessed as a strongly typed
            IEnumerable{object}.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.IParallelPartitionable`1">
      <summary>
             
             An interface that allows developers to specify their own partitioning routines.
            
             </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ParallelEnumerableWrapper">
      <summary>
            A simple implementation of the ParallelQuery{object} interface which wraps an
            underlying IEnumerable, such that it can be used in parallel queries.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.ParallelEnumerableWrapper`1">
      <summary>
            A simple implementation of the ParallelQuery{T} interface which wraps an
            underlying IEnumerable{T}, such that it can be used in parallel queries.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.QueryAggregationOptions">
      <summary>
            An enum to specify whether an aggregate operator is associative, commutative,
            neither, or both. This influences query analysis and execution: associative
            aggregations can run in parallel, whereas non-associative cannot; non-commutative
            aggregations must be run over data in input-order. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.RangeEnumerable">
      <summary>
            A simple enumerable type that implements the range algorithm. It also supports
            partitioning of the indices by implementing an interface that PLINQ recognizes.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.RepeatEnumerable`1">
      <summary>
            A simple enumerable type that implements the repeat algorithm. It also supports
            partitioning of the count space by implementing an interface that PLINQ recognizes.
            </summary>
      <typeparam name="TResult">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.IMergeHelper`1">
      <summary>
            Used as a stand-in for replaceable merge algorithms. Alternative implementations
            are chosen based on the style of merge required. 
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ArrayMergeHelper`1">
      <summary>
            A special merge helper for indexible queries. Given an indexible query, we know how many elements
            we'll have in the result set, so we can allocate the array ahead of time. Then, as each result element
            is produced, we can directly insert it into the appropriate position in the output array, paying
            no extra cost for ordering.
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
    </member>
    <member name="M:System.Linq.Parallel.ArrayMergeHelper`1.#ctor(System.Linq.Parallel.QuerySettings,System.Linq.Parallel.QueryResults{`0})">
      <summary>
            Instantiates the array merge helper.
            </summary>
      <param name="settings">The query settings</param>
      <param name="queryResults">The query results</param>
    </member>
    <member name="M:System.Linq.Parallel.ArrayMergeHelper`1.ToArrayElement(System.Int32)">
      <summary>
            A method used as a delegate passed into the ForAll operator
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.ArrayMergeHelper`1.Execute">
      <summary>
            Schedules execution of the merge itself.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.ArrayMergeHelper`1.GetEnumerator">
      <summary>
            Gets the enumerator over the results.
            
            We never expect this method to be called. ArrayMergeHelper is intended to be used when we want
            to consume the results using GetResultsAsArray().
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.ArrayMergeHelper`1.GetResultsAsArray">
      <summary>
            Returns the merged results as an array.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:System.Linq.Parallel.MergeEnumerator`1">
      <summary>
            Convenience class used by enumerators that merge many partitions into one. 
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.AsynchronousChannelMergeEnumerator`1">
      <summary>
             An enumerator that merges multiple one-to-one channels into a single output
             stream, including any necessary blocking and synchronization. This is an
             asynchronous enumerator, i.e. the producers may be inserting items into the
             channels concurrently with the consumer taking items out of them. Therefore,
             enumerating this object can cause the current thread to block.
            
             We use a biased choice algorithm to choose from our consumer channels. I.e. we
             will prefer to process elements in a fair round-robin fashion, but will
             occassionally bypass this if a channel is empty.
            
             </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:System.Linq.Parallel.AsynchronousChannelMergeEnumerator`1.WaitAny(System.Threading.ManualResetEventSlim[])">
      <summary>
            WaitAny simulates a Win32-style WaitAny on the set of thin-events.
            </summary>
      <param name="events">An array of thin-events (null elements permitted)</param>
      <returns>The index of the specific event in events that caused us to wake up.</returns>
    </member>
    <member name="T:System.Linq.Parallel.DefaultMergeHelper`2">
      <summary>
            The default merge helper uses a set of straightforward algorithms for output
            merging. Namely, for synchronous merges, the input data is yielded from the
            input data streams in "depth first" left-to-right order. For asynchronous merges,
            on the other hand, we use a biased choice algorithm to favor input channels in
            a "fair" way. No order preservation is carried out by this helper. 
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
      <typeparam name="TIgnoreKey">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.MergeExecutor`1">
      <summary>
            Drives execution of an actual merge operation, including creating channel data
            structures and scheduling parallel work as appropriate. The algorithms used
            internally are parameterized based on the type of data in the partitions; e.g.
            if an order preserved stream is found, the merge will automatically use an
            order preserving merge, and so forth. 
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.OrderPreservingMergeHelper`2">
      <summary>
            The order preserving merge helper guarantees the output stream is in a specific order. This is done
            by comparing keys from a set of already-sorted input partitions, and coalescing output data using
            incremental key comparisons.
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1">
      <summary>
            A merge helper that yields results in a streaming fashion, while still ensuring correct output
            ordering. This merge only works if each producer task generates outputs in the correct order,
            i.e. with an Increasing (or Correct) order index.
            
            The merge creates DOP producer tasks, each of which will be  writing results into a separate
            buffer.
            
            The consumer always waits until each producer buffer contains at least one element. If we don't
            have one element from each producer, we cannot yield the next element. (If the order index is 
            Correct, or in some special cases with the Increasing order, we could yield sooner. The
            current algorithm does not take advantage of this.)
            
            The consumer maintains a producer heap, and uses it to decide which producer should yield the next output
            result. After yielding an element from a particular producer, the consumer will take another element
            from the same producer. However, if the producer buffer exceeded a particular threshold, the consumer
            will take the entire buffer, and give the producer an empty buffer to fill.
            
            Finally, if the producer notices that its buffer has exceeded an even greater threshold, it will
            go to sleep and wait until the consumer takes the entire buffer.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.Producer">
      <summary>
            A structure to represent a producer in the producer heap.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.ProducerComparer">
      <summary>
            A comparer used by FixedMaxHeap(Of Producer)
            
            This comparer will be used by max-heap. We want the producer with the smallest MaxKey to
            end up in the root of the heap.
            
                x.MaxKey GREATER_THAN y.MaxKey  =&gt;  x LESS_THAN y     =&gt; return -
                x.MaxKey EQUALS y.MaxKey        =&gt;  x EQUALS y        =&gt; return 0
                x.MaxKey LESS_THAN y.MaxKey     =&gt;  x GREATER_THAN y  =&gt; return +
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.OrderedPipeliningMergeEnumerator">
      <summary>
            Enumerator over the results of an order-preserving pipelining merge.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.OrderedPipeliningMergeEnumerator.MoveNext">
      <summary>
            Moves the enumerator to the next result, or returns false if there are no more results to yield.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.OrderedPipeliningMergeEnumerator.ThrowIfInTearDown">
      <summary>
            If the cancellation of the query has been initiated (because one or more producers
            encountered exceptions, or because external cancellation token has been set), the method 
            will tear down the query and rethrow the exception.
            </summary>
    </member>
    <member name="P:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.OrderedPipeliningMergeEnumerator.Current">
      <summary>
            Returns the current result
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.INITIAL_BUFFER_SIZE">
      <summary>
            The initial capacity of the buffer queue. The value was chosen experimentally.
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.STEAL_BUFFER_SIZE">
      <summary>
            If the consumer notices that the queue reached this limit, it will take the entire buffer from
            the producer, instead of just popping off one result. The value was chosen experimentally.
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.MAX_BUFFER_SIZE">
      <summary>
            If the producer notices that the queue reached this limit, it will go to sleep until woken up
            by the consumer. Chosen experimentally.
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.m_autoBuffered">
      <summary>
            Whether the producer is allowed to buffer up elements before handing a chunk to the consumer.
            If false, the producer will make each result available to the consumer immediately after it is
            produced.
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.m_buffers">
      <summary>
            Buffers for the results. Each buffer has elements added by one producer, and removed
            by the consumer.
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.m_producerDone">
      <summary>
            Whether each producer is done producing. Set to true by individual producers, read by consumer.
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.m_producerWaiting">
      <summary>
            Whether a particular producer is waiting on the consumer. Read by the consumer, set to true
            by producers, set to false by the consumer.
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.m_consumerWaiting">
      <summary>
             Whether the consumer is waiting on a particular producer. Read by producers, set to true
             by consumer, set to false by producer.
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.m_bufferLocks">
      <summary>
            Each object is a lock protecting the corresponding elements in m_buffers, m_producerDone, 
            m_producerWaiting and m_consumerWaiting.
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1.s_producerComparer">
      <summary>
            A singleton instance of the comparer used by the producer heap. Eager allocation is OK 
            because if the static constructor runs, we will be using this merge.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.SynchronousChannelMergeEnumerator`1">
      <summary>
            This enumerator merges multiple input channels into a single output stream. The merging process just
            goes from left-to-right, enumerating each channel in succession in its entirety.
            Assumptions:
                Before enumerating this object, all producers for all channels must have finished enqueueing new
                elements.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.HashRepartitionEnumerator`3">
      <summary>
            This enumerator handles the actual coordination among partitions required to
            accomplish the repartitioning operation, as explained above.
            </summary>
      <typeparam name="TInputOutput">The kind of elements.</typeparam>
      <typeparam name="THashKey">The key used to distribute elements.</typeparam>
      <typeparam name="TIgnoreKey">The kind of keys found in the source (ignored).</typeparam>
    </member>
    <member name="T:System.Linq.Parallel.PartitionedStream`2">
      <summary>
             A partitioned stream just partitions some data source using an extensible 
             partitioning algorithm and exposes a set of N enumerators that are consumed by
             their ordinal index [0..N). It is used to build up a set of streaming computations.
             At instantiation time, the actual data source to be partitioned is supplied; and
             then the caller will layer on top additional enumerators to represent phases in the
             computation. Eventually, a merge can then schedule enumeration of all of the
             individual partitions in parallel by obtaining references to the individual
             partition streams.
            
             This type has a set of subclasses which implement different partitioning algorithms,
             allowing us to easily plug in different partitioning techniques as needed. The type
             supports wrapping IEnumerables and IEnumerators alike, with some preference for the
             former as many partitioning algorithms are more intelligent for certain data types.
             </summary>
      <typeparam name="TElement">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.HashRepartitionStream`3">
      <summary>
             A repartitioning stream must take input data that has already been partitioned and
             redistribute its contents based on a new partitioning algorithm. This is accomplished
             by making each partition p responsible for redistributing its input data to the
             correct destination partition. Some input elements may remain in p, but many will now
             belong to a different partition and will need to move. This requires a great deal of
             synchronization, but allows threads to repartition data incrementally and in parallel.
             Each partition will "pull" data on-demand instead of partitions "pushing" data, which
             allows us to reduce some amount of synchronization overhead.
            
             We currently only offer one form of reparitioning via hashing.  This used to be an
             abstract base class, but we have eliminated that to get rid of some virtual calls on
             hot code paths.  Uses a key selection algorithm with mod'ding to determine destination.
            
             @TODO: @BUG#519: consider adding a bound to the buffers. Unfortunately this can quite easily
                 lead to deadlock when multiple repartitions are involved. Need a solution.
             @TODO: @BUG#504: consider amortizing synchronization overhead by enqueueing/dequeueing in chunks
                 rather than single elements. Also need to be careful not to introduce deadlock.
             </summary>
      <typeparam name="TInputOutput">
      </typeparam>
      <typeparam name="THashKey">
      </typeparam>
      <typeparam name="TOrderKey">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.IPartitionedStreamRecipient`1">
      <summary>
            IPartitionedStreamRecipient is essentially a generic action on a partitioned stream,
            whose generic type parameter is the type of the order keys in the partitioned stream.
            </summary>
      <typeparam name="TElement">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.OrderedHashRepartitionEnumerator`3">
      <summary>
            This enumerator handles the actual coordination among partitions required to
            accomplish the repartitioning operation, as explained above.  In addition to that,
            it tracks order keys so that order preservation can flow through the enumerator.
            </summary>
      <typeparam name="TInputOutput">The kind of elements.</typeparam>
      <typeparam name="THashKey">The key used to distribute elements.</typeparam>
      <typeparam name="TOrderKey">The kind of keys found in the source.</typeparam>
    </member>
    <member name="T:System.Linq.Parallel.PartitionedDataSource`1">
      <summary>
             Contiguous range chunk partitioning attempts to improve data locality by keeping
             data close together in the incoming data stream together in the outgoing partitions.
             There are really three types of partitions that are used internally:
            
                 1. If the data source is indexable--like an array or List_T--we can actually
                    just compute the range indexes and avoid doing any copying whatsoever. Each
                    "partition" is just an enumerator that will walk some subset of the data.
                 2. If the data source has an index (different than being indexable!), we can
                    turn this into a range scan of the index. We can roughly estimate distribution
                    and ensure an evenly balanced set of partitions.
                    @TODO: @BUG#516: we don't have indexes today. We are considering it for the future.
                 3. If we can't use 1 or 2, we instead partition "on demand" by chunking the contents
                    of the source enumerator as they are requested. The unfortunate thing is that
                    this requires synchronization, since consumers may be running in parallel. We
                    amortize the cost of this by giving chunks of items when requested instead of
                    one element at a time. Note that this approach also works for infinite streams.
            
             In all cases, the caller can request that enumerators walk elements in striped
             contiguous chunks. If striping is requested, then each partition j will yield elements
             in the data source for which ((i / s)%p) == j, where i is the element's index, s is
             a chunk size calculated by the system with the intent of aligning on cache lines, and
             p is the number of partitions. If striping is not requested, we use the same algorith,
             only, instead of aligning on cache lines, we use a chunk size of l / p, where l
             is the length of the input and p is the number of partitions.
            
             Notes:
                 This is used as the default partitioning strategy by much of the PLINQ infrastructure.
             </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.QueryOperator`1">
      <summary>
             This is the abstract base class for all query operators in the system. It
             implements the ParallelQuery{T} type so that it can be bound as the source
             of parallel queries and so that it can be returned as the result of parallel query
             operations. Not much is in here, although it does serve as the "entry point" for
             opening all query operators: it will lazily analyze and cache a plan the first
             time the tree is opened, and will open the tree upon calls to GetEnumerator.
            
             Notes:
                 This class implements ParallelQuery so that any parallel query operator
                 can bind to the parallel query provider overloads. This allows us to string
                 together operators w/out the user always specifying AsParallel, e.g.
                 Select(Where(..., ...), ...), and so forth. 
             </summary>
      <typeparam name="TOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.UnaryQueryOperator`2">
      <summary>
            The base class from which all binary query operators derive, that is, those that
            have two child operators. This introduces some convenience methods for those
            classes, as well as any state common to all subclasses.
            </summary>
      <typeparam name="TInput">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.QueryResults`1">
      <summary>
             The QueryResults{T} is a class representing the results of the query. There may
             be different ways the query results can be manipulated. Currently, two ways are
             supported:
            
             1. Open the query results as a partitioned stream by calling GivePartitionedStream
                and pass a generic action as an argument.
                
             2. Access individual elements of the results list by calling GetElement(index) and
                ElementsCount. This method of accessing the query results is available only if
                IsIndexible return true. 
             </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.AssociativeAggregationOperator`3">
      <summary>
             The aggregation operator is a little unique, in that the enumerators it returns
             yield intermediate results instead of the final results. That's because there is
             one last Aggregate operation that must occur in order to perform the final reduction
             over the intermediate streams. In other words, the intermediate enumerators produced
             by this operator are never seen by other query operators or consumers directly.
            
             An aggregation performs parallel prefixing internally. Given a binary operator O,
             it will generate intermediate results by folding O across partitions; then it
             performs a final reduction by folding O accross the intermediate results. The
             analysis engine knows about associativity and commutativity, and will ensure the
             style of partitioning inserted into the tree is compatable with the operator.
            
             For instance, say O is + (meaning it is AC), our input is {1,2,...,8}, and we
             use 4 partitions to calculate the aggregation. Sequentially this would look
             like this O(O(O(1,2),...),8), in other words ((1+2)+...)+8. The parallel prefix
             of this (w/ 4 partitions) instead calculates the intermediate aggregations, i.e.:
             t1 = O(1,2), t2 = O(3,4), ... t4 = O(7,8), aka t1 = 1+2, t2 = 3+4, t4 = 7+8.
             The final step is to aggregate O over these intermediaries, i.e.
             O(O(O(t1,t2),t3),t4), or ((t1+t2)+t3)+t4. This generalizes to any binary operator.
            
             Beause some aggregations use a different input, intermediate, and output types,
             we support an even more generalized aggregation type. In this model, we have
             three operators, an intermediate (used for the incremental aggregations), a
             final (used for the final summary of intermediate results), and a result selector
             (used to perform whatever transformation is needed on the final summary).
             </summary>
      <typeparam name="TInput">
      </typeparam>
      <typeparam name="TIntermediate">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.PartitionerQueryOperator`1">
      <summary>
            A QueryOperator that represents the output of the query partitioner.AsParallel().
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.PartitionerQueryOperator`1.PartitionerQueryOperatorResults">
      <summary>
            QueryResults for a PartitionerQueryOperator
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.PartitionerQueryOperator`1.OrderablePartitionerEnumerator">
      <summary>
            Enumerator that converts an enumerator over key-value pairs exposed by a partitioner
            to a QueryOperatorEnumerator used by PLINQ internally.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.PartitionerQueryOperator`1.PartitionerEnumerator">
      <summary>
            Enumerator that converts an enumerator over key-value pairs exposed by a partitioner
            to a QueryOperatorEnumerator used by PLINQ internally.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.PartitionerQueryOperator`1.GetOrdinalIndexState(System.Collections.Concurrent.Partitioner{`0})">
      <summary>
            Determines the OrdinalIndexState for a partitioner 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.ScanQueryOperator`1">
      <summary>
            A scan is just a simple operator that is positioned directly on top of some
            real data source. It's really just a place holder used during execution and
            analysis -- it should never actually get opened.
            </summary>
      <typeparam name="TElement">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.BinaryQueryOperator`3">
      <summary>
            The base class from which all binary query operators derive, that is, those that
            have two child operators. This introduces some convenience methods for those
            classes, as well as any state common to all subclasses. 
            </summary>
      <typeparam name="TLeftInput">
      </typeparam>
      <typeparam name="TRightInput">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ExceptQueryOperator`1">
      <summary>
            Operator that yields the elements from the first data source that aren't in the second.
            This is known as the set relative complement, i.e. left - right. 
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.GroupJoinQueryOperator`4">
      <summary>
            A group join operator takes a left query tree and a right query tree, and then yields
            the matching elements between the two. This can be used for outer joins, i.e. those
            where an outer element has no matching inner elements -- the result is just an empty
            list. As with the join algorithm above, we currently use a hash join algorithm.
            </summary>
      <typeparam name="TLeftInput">
      </typeparam>
      <typeparam name="TRightInput">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.HashJoinQueryOperatorEnumerator`5">
      <summary>
             This enumerator implements the hash-join algorithm as noted earlier.
            
             Assumptions:
                 This enumerator type won't work properly at all if the analysis engine didn't
                 ensure a proper hash-partition. We expect inner and outer elements with equal
                 keys are ALWAYS in the same partition. If they aren't (e.g. if the analysis is
                 busted) we'll silently drop items on the floor. :( 
                 
                 
              This is the enumerator class for two operators:
               - Join
               - GroupJoin
             </summary>
      <typeparam name="TLeftInput">
      </typeparam>
      <typeparam name="TLeftKey">
      </typeparam>
      <typeparam name="TRightInput">
      </typeparam>
      <typeparam name="THashKey">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.IntersectQueryOperator`1">
      <summary>
            Operator that yields the intersection of two data sources. 
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.JoinQueryOperator`4">
      <summary>
             A join operator takes a left query tree and a right query tree, and then yields the
             matching pairs between the two. LINQ supports equi-key-based joins. Hence, a key-
             selection function for the left and right data types will yield keys of the same
             type for both. We then merely have to match elements from the left with elements from
             the right that have the same exact key. Note that this is an inner join. In other
             words, outer elements with no matching inner elements do not appear in the output.
            
             @TODO: @BUG#528: Currently we implement only a hash-join algorithm. Furthermore, we always
                 choose the inner data source for the hash-table creation. There is room for
                 optimization and different algorithm choices eventually.
            
             Hash-joins work in two phases:
            
                (1) Building - we build a hash-table from one of the data sources. In the case
                        of this specific operator, the table is built from the hash-codes of
                        keys selected via the key selector function. Because elements may share
                        the same key, the table must support one-key-to-many-values.
                (2) Probing - for each element in the data source not used for building, we
                        use its key to look into the hash-table. If we find elements under this
                        key, we just enumerate all of them, yielding them as join matches.
            
             Because hash-tables exhibit on average O(1) lookup, we turn what would have been
             an O(n*m) algorithm -- in the case of nested loops joins -- into an O(n) algorithm.
             We of course require some additional storage to do so, but in general this pays.
             </summary>
      <typeparam name="TLeftInput">
      </typeparam>
      <typeparam name="TRightInput">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.UnionQueryOperator`1">
      <summary>
            Operator that yields the union of two data sources. 
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ZipQueryOperator`3">
      <summary>
            A Zip operator combines two input data sources into a single output stream,
            using a pairwise element matching algorithm. For example, the result of zipping
            two vectors a = {0, 1, 2, 3} and b = {9, 8, 7, 6} is the vector of pairs,
            c = {(0,9), (1,8), (2,7), (3,6)}. Because the expectation is that each element
            is matched with the element in the other data source at the same ordinal
            position, the zip operator requires order preservation. 
            </summary>
      <typeparam name="TLeftInput">
      </typeparam>
      <typeparam name="TRightInput">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.PartitionedStreamMerger`1">
      <summary>
            Partitioned stream recipient that will merge the results. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.QueryOpeningEnumerator`1">
      <summary>
            A wrapper enumerator that just opens the query operator when MoveNext() is called for the
            first time. We use QueryOpeningEnumerator to call QueryOperator.GetOpenedEnumerator()
            lazily because once GetOpenedEnumerator() is called, PLINQ starts precomputing the
            results of the query.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.QueryOpeningEnumerator`1.OpenQuery">
      <summary>
            Opens the query and initializes m_openedQueryEnumerator and m_querySettings.
            Called from the first MoveNext call.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.InlinedAggregationOperator`3">
      <summary>
            This class is common to all of the "inlined" versions of various aggregations.  The
            inlined operators ensure that real MSIL instructions are used to perform elementary
            operations versus general purpose delegate-based binary operators.  For obvious reasons
            this is a quite bit more efficient, although it does lead to a fair bit of unfortunate
            code duplication. 
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TIntermediate">
      </typeparam>
      <typeparam name="TResult">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.CountAggregationOperator`1">
      <summary>
            An inlined count aggregation and its enumerator. 
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.InlinedAggregationOperatorEnumerator`1">
      <summary>
            A class with some shared implementation between all aggregation enumerators. 
            </summary>
      <typeparam name="TIntermediate">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.DecimalAverageAggregationOperator">
      <summary>
            An inlined average aggregation operator and its enumerator, for decimals. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.DecimalMinMaxAggregationOperator">
      <summary>
            An inlined min/max aggregation and its enumerator, for decimals.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.DecimalSumAggregationOperator">
      <summary>
            An inlined sum aggregation and its enumerator, for decimals. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.DoubleAverageAggregationOperator">
      <summary>
            An inlined average aggregation operator and its enumerator, for doubles.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.DoubleMinMaxAggregationOperator">
      <summary>
             An inlined min/max aggregation and its enumerator, for doubles.
            
             Notes:
                 Note that normally double.NaN &lt; anything is false, as is anything &lt; NaN.  This would
                 lead to some strangeness in Min and Max, e.g. Min({ NaN, 5.0 } == NaN, yet
                 Min({ 5.0, NaN }) == 5.0!  We impose a total ordering so that NaN is smaller than
                 everything, including -infinity, which is consistent with Comparer_T. 
             </summary>
    </member>
    <member name="T:System.Linq.Parallel.DoubleSumAggregationOperator">
      <summary>
            An inlined sum aggregation and its enumerator, for doubles. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.FloatAverageAggregationOperator">
      <summary>
            An inlined average aggregation operator and its enumerator, for floats. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.FloatMinMaxAggregationOperator">
      <summary>
            An inlined min/max aggregation and its enumerator, for floats.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.FloatSumAggregationOperator">
      <summary>
            An inlined sum aggregation and its enumerator, for floats. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.IntAverageAggregationOperator">
      <summary>
            An inlined average aggregation operator and its enumerator, for ints. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.IntMinMaxAggregationOperator">
      <summary>
            An inlined min/max aggregation and its enumerator, for ints. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.IntSumAggregationOperator">
      <summary>
            Inlined aggregations for summing up primitives (int, long, float, double, decimal), as
            well as the nullable versions of each (int?, long?, float?, double?, decimal?). 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.LongAverageAggregationOperator">
      <summary>
            An inlined average aggregation operator and its enumerator, for longs. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.LongCountAggregationOperator`1">
      <summary>
            An inlined count aggregation and its enumerator. 
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.LongMinMaxAggregationOperator">
      <summary>
            An inlined min/max aggregation and its enumerator, for longs. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.LongSumAggregationOperator">
      <summary>
            An inlined sum aggregation and its enumerator, for longs. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableDecimalAverageAggregationOperator">
      <summary>
            An inlined average aggregation operator and its enumerator, for Nullable decimals.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableDecimalMinMaxAggregationOperator">
      <summary>
            An inlined min/max aggregation and its enumerator, for Nullable decimals. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableDecimalSumAggregationOperator">
      <summary>
            An inlined sum aggregation and its enumerator, for nullable decimals. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableDoubleAverageAggregationOperator">
      <summary>
            An inlined average aggregation operator and its enumerator, for Nullable doubles.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableDoubleMinMaxAggregationOperator">
      <summary>
             An inlined min/max aggregation and its enumerator, for Nullable{Double}s.
            
             Notes:
                 Note that normally double.NaN &lt; anything is false, as is anything &lt; NaN.  This would
                 lead to some strangeness in Min and Max, e.g. Min({ NaN, 5.0 } == NaN, yet
                 Min({ 5.0, NaN }) == 5.0!  We impose a total ordering so that NaN is smaller than
                 everything, including -infinity, which is consistent with Comparer_T. 
             </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableDoubleSumAggregationOperator">
      <summary>
            An inlined sum aggregation and its enumerator, for nullable doubles. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableFloatAverageAggregationOperator">
      <summary>
            An inlined average aggregation operator and its enumerator, for Nullable floats.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableFloatMinMaxAggregationOperator">
      <summary>
             An inlined min/max aggregation and its enumerator, for Nullable floats.
            
             Notes:
                 Note that normally float.NaN &lt; anything is false, as is anything &lt; NaN.  This would
                 lead to some strangeness in Min and Max, e.g. Min({ NaN, 5.0 } == NaN, yet
                 Min({ 5.0, NaN }) == 5.0!  We impose a total ordering so that NaN is smaller than
                 everything, including -infinity, which is consistent with Comparer_T.
             </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableFloatSumAggregationOperator">
      <summary>
            An inlined sum aggregation and its enumerator, for Nullable floats. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableIntAverageAggregationOperator">
      <summary>
            An inlined average aggregation operator and its enumerator, for Nullable ints. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableIntMinMaxAggregationOperator">
      <summary>
            An inlined min/max aggregation and its enumerator, for Nullable ints. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableIntSumAggregationOperator">
      <summary>
            An inlined sum aggregation and its enumerator, for Nullable ints. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableLongAverageAggregationOperator">
      <summary>
            An inlined average aggregation operator and its enumerator, for Nullable longs. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableLongMinMaxAggregationOperator">
      <summary>
            An inlined min/max aggregation and its enumerator, for Nullable{Int64}s. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NullableLongSumAggregationOperator">
      <summary>
            An inlined sum aggregation and its enumerator, for Nullable longs. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.ListQueryResults`1">
      <summary>
            Class to represent an IList{T} as QueryResults{T} 
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.OrdinalIndexState">
      <summary>
            Describes the state of order preservation index associated with an enumerator. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.QuerySettings">
      <summary>
            This type contains query execution options specified by the user.
            QuerySettings are used as follows:
            - in the query construction phase, some settings may be uninitialized.
            - at the start of the query opening phase, the WithDefaults method
              is used to initialize all uninitialized settings.
            - in the rest of the query opening phase, we assume that all settings
              have been initialized.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.OrderingQueryOperator`1">
      <summary>
            Represents operators AsOrdered and AsUnordered. In the current implementation, it
            simply turns on preservation globally in the query. 
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.QueryExecutionOption`1">
      <summary>
            Represents operators that set various query execution options. 
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.AnyAllSearchOperator`1">
      <summary>
             The any/all operators work the same way. They search for the occurrence of a predicate
             value in the data source, and upon the first occurrence of such a value, yield a
             particular value. Specifically:
            
                 - Any returns true if the predicate for any element evaluates to true.
                 - All returns false if the predicate for any element evaluates to false.
            
             This uniformity is used to apply a general purpose algorithm. Both sentences above
             take the form of "returns XXX if the predicate for any element evaluates to XXX."
             Therefore, we just parameterize on XXX, called the qualifciation below, and if we
             ever find an occurrence of XXX in the input data source, we also return XXX. Otherwise,
             we return !XXX. Obviously, XXX in this case is a bool.
            
             This is a search algorithm. So once any single partition finds an element, it will
             return so that execution can stop. This is done with a "cancelation" flag that is
             polled by all parallel workers. The first worker to find an answer sets it, and all
             other workers notice it and quit as quickly as possible.
             </summary>
      <typeparam name="TInput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ConcatQueryOperator`1">
      <summary>
            Concatenates one data source with another.  Order preservation is used to ensure
            the output is actually a concatenation -- i.e. one after the other.  The only
            special synchronization required is to find the largest index N in the first data
            source so that the indices of elements in the second data source can be offset
            by adding N+1.  This makes it appear to the order preservation infrastructure as
            though all elements in the second came after all elements in the first, which is
            precisely what we want.
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ContainsSearchOperator`1">
      <summary>
            Contains is quite similar to the any/all operator above. Each partition searches a
            subset of elements for a match, and the first one to find a match signals to the rest
            of the partititons to stop searching.
            </summary>
      <typeparam name="TInput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.DefaultIfEmptyQueryOperator`1">
      <summary>
            This operator just exposes elements directly from the underlying data source, if
            it's not empty, or yields a single default element if the data source is empty.
            There is a minimal amount of synchronization at the beginning, until all partitions
            have registered whether their stream is empty or not. Once the 0th partition knows
            that at least one other partition is non-empty, it may proceed. Otherwise, it is
            the 0th partition which yields the default value.
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.DistinctQueryOperator`1">
      <summary>
            This operator yields all of the distinct elements in a single data set. It works quite
            like the above set operations, with the obvious difference being that it only accepts
            a single data source as input. 
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ElementAtQueryOperator`1">
      <summary>
            ElementAt just retrieves an element at a specific index.  There is some cross-partition
            coordination to force partitions to stop looking once a partition has found the
            sought-after element.
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="M:System.Linq.Parallel.ElementAtQueryOperator`1.Aggregate(`0@,System.Boolean)">
      <summary>
            Executes the query, either sequentially or in parallel, depending on the query execution mode and
            whether a premature merge was inserted by this ElementAt operator.
            </summary>
      <param name="result">result</param>
      <param name="withDefaultValue">withDefaultValue</param>
      <returns>whether an element with this index exists</returns>
    </member>
    <member name="T:System.Linq.Parallel.FirstQueryOperator`1">
      <summary>
            First tries to discover the first element in the source, optionally matching a
            predicate.  All partitions search in parallel, publish the lowest index for a
            candidate match, and reach a barrier.  Only the partition that "wins" the race,
            i.e. who found the candidate with the smallest index, will yield an element.
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ForAllOperator`1">
      <summary>
            A forall operator just enables an action to be placed at the "top" of a query tree
            instead of yielding an enumerator that some consumer can walk. We execute the
            query for effect instead of yielding a data result. 
            </summary>
      <typeparam name="TInput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.GroupByQueryOperator`3">
      <summary>
            The operator type for GroupBy statements. This operator groups the input based on
            a key-selection routine, yielding one-to-many values of key-to-elements. The
            implementation is very much like the hash join operator, in which we first build
            a big hashtable of the input; then we just iterate over each unique key in the
            hashtable, yielding it plus all of the elements with the same key.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TGroupKey">
      </typeparam>
      <typeparam name="TElement">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.OrderedGroupByGrouping`3">
      <summary>
            An ordered version of the grouping data structure. Represents an ordered group of elements that
            have the same grouping key.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.OrderedGroupByGrouping`3.#ctor(`0,System.Collections.Generic.IComparer{`1})">
      <summary>
            Constructs a new grouping
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.OrderedGroupByGrouping`3.Add(`2,`1)">
      <summary>
            Add an element
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.OrderedGroupByGrouping`3.DoneAdding">
      <summary>
            No more elements will be added, so we can sort the group now.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.IndexedSelectQueryOperator`2">
      <summary>
             A variant of the Select operator that supplies element index while performing the
             projection operation. This requires cooperation with partitioning and merging to
             guarantee ordering is preserved.
            
             @TODO: @PERF: @BUG#527: as an optimization, we strictly don't need order to be preserved
                  all the way until the merge. If ordering is only kept for THIS operator, we
                  can subsequently get rid of order preservation after executing. 
             </summary>
      <typeparam name="TInput">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.IndexedWhereQueryOperator`1">
      <summary>
             A variant of the Where operator that supplies element index while performing the
             filtering operation. This requires cooperation with partitioning and merging to
             guarantee ordering is preserved.
            
             @TODO: @PERF: @BUG#527: as an optimization, we strictly don't need order to be preserved
                  all the way until the merge. If ordering is only kept for THIS operator, we
                  can subsequently get rid of order preservation after executing. 
             </summary>
      <typeparam name="TInputOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.LastQueryOperator`1">
      <summary>
             Last tries to discover the last element in the source, optionally matching a
             predicate.  All partitions search in parallel, publish the greatest index for a
             candidate match, and reach a barrier.  Only the partition that "wins" the race,
             i.e. who found the candidate with the largest index, will yield an element.
            
             @TODO: @PERF: @BUG#414: this traverses the data source in forward-order.  In the future, we
                 will want to traverse in reverse order, since this allows partitions to stop
                 the search sooner (by watching if the current index passes below the current best).
            
             </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ReverseQueryOperator`1">
      <summary>
            Reverse imposes ordinal order preservation. There are normally two phases to this
            operator's execution.  Each partition first builds a buffer containing all of its
            elements, and then proceeds to yielding the elements in reverse.  There is a
            'barrier' (but not a blocking barrier) in between these two steps, at which point the largest index becomes
            known.  This is necessary so that when elements from the buffer are yielded, the
            CurrentIndex can be reported as the largest index minus the original index (thereby
            reversing the indices as well as the elements themselves).  If the largest index is
            known a priori, because we have an array for example, we can avoid the barrier in
            between the steps.
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.SelectManyQueryOperator`3">
      <summary>
             SelectMany is effectively a nested loops join. It is given two data sources, an
             outer and an inner -- actually, the inner is sometimes calculated by invoking a
             function for each outer element -- and we walk the outer, walking the entire
             inner enumerator for each outer element. There is an optional result selector
             function which can transform the output before yielding it as a result element.
            
             Notes:
                 Although select many takes two enumerable objects as input, it appears to the
                 query analysis infrastructure as a unary operator. That's because it works a
                 little differently than the other binary operators: it has to re-open the right
                 child every time an outer element is walked. The right child is NOT partitioned. 
             </summary>
      <typeparam name="TLeftInput">
      </typeparam>
      <typeparam name="TRightInput">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
    </member>
    <member name="M:System.Linq.Parallel.SelectManyQueryOperator`3.WrapPartitionedStreamNotIndexed``1(System.Linq.Parallel.PartitionedStream{`0,``0},System.Linq.Parallel.IPartitionedStreamRecipient{`2},System.Linq.Parallel.QuerySettings)">
      <summary>
            A helper method for WrapPartitionedStream. We use the helper to reuse a block of code twice, but with
            a different order key type. (If premature merge occured, the order key type will be "int". Otherwise, 
            it will be the same type as "TLeftKey" in WrapPartitionedStream.)
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.SelectManyQueryOperator`3.WrapPartitionedStreamIndexed(System.Linq.Parallel.PartitionedStream{`0,System.Int32},System.Linq.Parallel.IPartitionedStreamRecipient{`2},System.Linq.Parallel.QuerySettings)">
      <summary>
            Similar helper method to WrapPartitionedStreamNotIndexed, except that this one is for the indexed variant
            of SelectMany (i.e., the SelectMany that passes indices into the user sequence-generating delegate)
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.SelectQueryOperator`2">
      <summary>
            The operator type for Select statements. This operator transforms elements as it
            enumerates them through the use of a selector delegate. 
            </summary>
      <typeparam name="TInput">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.SingleQueryOperator`1">
      <summary>
            Single searches the input to find the sole element that satisfies the (optional)
            predicate.  If multiple such elements are found, the caller is responsible for
            producing an error.  There is some degree of cross-partition synchronization to
            proactively hault the search if we ever determine there are multiple elements
            satisfying the search in the input.
            </summary>
      <typeparam name="TSource">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.SortQueryOperator`2">
      <summary>
            The query operator for OrderBy and ThenBy.
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
      <typeparam name="TSortKey">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.TakeOrSkipQueryOperator`1">
      <summary>
            Take and Skip either take or skip a specified number of elements, captured in the
            count argument.  These will work a little bit like TakeWhile and SkipWhile: there
            are two phases, (1) Search and (2) Yield.  In the search phase, our goal is to
            find the 'count'th index from the input.  We do this in parallel by sharing a count-
            sized array.  Each thread races to populate the array with indices in ascending
            order.  This requires synchronization for inserts.  We use a simple heap, for decent
            worst case performance.  After a thread has scanned count elements, or its current
            index is greater than or equal to the maximum index in the array (and the array is
            fully populated), the thread can stop searching.  All threads issue a barrier before
            moving to the Yield phase.  When the Yield phase is entered, the count-1th element
            of the array contains: in the case of Take, the maximum index (exclusive) to be
            returned; or in the case of Skip, the minimum index (inclusive) to be returned.  The
            Yield phase simply consists of yielding these elements as output.
            </summary>
      <typeparam name="TResult">
      </typeparam>
    </member>
    <member name="M:System.Linq.Parallel.TakeOrSkipQueryOperator`1.OutputOrdinalIndexState">
      <summary>
            Determines the order index state for the output operator
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.TakeOrSkipWhileQueryOperator`1">
      <summary>
             Take- and SkipWhile work similarly. Execution is broken into two phases: Search
             and Yield.
            
             During the Search phase, many partitions at once search for the first occurrence
             of a false element.  As they search, any time a partition finds a false element
             whose index is lesser than the current lowest-known false element, the new index
             will be published, so other partitions can stop the search.  The search stops
             as soon as (1) a partition exhausts its input, (2) the predicate yields false for
             one of the partition's elements, or (3) its input index passes the current lowest-
             known index (sufficient since a given partition's indices are always strictly
             incrementing -- asserted below).  Elements are buffered during this process.
            
             Partitions use a barrier after Search and before moving on to Yield.  Once all
             have passed the barrier, Yielding begins.  At this point, the lowest-known false
             index will be accurate for the entire set, since all partitions have finished
             scanning.  This is where TakeWhile and SkipWhile differ.  TakeWhile will start at
             the beginning of its buffer and yield all elements whose indices are less than
             the lowest-known false index.  SkipWhile, on the other hand, will skipp any such
             elements in the buffer, yielding those whose index is greater than or equal to
             the lowest-known false index, and then finish yielding any remaining elements in
             its data source (since it may have stopped prematurely due to (3) above).
             </summary>
      <typeparam name="TResult">
      </typeparam>
    </member>
    <member name="M:System.Linq.Parallel.TakeOrSkipWhileQueryOperator`1.OutputOrderIndexState">
      <summary>
            Determines the order index state for the output operator
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.WhereQueryOperator`1">
      <summary>
            The operator type for Where statements. This operator filters out elements that
            don't match a filter function (supplied at instantiation time). 
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
    </member>
    <member name="F:System.Linq.Parallel.CancellationState.POLL_INTERVAL">
      <summary>
            Poll frequency (number of loops per cancellation check) for situations where per-1-loop testing is too high an overhead. 
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.CancellationState.ThrowIfCanceled(System.Threading.CancellationToken)">
      <summary>
            Throws an OCE if the merged token has been canceled.
            </summary>
      <param name="token">A token to check for cancelation.</param>
    </member>
    <member name="T:System.Linq.Parallel.QueryTask">
      <summary>
            Simple abstract task representation, allowing either synchronous and asynchronous
            execution. Subclasses override the Work API to implement the logic.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.SpoolingTaskBase">
      <summary>
            A spooling task handles marshaling data from a producer to a consumer. It simply
            takes data from a producer and hands it off to a consumer. This class is the base
            class from which other concrete spooling tasks derive, encapsulating some common
            logic (such as capturing exceptions).
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningSpoolingTask`1.PRODUCER_BUFFER_AUTO_SIZE">
      <summary>
            The number of elements to accumulate on the producer before copying the elements to the 
            producer-consumer buffer. This constant is only used in the AutoBuffered mode.
            
            Experimentally, 16 appears to be sufficient buffer size to compensate for the synchronization
            cost.
            </summary>
    </member>
    <member name="F:System.Linq.Parallel.OrderPreservingPipeliningSpoolingTask`1.m_autoBuffered">
      <summary>
            Whether the producer is allowed to buffer up elements before handing a chunk to the consumer.
            If false, the producer will make each result available to the consumer immediately after it is
            produced.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.OrderPreservingPipeliningSpoolingTask`1.#ctor(System.Linq.Parallel.QueryOperatorEnumerator{`0,System.Int32},System.Linq.Parallel.QueryTaskGroupState,System.Boolean[],System.Boolean[],System.Boolean[],System.Int32,System.Collections.Generic.Queue{System.Linq.Parallel.Pair{System.Int32,`0}}[],System.Object,System.Threading.Tasks.TaskScheduler,System.Boolean)">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.OrderPreservingPipeliningSpoolingTask`1.SpoolingWork">
      <summary>
            This method is responsible for enumerating results and enqueueing them to
            the output buffer as appropriate.  Each base class implements its own.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.OrderPreservingPipeliningSpoolingTask`1.Spool(System.Linq.Parallel.QueryTaskGroupState,System.Linq.Parallel.PartitionedStream{`0,System.Int32},System.Boolean[],System.Boolean[],System.Boolean[],System.Collections.Generic.Queue{System.Linq.Parallel.Pair{System.Int32,`0}}[],System.Object[],System.Threading.Tasks.TaskScheduler,System.Boolean)">
      <summary>
            Creates and begins execution of a new set of spooling tasks.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.OrderPreservingPipeliningSpoolingTask`1.SpoolingFinally">
      <summary>
            Dispose the underlying enumerator and wake up the consumer if necessary.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.OrderPreservingSpoolingTask`2">
      <summary>
            A spooling task handles marshaling data from a producer to a consumer. It's given
            a single enumerator object that contains all of the production algorithms, a single
            destination channel from which consumers draw results, and (optionally) a
            synchronization primitive using which to notify asynchronous consumers. This
            particular task variant preserves sort order in the final data.
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.QueryTaskGroupState">
      <summary>
            A collection of tasks used by a single query instance. This type also offers some
            convenient methods for tracing significant ETW events, waiting on tasks, propagating
            exceptions, and performing cancellation activities.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.SpoolingTask">
      <summary>
            A factory class to execute spooling logic.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.StopAndGoSpoolingTask`2">
      <summary>
            A spooling task handles marshaling data from a producer to a consumer. It's given
            a single enumerator object that contains all of the production algorithms, a single
            destination channel from which consumers draw results, and (optionally) a
            synchronization primitive using which to notify asynchronous consumers.
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
      <typeparam name="TIgnoreKey">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.PipelineSpoolingTask`2">
      <summary>
            A spooling task handles marshaling data from a producer to a consumer. It's given
            a single enumerator object that contains all of the production algorithms, a single
            destination channel from which consumers draw results, and (optionally) a
            synchronization primitive using which to notify asynchronous consumers.
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
      <typeparam name="TIgnoreKey">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ForAllSpoolingTask`2">
      <summary>
            A spooling task handles marshaling data from a producer to a consumer. It's given
            a single enumerator object that contains all of the production algorithms, a single
            destination channel from which consumers draw results, and (optionally) a
            synchronization primitive using which to notify asynchronous consumers.
            </summary>
      <typeparam name="TInputOutput">
      </typeparam>
      <typeparam name="TIgnoreKey">
      </typeparam>
    </member>
    <member name="M:System.Linq.Parallel.CancellableEnumerable.Wrap``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
      <summary>
            Wraps an enumerable with a cancellation checker. The enumerator handed out by the source enumerable
            will be wrapped by an object that periodically checks whether a particular cancellation token has
            been cancelled. If so, the next call to MoveNext() will throw an OperationCancelledException.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.ExceptionAggregator.WrapEnumerable``1(System.Collections.Generic.IEnumerable{``0},System.Linq.Parallel.CancellationState)">
      <summary>
            WrapEnumerable.ExceptionAggregator wraps the enumerable with another enumerator that will
            catch exceptions, and wrap each with an AggregateException.
            
            If PLINQ decides to execute a query sequentially, we will reuse LINQ-to-objects
            implementations for the different operators. However, we still need to throw
            AggregateException in the cases when parallel execution would have thrown an
            AggregateException. Thus, we introduce a wrapper enumerator that catches exceptions
            and wraps them with an AggregateException.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.ExceptionAggregator.WrapQueryEnumerator``2(System.Linq.Parallel.QueryOperatorEnumerator{``0,``1},System.Linq.Parallel.CancellationState)">
      <summary>
            A variant of WrapEnumerable that accepts a QueryOperatorEnumerator{,} instead of an IEnumerable{}.
            The code duplication is necessary to avoid extra virtual method calls that would otherwise be needed to
            convert the QueryOperatorEnumerator{,} to an IEnumerator{}.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.ExceptionAggregator.ThrowOCEorAggregateException(System.Exception,System.Linq.Parallel.CancellationState)">
      <summary>
            Accepts an exception, wraps it as if it was crossing the parallel-&gt;sequential boundary, and throws the
            wrapped exception. In sequential fallback cases, we use this method to throw exceptions that are consistent
            with exceptions thrown by PLINQ when the query is executed by worker tasks.
            
            The exception will be wrapped into an AggregateException, except for the case when the query is being
            legitimately cancelled, in which case we will propagate the CancellationException with the appropriate
            token.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.ExceptionAggregator.WrapFunc``2(System.Func{``0,``1},System.Linq.Parallel.CancellationState)">
      <summary>
            Wraps a function with a try/catch that morphs all exceptions into AggregateException.
            </summary>
      <typeparam name="T">The input argument type.</typeparam>
      <typeparam name="U">The return value type.</typeparam>
      <param name="f">A function to use internally.</param>
      <param name="cancellationState">The cancellation state to use.</param>
      <returns>A new function containing exception wrapping logic.</returns>
    </member>
    <member name="T:System.Linq.Parallel.ExchangeUtilities">
      <summary>
            ExchangeUtilities is a static class that contains helper functions to partition and merge
            streams. 
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.NoKeyMemoizationRequired">
      <summary>
            Used during hash partitioning, when the keys being memoized are not used for anything.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.FixedMaxHeap`1">
      <summary>
            Very simple heap data structure, of fixed size.
            </summary>
      <typeparam name="TElement">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.GrowingArray`1">
      <summary>
            A growing array. Unlike List{T}, it makes the internal array available to its user.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.HashLookup`2">
      <summary>
            A simple hash map data structure, derived from the LINQ set we also use.
            </summary>
      <typeparam name="TKey">The kind of keys contained within.</typeparam>
      <typeparam name="TValue">The kind of values contained within.</typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ListChunk`1">
      <summary>
            A linked list of array chunks. Allows direct access to its arrays.
            </summary>
      <typeparam name="TInputOutput">The elements held within.</typeparam>
    </member>
    <member name="M:System.Linq.Parallel.ListChunk`1.#ctor(System.Int32)">
      <summary>
            Allocates a new root chunk of a particular size.
            </summary>
    </member>
    <member name="M:System.Linq.Parallel.ListChunk`1.Add(`0)">
      <summary>
            Adds an element to this chunk.  Only ever called on the root.
            </summary>
      <param name="e">The new element.</param>
    </member>
    <member name="M:System.Linq.Parallel.ListChunk`1.GetEnumerator">
      <summary>
            Fetches an enumerator to walk the elements in all chunks rooted from this one.
            </summary>
    </member>
    <member name="P:System.Linq.Parallel.ListChunk`1.Next">
      <summary>
            The next chunk in the linked chain.
            </summary>
    </member>
    <member name="P:System.Linq.Parallel.ListChunk`1.Count">
      <summary>
            The number of elements contained within this particular chunk.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.Lookup`2">
      <summary>
             Lookup class implements the ILookup interface. Lookup is very similar to a dictionary
             except multiple values are allowed to map to the same key, and null keys are supported.
            
             Support for null keys adds an issue because the Dictionary class Lookup uses for
             storage does not support null keys. So, we need to treat null keys separately.
             Unfortunately, since TKey may be a value type, we cannot test whether the key is null
             using the user-specified equality comparer.
            
             C# does allow us to compare the key against null using the == operator, but there is a
             possibility that the user's equality comparer considers null to be equal to other values.
             Now, MSDN documentation specifies that if IEqualityComparer.Equals(x,y) returns true, it
             must be the case that x and y have the same hash code, and null has no hash code. Despite
             that, we might as well support the use case, even if it is bad practice.
            
             The solution the Lookup class uses is to treat the key default(TKey) as a special case,
             and hold its associated grouping - if any - in a special field instead of inserting it
             into a dictionary.
             </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TElement">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.Pair`2">
      <summary>
            A pair just wraps two bits of data into a single addressable unit. This is a
            value type to ensure it remains very lightweight, since it is frequently used
            with other primitive data types as well.
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="U">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.PairComparer`2">
      <summary>
            PairComparer compares pairs by the first element, and breaks ties by the second
            element.
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="U">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.ReverseComparer`1">
      <summary>
            Comparer that wraps another comparer, and flips the result of each comparison to the
            opposite answer.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.Set`1">
      <summary>
            A set for various operations. Shamelessly stolen from LINQ's source code.
            @TODO: can the Linq one be used directly now that we are in System.Core
            </summary>
      <typeparam name="TElement">The kind of elements contained within.</typeparam>
    </member>
    <member name="T:System.Linq.Parallel.Shared`1">
      <summary>
            A very simple primitive that allows us to share a value across multiple threads.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.Util">
      <summary>
            Common miscellaneous utility methods used throughout the code-base.
            </summary>
    </member>
    <member name="T:System.Linq.Parallel.Wrapper`1">
      <summary>
            A struct to wrap any arbitrary object reference or struct.  Used for situations
            where we can't tolerate null values (like keys for hashtables).
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.Parallel.WrapperEqualityComparer`1">
      <summary>
            Compares two wrapped structs of the same underlying type for equality.  Simply
            wraps the actual comparer for the type being wrapped.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:System.Linq.OrderedParallelQuery`1">
      <summary>
            Represents a sorted, parallel sequence.
            </summary>
    </member>
    <member name="M:System.Linq.OrderedParallelQuery`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the sequence.
            </summary>
      <returns>An enumerator that iterates through the sequence.</returns>
    </member>
    <member name="T:System.Linq.ParallelExecutionMode">
      <summary>
            The query execution mode is a hint that specifies how the system should handle
            performance trade-offs when parallelizing queries.
            </summary>
    </member>
    <member name="F:System.Linq.ParallelExecutionMode.Default">
      <summary>
            By default, the system will use algorithms for queries
            that are ripe for parallelism and will avoid algorithms with high 
            overheads that will likely result in slow downs for parallel execution. 
            </summary>
    </member>
    <member name="F:System.Linq.ParallelExecutionMode.ForceParallelism">
      <summary>
            Parallelize the entire query, even if that means using high-overhead algorithms.
            </summary>
    </member>
    <member name="T:System.Threading.Tasks.TaskExtensions">
      <summary>
            Provides a set of static (Shared in Visual Basic) methods for working with specific kinds of 
            <see cref="T:System.Threading.Tasks.Task" /> instances.
            </summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskExtensions.Unwrap(System.Threading.Tasks.Task{System.Threading.Tasks.Task})">
      <summary>
            Creates a proxy <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the 
            asynchronous operation of a Task{Task}.
            </summary>
      <remarks>
            It is often useful to be able to return a Task from a <see cref="T:System.Threading.Tasks.Task`1">
            Task{TResult}</see>, where the inner Task represents work done as part of the outer Task{TResult}.  However, 
            doing so results in a Task{Task}, which, if not dealt with carefully, could produce unexpected behavior.  Unwrap 
            solves this problem by creating a proxy Task that represents the entire asynchronous operation of such a Task{Task}.
            </remarks>
      <param name="task">The Task{Task} to unwrap.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown if the 
            <paramref name="task" /> argument is null.</exception>
      <returns>A Task that represents the asynchronous operation of the provided Task{Task}.</returns>
    </member>
    <member name="M:System.Threading.Tasks.TaskExtensions.Unwrap``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})">
      <summary>
            Creates a proxy <see cref="T:System.Threading.Tasks.Task`1">Task{TResult}</see> that represents the 
            asynchronous operation of a Task{Task{TResult}}.
            </summary>
      <remarks>
            It is often useful to be able to return a Task{TResult} from a Task{TResult}, where the inner Task{TResult} 
            represents work done as part of the outer Task{TResult}.  However, doing so results in a Task{Task{TResult}}, 
            which, if not dealt with carefully, could produce unexpected behavior.  Unwrap solves this problem by 
            creating a proxy Task{TResult} that represents the entire asynchronous operation of such a Task{Task{TResult}}.
            </remarks>
      <param name="task">The Task{Task{TResult}} to unwrap.</param>
      <exception cref="T:System.ArgumentNullException">The exception that is thrown if the 
            <paramref name="task" /> argument is null.</exception>
      <returns>A Task{TResult} that represents the asynchronous operation of the provided Task{Task{TResult}}.</returns>        /// <summary>Unwraps a Task that returns another Task.</summary></member>
  </members>
</doc>